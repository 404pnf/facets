<br/><b>Class: Enumerable</b><hr />
TODO: Consider Enumerator methods<p />
<hr />
This is a simple reimplementation of the core Enumerable module to allow the methods to take and pass-on arbitrary arguments to the underlying #each call. This library uses Enumerator and scans Enumerable so it can alwasy stay in sync.<p />
NOTE Any Enumerable method with a negative arity cannot do pass arguments due to ambiguity in the argument count. So the methods #inject and #zip do NOT work this way, but simply work as they do in Enumerable. The method #find (and #detect) though has been made to work by removing its rarely used optional parameter and providing instead an optional keyword parameter (:ifnone =&gt; ...). Please keep these difference in mind.<p />
<pre>  require 'enumargs'

  class T
    include Enumerable::Arguments
    def initialize(arr)
      @arr = arr
    end
    def each(n)
      arr.each{ |e| yield(e+n) }
    end
  end

  t = T.new([1,2,3])
  t.collect(4)
  #=&amp;gt; [5,6,7]
</pre>
<hr />
<br/><br/>