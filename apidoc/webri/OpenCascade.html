<br/><b>Class: OpenCascade < OpenObject</b><hr />
<h1>OpenCascade</h1>
OpenCascade is subclass of OpenObject. It differs in a few significant ways.<p />
The main reason this class is labeled &quot;cascade&quot;, every internal Hash is transformed into an OpenCascade dynamically upon access. This makes it easy to create &quot;cascading&quot; references.<p />
<pre>  h = { :x =&amp;gt; { :y =&amp;gt; { :z =&amp;gt; 1 } } }
  c = OpenCascade[h]
  c.x.y.z  #=&amp;gt; 1
</pre>
As soon as you access a node it automatically becomes an OpenCascade.<p />
<pre>  c = OpenCascade.new   #=&amp;gt; #&amp;lt;OpenCascade:0x7fac3680ccf0 {}&amp;gt;
  c.r                   #=&amp;gt; #&amp;lt;OpenCascade:0x7fac368084c0 {}&amp;gt;
  c.a.b                 #=&amp;gt; #&amp;lt;OpenCascade:0x7fac3680a4f0 {}&amp;gt;
</pre>
But if you set a node, then that will be it's value.<p />
<pre>  c.a.b = 4             #=&amp;gt; 4
</pre>
To query a node without causing the auto-creation of an OpenCasade object, use the ?-mark.<p />
<pre>  c.a.z?                #=&amp;gt; nil
</pre>
Finally, you can set a node and get the reciever back using the !-mark.<p />
<pre>  c = OpenCascade.new   #=&amp;gt; #&amp;lt;OpenCascade:0x7fac3680ccf0 {}&amp;gt;
  c.x!(4).y!(3)         #=&amp;gt; #&amp;lt;OpenCascade:0x7fac3680ccf0 {:x=&amp;gt;4, :y=&amp;gt;3}&amp;gt;
</pre>
<hr />
<p />
<h2>Instance methods:</h2>
method_missing<br/><br/>