{"(metadata)":{"source":["var"],"authors":[{"name":"Thomas Sawyer","email":"transfire@gmail.com"}],"copyrights":[{"holder":"Thomas Sawyer","year":"2004","license":"Ruby"}],"replacements":[],"alternatives":[],"requirements":[{"name":"lemon","groups":["test"],"development":null},{"name":"qed","groups":["test"],"development":null},{"name":"detroit","groups":["build"],"development":null}],"dependencies":[],"conflicts":[],"repositories":[{"uri":"git@github.com:rubyworks/facets.git","scm":"git","name":"upstream"}],"resources":{"home":"http://rubyworks.github.com/facets","code":"http://github.com/rubyworks/facets","docs":"http://rubyworks.github.com/facets/learn.html","wiki":"http://wiki.github.com/rubyworks/facets","talk":"http://groups.google.com/group/facets-universal"},"extra":{},"load_path":["lib/core","lib/standard"],"revision":null,"created":"2004-12-16","summary":"Premium Ruby Extensions","title":"Facets","version":"2.9.3","scm_uri":"https://github.com/rubyworks/facets/tree/master","name":"facets","description":"Facets is the premier collection of extension methods for the Ruby programming language. Facets extensions are unique by virtue of thier atomicity. They are stored in individual files allowing for highly granular control of requirements. In addition, Facets includes a few additional classes and mixins suitable to wide variety of applications.","organization":"rubyworks","date":"2012-01-02","path":"(metadata)","markup":"rdoc"},"URI":{"!":"module","path":"URI","name":"URI","namespace":"","comment":"","format":"rdoc","constants":["URI::KEY_VALUE_SEPARATOR"],"includes":[],"extensions":[],"modules":["URI::Kernel","URI::Hash"],"classes":[],"methods":["URI#decode","URI#query_to_hash","URI#query_string_to_hash","URI#hash_to_query","URI#hash_to_query_string","URI#cgi_escape","URI#cgi_unescape","URI#cgi_parse","URI#get_query_string","URI#chomp_query_string","URI#update_query_string","URI#update_request_uri"],"accessors":[],"files":["/lib/standard/facets/uri.rb"],"tags":{}},"URI::KEY_VALUE_SEPARATOR":{"!":"constant","path":"URI::KEY_VALUE_SEPARATOR","name":"KEY_VALUE_SEPARATOR","namespace":"URI","comment":"\"&\"","format":"rdoc","value":"\";\"","tags":{},"files":["/lib/standard/facets/uri.rb"]},"URI#decode":{"!":"method","declarations":["instance","public"],"path":"URI#decode","name":"decode","namespace":"URI","comment":"Decode the uri components.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"decode(uri)","arguments":[{"name":"uri"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def decode(uri)\n  ## gmosx: hmm is this needed?\n  ## guard against invalid filenames for example pictures with\n  ## spaces uploaded by users\n  escaped_uri = uri.gsub(/ /, \"+\")\n\n  if md = URI::REGEXP::REL_URI.match(escaped_uri)\n    path = \"#{md[5]}#{md[6]}\"\n    type = File.extname(path)\n    query_string = md[7]\n\n    ## real_path = \"#{$root_dir}/#{path}\"\n\n    parameters = URI.query_to_hash(query_string)\n    path.gsub!(/\\+/, \" \")\n\n    return [path, type, parameters, query_string]\n  end\n\n  ## this is usefull for uncovering bugs!\n  raise ArgumentError.new(\"the parameter '#{uri}' is not a valid uri\")\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"URI#query_to_hash":{"!":"method","declarations":["instance","public"],"path":"URI#query_to_hash","name":"query_to_hash","namespace":"URI","comment":"Extend the basic query string parser provided by the cgi module.\nconverts single valued params (the most common case) to\nobjects instead of arrays\n\nReturns hash of parameters, contains arrays for multivalued parameters\n(multiselect, checkboxes , etc).\n\nIf no query string is provided (nil or \"\") returns an empty hash.","format":"rdoc","aliases":["URI#query_string_to_hash"],"singleton":null,"interfaces":[{"signature":"query_to_hash(query_string)","arguments":[{"name":"query_string"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def query_to_hash(query_string)\n  return {} unless query_string\n\n  query_parameters = cgi_parse(query_string)\n\n  query_parameters.each { |key, val|\n    ## replace the array with an object\n    query_parameters[key] = val[0] if 1 == val.length\n  }\n\n  ## set default value to nil! cgi sets this to []\n  query_parameters.default = nil\n\n  return query_parameters\nend","language":"ruby","dynamic":null,"tags":{}},"URI#query_string_to_hash":{"!":"method","declarations":["instance","public"],"path":"URI#query_string_to_hash","name":"query_string_to_hash","namespace":"URI","comment":"Extend the basic query string parser provided by the cgi module.\nconverts single valued params (the most common case) to\nobjects instead of arrays\n\nReturns hash of parameters, contains arrays for multivalued parameters\n(multiselect, checkboxes , etc).\n\nIf no query string is provided (nil or \"\") returns an empty hash.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"query_to_hash(query_string)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def query_to_hash(query_string)\n  return {} unless query_string\n\n  query_parameters = cgi_parse(query_string)\n\n  query_parameters.each { |key, val|\n    ## replace the array with an object\n    query_parameters[key] = val[0] if 1 == val.length\n  }\n\n  ## set default value to nil! cgi sets this to []\n  query_parameters.default = nil\n\n  return query_parameters\nend","language":"ruby","dynamic":null,"tags":{}},"URI#hash_to_query":{"!":"method","declarations":["instance","public"],"path":"URI#hash_to_query","name":"hash_to_query","namespace":"URI","comment":"Given a hash with parameter/value pairs construct a\nstandard query string.\n\n  URI.hash_to_query(:a => 1, :b => 2)\n  #=> \"a=1;b=2\"","format":"rdoc","aliases":["URI#hash_to_query_string"],"singleton":null,"interfaces":[{"signature":"hash_to_query(parameters)","arguments":[{"name":"parameters"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def hash_to_query(parameters)\n  return '' unless parameters\n  pairs = []\n  parameters.each do |param, value|\n    pairs << \"#{param}=#{cgi_escape(value.to_s)}\"\n  end\n  return pairs.join(KEY_VALUE_SEPARATOR)\nend","language":"ruby","dynamic":null,"tags":{}},"URI#hash_to_query_string":{"!":"method","declarations":["instance","public"],"path":"URI#hash_to_query_string","name":"hash_to_query_string","namespace":"URI","comment":"Given a hash with parameter/value pairs construct a\nstandard query string.\n\n  URI.hash_to_query(:a => 1, :b => 2)\n  #=> \"a=1;b=2\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"hash_to_query(parameters)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def hash_to_query(parameters)\n  return '' unless parameters\n  pairs = []\n  parameters.each do |param, value|\n    pairs << \"#{param}=#{cgi_escape(value.to_s)}\"\n  end\n  return pairs.join(KEY_VALUE_SEPARATOR)\nend","language":"ruby","dynamic":null,"tags":{}},"URI#cgi_escape":{"!":"method","declarations":["instance","public"],"path":"URI#cgi_escape","name":"cgi_escape","namespace":"URI","comment":"CGI escape\n\nTODO: How does this compare to URI.escape?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cgi_escape(string)","arguments":[{"name":"string"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def cgi_escape(string)\n  string.gsub(/([^ a-zA-Z0-9_.-]+)/n) do\n    '%' + $1.unpack('H2' * $1.size).join('%').upcase\n  end.tr(' ', '+')\nend","language":"ruby","dynamic":null,"tags":{}},"URI#cgi_unescape":{"!":"method","declarations":["instance","public"],"path":"URI#cgi_unescape","name":"cgi_unescape","namespace":"URI","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cgi_unescape(string)","arguments":[{"name":"string"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def cgi_unescape(string)\n  string.tr('+', ' ').gsub(/((?:%[0-9a-fA-F]{2})+)/n) do\n    [$1.delete('%')].pack('H*')\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"URI#cgi_parse":{"!":"method","declarations":["instance","public"],"path":"URI#cgi_parse","name":"cgi_parse","namespace":"URI","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cgi_parse(query)","arguments":[{"name":"query"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def cgi_parse(query)\n  params = Hash.new([].freeze)\n\n  query.split(/[&;]/n).each do |pairs|\n    key, value = pairs.split('=',2).collect{|v| cgi_unescape(v) }\n    if params.has_key?(key)\n      params[key].push(value)\n    else\n      params[key] = [value]\n    end\n  end\n\n  params\nend","language":"ruby","dynamic":null,"tags":{}},"URI#get_query_string":{"!":"method","declarations":["instance","public"],"path":"URI#get_query_string","name":"get_query_string","namespace":"URI","comment":"This method returns the query string of a uri\n\nInput:\nthe uri\n\nOutput:\nthe query string.\nreturns nil if no query string","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"get_query_string(uri)","arguments":[{"name":"uri"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def get_query_string(uri)\n  return nil unless uri\n  # gmosx: INVESTIGATE ruby's URI seems to differently handle\n  # abs and rel uris.\n  if md = URI::REGEXP::ABS_URI.match(uri)\n    return md[8]\n  elsif md = URI::REGEXP::REL_URI.match(uri)\n    return md[7]\n  end\n  return nil\nend","language":"ruby","dynamic":null,"tags":{}},"URI#chomp_query_string":{"!":"method","declarations":["instance","public"],"path":"URI#chomp_query_string","name":"chomp_query_string","namespace":"URI","comment":"Removes the query string from a +uri+.\n\nReturns the chomped uri.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"chomp_query_string(uri)","arguments":[{"name":"uri"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def chomp_query_string(uri)\n  return nil unless uri\n  query_string = self.get_query_string(uri)\n  return uri.dup.chomp(\"?#{query_string}\")\nend","language":"ruby","dynamic":null,"tags":{}},"URI#update_query_string":{"!":"method","declarations":["instance","public"],"path":"URI#update_query_string","name":"update_query_string","namespace":"URI","comment":"Get a uri and a hash of parameters. Inject the hash values\nas parameters in the query sting path. Returns the full uri.\n\nuri       - the uri to filter (String)\nparameter - hash of parameters to update\n\nReturns the full updated query string.\n\nTODO: optimize","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"update_query_string(uri, parameters)","arguments":[{"name":"uri"},{"name":"parameters"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def update_query_string(uri, parameters)\n  query_string = self.get_query_string(uri)\n  rest = uri.dup.gsub(/\\?#{query_string}/, \"\")\n\n  hash = self.query_string_to_hash(query_string)\n  hash.update(parameters)\n  query_string = self.hash_to_query_string(hash)\n\n  unless query_string.blank?\n    return \"#{rest}?#{query_string}\"\n  else\n    return rest\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"URI#update_request_uri":{"!":"method","declarations":["instance","public"],"path":"URI#update_request_uri","name":"update_request_uri","namespace":"URI","comment":"Gets the request uri, injects extra parameters in the query string\nand returns a new uri. The request object is not modified.\nThere is always a qs string so an extra test is skipped.\n\nTODO: find a better name?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"update_request_uri(request, parameters)","arguments":[{"name":"request"},{"name":"parameters"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def update_request_uri(request, parameters)\n  hash = request.parameters.dup()\n  hash.update(parameters)\n\n  ## use this in hash_to_querystring.\n  query_string = hash.collect { |k, v|\n    \"#{k}=#{v}\"\n  }.join(\";\")\n\n  ## return \"#{request.translated_uri}?#{query_string}\"\n  return \"#{request.path}?#{query_string}\"\nend","language":"ruby","dynamic":null,"tags":{}},"URI::Kernel":{"!":"module","path":"URI::Kernel","name":"Kernel","namespace":"URI","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["URI::Kernel#uri","URI::Kernel#unuri"],"accessors":[],"files":["/lib/standard/facets/uri.rb"],"tags":{}},"URI::Kernel#uri":{"!":"method","declarations":["instance","public"],"path":"URI::Kernel#uri","name":"uri","namespace":"URI::Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"uri(s, w=%r{[^a-zA-Z_0-9./-]})","arguments":[{"name":"s"},{"name":"w","default":"%r{[^a-zA-Z_0-9./-]}"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def uri(s, w=%r{[^a-zA-Z_0-9./-]})\n  URI.escape(s, w)\nend","language":"ruby","dynamic":null,"tags":{}},"URI::Kernel#unuri":{"!":"method","declarations":["instance","public"],"path":"URI::Kernel#unuri","name":"unuri","namespace":"URI::Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unuri(s)","arguments":[{"name":"s"}]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def unuri(s)\n  URI.unescape(s)\nend","language":"ruby","dynamic":null,"tags":{}},"URI::Hash":{"!":"module","path":"URI::Hash","name":"Hash","namespace":"URI","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["URI::Hash#to_uri"],"accessors":[],"files":["/lib/standard/facets/uri.rb"],"tags":{}},"URI::Hash#to_uri":{"!":"method","declarations":["instance","public"],"path":"URI::Hash#to_uri","name":"to_uri","namespace":"URI::Hash","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_uri()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/uri.rb","line":null,"source":"def to_uri\n  URI.hash_to_query(self)\nend","language":"ruby","dynamic":null,"tags":{}},"Object":{"!":"class","superclass":"BasicObject","path":"Object","name":"Object","namespace":"","comment":":nodoc:","format":"rdoc","constants":[],"includes":["URI::Kernel"],"extensions":[],"modules":[],"classes":[],"methods":["Object#null?"],"accessors":[],"files":["/lib/standard/facets/uri.rb","/lib/standard/facets/nullclass.rb"],"tags":{}},"Hash":{"!":"class","superclass":"Object","path":"Hash","name":"Hash","namespace":"","comment":":nodoc:","format":"rdoc","constants":[],"includes":["Random::HashExtensions","URI::Hash"],"extensions":[],"modules":[],"classes":[],"methods":["Hash#to_ostruct","Hash#to_ostruct_recurse","Hash#shellwords","Hash#shelljoin"],"accessors":[],"files":["/lib/standard/facets/uri.rb","/lib/standard/facets/random.rb","/lib/standard/facets/ostruct.rb","/lib/standard/facets/shellwords.rb"],"tags":{}},"ERB::OpenTemplate":{"!":"class","superclass":"Object","path":"ERB::OpenTemplate","name":"OpenTemplate","namespace":"ERB","comment":"= OpenTemplate\n\nThe Erb OpenTemplate provides a quick and convenient way to\ncreate a clean rendering space with the desired responses.\n\nRuby 1.8.6 or less can't handle object scope methods with blocks.\n\nTODO: This might make a good addon library. Just add \nrequire 'erb' to the erb_result method? Call it OpenResponse?","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["ERB::OpenTemplate#initialize","ERB::OpenTemplate#erb_result"],"accessors":[],"files":["/lib/standard/facets/erb.rb"],"tags":{}},"Set":{"!":"class","superclass":"Object","path":"Set","name":"Set","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Set#power_set"],"accessors":[],"files":["/lib/standard/facets/set.rb"],"tags":{}},"Set#power_set":{"!":"method","declarations":["instance","public"],"path":"Set#power_set","name":"power_set","namespace":"Set","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"power_set()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/set.rb","line":null,"source":"def power_set\n  if empty?\n    Set[self]\n  else\n    any_value = [to_a.first]\n    subsubs = (self - any_value).power_set\n    subsubs + subsubs.map{ |subset| subset + any_value }\n  end\nend","language":"ruby","dynamic":null,"tags":{"author":"Phrogz"}},"Array":{"!":"class","superclass":"Object","path":"Array","name":"Array","namespace":"","comment":"","format":"rdoc","constants":[],"includes":["Random::ArrayExtensions"],"extensions":[],"modules":[],"classes":[],"methods":["Array#power_set","Array#to_t","Array#to_path","Array#shellwords","Array#shelljoin"],"accessors":[],"files":["/lib/standard/facets/set.rb","/lib/standard/facets/tuple.rb","/lib/standard/facets/random.rb","/lib/standard/facets/pathname.rb","/lib/standard/facets/shellwords.rb"],"tags":{}},"Array#power_set":{"!":"method","declarations":["instance","public"],"path":"Array#power_set","name":"power_set","namespace":"Array","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"power_set()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/set.rb","line":null,"source":"def power_set\n  if empty?\n    [self]\n  else\n    subset  = dup\n    value   = [ subset.pop ]\n    subsubs = subset.power_set\n    subsubs.concat( subsubs.map{ |subset| subset + value } )\n  end\nend","language":"ruby","dynamic":null,"tags":{"author":"Phrogz"}},"CGI":{"!":"class","superclass":"Object","path":"CGI","name":"CGI","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["CGI#marshal_to_cgi","CGI#marshal_from_cgi","CGI#esc","CGI#escformat","CGI.escape_html","CGI.unescape_html","CGI.escape_element","CGI.unescape_element"],"accessors":[],"files":["/lib/standard/facets/cgi.rb"],"tags":{}},"CGI#marshal_to_cgi":{"!":"method","declarations":["instance","public"],"path":"CGI#marshal_to_cgi","name":"marshal_to_cgi","namespace":"CGI","comment":"Create an hidden input field through which an object can can be marshalled.\nThis makes it very easy to pass from data betwenn requests.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"marshal_to_cgi(name, iobj)","arguments":[{"name":"name"},{"name":"iobj"}]}],"returns":[],"file":"/lib/standard/facets/cgi.rb","line":null,"source":"def marshal_to_cgi(name, iobj)\n  data = CGI.escape(Marshal.dump(iobj))\n  return %Q{<input type=\"hidden\" name=\"__#{name}__\" value=\"#{data}\"/>\\n}\nend","language":"ruby","dynamic":null,"tags":{}},"CGI#marshal_from_cgi":{"!":"method","declarations":["instance","public"],"path":"CGI#marshal_from_cgi","name":"marshal_from_cgi","namespace":"CGI","comment":"Create an hidden input field through which an object can can be marshalled.\nThis makes it very easy to pass from data between requests.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"marshal_from_cgi(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/standard/facets/cgi.rb","line":null,"source":"def marshal_from_cgi(name)\n  if self.params.has_key?(\"__#{name}__\")\n    return Marshal.load(CGI.unescape(self[\"__#{name}__\"][0]))\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"CGI#esc":{"!":"method","declarations":["instance","public"],"path":"CGI#esc","name":"esc","namespace":"CGI","comment":"Return an html \"safe\" version of the string,\nwhere every &, < and > are replaced with appropriate entities.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"esc(str)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/standard/facets/cgi.rb","line":null,"source":"def esc(str)\n  str.gsub(/&/,'&amp;').gsub(/</,'&lt;').gsub(/>/,'&gt;')\nend","language":"ruby","dynamic":null,"tags":{}},"CGI#escformat":{"!":"method","declarations":["instance","public"],"path":"CGI#escformat","name":"escformat","namespace":"CGI","comment":"Calls #esc, and then further replaces carriage returns and quote characters with entities.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"escformat(str)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/standard/facets/cgi.rb","line":null,"source":"def escformat(str)\n  esc(str).gsub(/[\\r\\n]+/,'&#13;&#10;').gsub(%r|\"|,'&quot;').gsub(%r|'|,'&#39;')\nend","language":"ruby","dynamic":null,"tags":{}},"CGI.escape_html":{"!":"method","declarations":["class","public"],"path":"CGI.escape_html","name":"escape_html","namespace":"CGI","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"escape_html","arguments":[]}],"returns":[],"file":"/lib/standard/facets/cgi.rb","line":null,"source":"alias :escape_html :escapeHTML","language":"ruby","dynamic":null,"tags":{}},"CGI.unescape_html":{"!":"method","declarations":["class","public"],"path":"CGI.unescape_html","name":"unescape_html","namespace":"CGI","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unescape_html","arguments":[]}],"returns":[],"file":"/lib/standard/facets/cgi.rb","line":null,"source":"alias :unescape_html :unescapeHTML","language":"ruby","dynamic":null,"tags":{}},"CGI.escape_element":{"!":"method","declarations":["class","public"],"path":"CGI.escape_element","name":"escape_element","namespace":"CGI","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"escape_element","arguments":[]}],"returns":[],"file":"/lib/standard/facets/cgi.rb","line":null,"source":"alias :escape_element :escapeElement","language":"ruby","dynamic":null,"tags":{}},"CGI.unescape_element":{"!":"method","declarations":["class","public"],"path":"CGI.unescape_element","name":"unescape_element","namespace":"CGI","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unescape_element","arguments":[]}],"returns":[],"file":"/lib/standard/facets/cgi.rb","line":null,"source":"alias :unescape_element :unescapeElement","language":"ruby","dynamic":null,"tags":{}},"Date":{"!":"class","superclass":"Object","path":"Date","name":"Date","namespace":"","comment":"= Date\n\nThis new version of Date extension has been largely improved by\nporting some of the methods used by ActiveSupport. The old version\nalready had much in common with the Active Support library, so it\nwas decided to take it a step further in that direction for the\nsake of interoparability.\n\nHopefully most of these methods will find there way into Ruby's\nown standard library eventually.\n\nThe biggest difference with ActiveSupport is the lack of many\nof the \"English-esque\" methods, and that we use #stamp with\nDate::FORMAT, instead of #to_formmated_s with Date::DATE_FORMATS.\nWe do not override the standard #to_s method like ActiveSupport does.","format":"rdoc","constants":["Date::FORMAT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Date.yesterday","Date.tomorrow","Date.current","Date#to_date","Date#to_datetime","Date#to_time","Date#xmlschema","Date#days_in_month","Date#days_of_month","Date#month_name","Date#stamp","Date#advance","Date#change","Date#ago","Date#since","Date#in","Date#beginning_of_day","Date#midnight","Date#yesterday","Date#tomorrow"],"accessors":[],"files":["/lib/standard/facets/date.rb"],"tags":{}},"Date::FORMAT":{"!":"constant","path":"Date::FORMAT","name":"FORMAT","namespace":"Date","comment":"","format":"rdoc","value":"{\n  :short        => \"%e %b\",\n  :long         => \"%B %e, %Y\",\n  :db           => \"%Y-%m-%d\",\n  :number       => \"%Y%m%d\",\n  :rfc822       => \"%e %b %Y\",\n  :default      => \"%Y-%m-%d\",\n  nil           => \"%Y-%m-%d\"\n}","tags":{},"files":["/lib/standard/facets/date.rb"]},"Date.yesterday":{"!":"method","declarations":["class","public"],"path":"Date.yesterday","name":"yesterday","namespace":"Date","comment":"Returns a new Date representing the date 1 day ago (i.e. yesterday's date).","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"yesterday(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def self.yesterday\n  ::Date.today.yesterday\nend","language":"ruby","dynamic":null,"tags":{}},"Date.tomorrow":{"!":"method","declarations":["class","public"],"path":"Date.tomorrow","name":"tomorrow","namespace":"Date","comment":"Returns a new Date representing the date 1 day after today (i.e. tomorrow's date).","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tomorrow(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def self.tomorrow\n  ::Date.today.tomorrow\nend","language":"ruby","dynamic":null,"tags":{}},"Date.current":{"!":"method","declarations":["class","public"],"path":"Date.current","name":"current","namespace":"Date","comment":"Returns Time.zone.today when config.time_zone is set, otherwise just returns Date.today.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"current(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def self.current\n  ::Time.zone_default ? ::Time.zone.today : ::Date.today\nend","language":"ruby","dynamic":null,"tags":{}},"Date#to_date":{"!":"method","declarations":["instance","public"],"path":"Date#to_date","name":"to_date","namespace":"Date","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_date()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_date\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Date#to_datetime":{"!":"method","declarations":["instance","public"],"path":"Date#to_datetime","name":"to_datetime","namespace":"Date","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_datetime()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_datetime\n  ::DateTime.civil(year, month, day, 0, 0, 0, 0)\nend","language":"ruby","dynamic":null,"tags":{}},"Date#to_time":{"!":"method","declarations":["instance","public"],"path":"Date#to_time","name":"to_time","namespace":"Date","comment":"Converts a Date instance to a Time, where the time is set to the beginning of the day.\nThe timezone can be either :local or :utc (default :local).\n\n  date = Date.new(2007, 11, 10)  # Sat, 10 Nov 2007\n\n  date.to_time                   # Sat Nov 10 00:00:00 0800 2007\n  date.to_time(:local)           # Sat Nov 10 00:00:00 0800 2007\n\n  date.to_time(:utc)             # Sat Nov 10 00:00:00 UTC 2007","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_time(form=:local)","arguments":[{"name":"form","default":":local"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_time(form=:local)\n  ::Time.send(form, year, month, day)\n  ##::Time.send(\"#{form}_time\", year, month, day)\nend","language":"ruby","dynamic":null,"tags":{}},"Date#xmlschema":{"!":"method","declarations":["instance","public"],"path":"Date#xmlschema","name":"xmlschema","namespace":"Date","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"xmlschema()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def xmlschema\n  to_time.xmlschema\nend","language":"ruby","dynamic":null,"tags":{}},"Date#days_in_month":{"!":"method","declarations":["instance","public"],"path":"Date#days_in_month","name":"days_in_month","namespace":"Date","comment":"Returns the number of days in the date's month.\n\n  Date.new(2004,2).days_in_month  #=> 29\n\nCREDIT: Ken Kunz.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"days_in_month()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def days_in_month\n   Date.civil(year, month, -1).day\nend","language":"ruby","dynamic":null,"tags":{}},"Date#days_of_month":{"!":"method","declarations":["instance","public"],"path":"Date#days_of_month","name":"days_of_month","namespace":"Date","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"days_of_month()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def days_of_month\n  (1..days_in_month).to_a\nend","language":"ruby","dynamic":null,"tags":{}},"Date#month_name":{"!":"method","declarations":["instance","public"],"path":"Date#month_name","name":"month_name","namespace":"Date","comment":"Get the month name for this date object\n\nCREDIT: Benjamin Oakes","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"month_name()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def month_name\n  MONTHNAMES[self.month]\nend","language":"ruby","dynamic":null,"tags":{}},"Date#stamp":{"!":"method","declarations":["instance","public"],"path":"Date#stamp","name":"stamp","namespace":"Date","comment":"Convert to a formatted string. See DATE_FORMATS for predefined formats.\n\nThis method is aliased to <tt>to_s</tt>.\n\n  date = Date.new(2007, 11, 10)   # Sat, 10 Nov 2007\n\n  date.stamp(:db)                 # => \"2007-11-10\"\n  date.stamp(:short)              # => \"10 Nov\"\n  date.stamp(:long)               # => \"November 10, 2007\"\n  date.stamp(:rfc822)             # => \"10 Nov 2007\"\n\n== Adding your own formats to stamp\nYou can add your own formats to the Date::FORMAT hash.\nUse the format name as the hash key and a strftime string\nas the value. Eg.\n\n  Date::FORMAT[:month_and_year] = \"%B %Y\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stamp(format=:default)","arguments":[{"name":"format","default":":default"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def stamp(format=:default)\n  if formatter = FORMAT[format]\n    strftime(formatter)\n  else\n    to_s\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Date#advance":{"!":"method","declarations":["instance","public"],"path":"Date#advance","name":"advance","namespace":"Date","comment":"Provides precise Date calculations for years, months, and days.\nThe +options+ parameter takes a hash with  any of these keys:\n<tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"advance(options)","arguments":[{"name":"options"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def advance(options)\n  d = self\n  d = d >> options.delete(:years) * 12 if options[:years]\n  d = d >> options.delete(:months)     if options[:months]\n  d = d +  options.delete(:weeks) * 7  if options[:weeks]\n  d = d +  options.delete(:days)       if options[:days]\n  d\nend","language":"ruby","dynamic":null,"tags":{}},"Date#change":{"!":"method","declarations":["instance","public"],"path":"Date#change","name":"change","namespace":"Date","comment":"Returns a new Date where one or more of the elements have been changed\naccording to the +options+ parameter.\n\n  Date.new(2007, 5, 12).change(:day=>1)                 # Date.new(2007, 5, 1)\n  Date.new(2007, 5, 12).change(:year=>2005, :month=>1)  # Date.new(2005, 1, 12)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"change(options)","arguments":[{"name":"options"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def change(options)\n  ::Date.new(\n    options[:year]  || self.year,\n    options[:month] || self.month,\n    options[:day]   || self.day\n  )\nend","language":"ruby","dynamic":null,"tags":{}},"Date#ago":{"!":"method","declarations":["instance","public"],"path":"Date#ago","name":"ago","namespace":"Date","comment":"Converts Date to a Time (or DateTime if necessary) with the time portion\nset to the beginning of the day (0:00) and then subtracts the specified\nnumber of seconds","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ago(seconds)","arguments":[{"name":"seconds"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def ago(seconds)\n  to_time.since(-seconds)\nend","language":"ruby","dynamic":null,"tags":{}},"Date#since":{"!":"method","declarations":["instance","public"],"path":"Date#since","name":"since","namespace":"Date","comment":"Converts Date to a Time (or DateTime if necessary) with the time portion\nset to the beginning of the day (0:00) and then adds the specified number\nof seconds.","format":"rdoc","aliases":["Date#in"],"singleton":null,"interfaces":[{"signature":"since(seconds)","arguments":[{"name":"seconds"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def since(seconds)\n  to_time.since(seconds)\nend","language":"ruby","dynamic":null,"tags":{}},"Date#in":{"!":"method","declarations":["instance","public"],"path":"Date#in","name":"in","namespace":"Date","comment":"Converts Date to a Time (or DateTime if necessary) with the time portion\nset to the beginning of the day (0:00) and then adds the specified number\nof seconds.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"since(seconds)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def since(seconds)\n  to_time.since(seconds)\nend","language":"ruby","dynamic":null,"tags":{}},"Date#beginning_of_day":{"!":"method","declarations":["instance","public"],"path":"Date#beginning_of_day","name":"beginning_of_day","namespace":"Date","comment":"Converts Date to a Time (or DateTime if necessary) with the time portion\nset to the beginning of the day (0:00).","format":"rdoc","aliases":["Date#midnight"],"singleton":null,"interfaces":[{"signature":"beginning_of_day()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def beginning_of_day\n  to_time\nend","language":"ruby","dynamic":null,"tags":{}},"Date#midnight":{"!":"method","declarations":["instance","public"],"path":"Date#midnight","name":"midnight","namespace":"Date","comment":"Converts Date to a Time (or DateTime if necessary) with the time portion\nset to the beginning of the day (0:00).","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"beginning_of_day()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def beginning_of_day\n  to_time\nend","language":"ruby","dynamic":null,"tags":{}},"Date#yesterday":{"!":"method","declarations":["instance","public"],"path":"Date#yesterday","name":"yesterday","namespace":"Date","comment":"Convenience method which returns a new Date/DateTime representing the\ntime 1 day ago.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"yesterday()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def yesterday\n  self - 1\nend","language":"ruby","dynamic":null,"tags":{}},"Date#tomorrow":{"!":"method","declarations":["instance","public"],"path":"Date#tomorrow","name":"tomorrow","namespace":"Date","comment":"Convenience method which returns a new Date/DateTime representing\nthe time 1 day since the instance time.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tomorrow()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def tomorrow\n  self + 1\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime":{"!":"class","superclass":"Object","path":"DateTime","name":"DateTime","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["DateTime.local_offset","DateTime#future?","DateTime#past?","DateTime#to_date","DateTime#to_time","DateTime#to_datetime","DateTime#stamp","DateTime#seconds_since_midnight","DateTime#change","DateTime#advance","DateTime#ago","DateTime#since","DateTime#in","DateTime#beginning_of_day","DateTime#midnight","DateTime#end_of_day","DateTime#utc","DateTime#getutc","DateTime#utc?","DateTime#utc_offset","DateTime#xmlschema","DateTime#to_f"],"accessors":[],"files":["/lib/standard/facets/date.rb"],"tags":{}},"DateTime.local_offset":{"!":"method","declarations":["class","public"],"path":"DateTime.local_offset","name":"local_offset","namespace":"DateTime","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"local_offset(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def self.local_offset\n  ::Time.local(2007).utc_offset.to_r / 86400\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#future?":{"!":"method","declarations":["instance","public"],"path":"DateTime#future?","name":"future?","namespace":"DateTime","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"future?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/date.rb","line":null,"source":"def future?\n  self > ::DateTime.current\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#past?":{"!":"method","declarations":["instance","public"],"path":"DateTime#past?","name":"past?","namespace":"DateTime","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"past?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/date.rb","line":null,"source":"def past?\n  self < ::DateTime.current\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#to_date":{"!":"method","declarations":["instance","public"],"path":"DateTime#to_date","name":"to_date","namespace":"DateTime","comment":"Converts self to a Ruby Date object; time portion is discarded","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_date()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_date\n  ::Date.new(year, month, day)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#to_time":{"!":"method","declarations":["instance","public"],"path":"DateTime#to_time","name":"to_time","namespace":"DateTime","comment":"Attempts to convert self to a Ruby Time object; returns self if\nout of range of Ruby Time class. If self has an offset other than 0,\nself will just be returned unaltered, since there's no clean way\nto map it to a Time.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_time()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_time\n  self.offset == 0 ? ::Time.utc_time(year, month, day, hour, min, sec) : self\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#to_datetime":{"!":"method","declarations":["instance","public"],"path":"DateTime#to_datetime","name":"to_datetime","namespace":"DateTime","comment":"To be able to keep Times, Dates and DateTimes interchangeable on conversions","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_datetime()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_datetime\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#stamp":{"!":"method","declarations":["instance","public"],"path":"DateTime#stamp","name":"stamp","namespace":"DateTime","comment":"Convert to a formatted string. See Time::FORMAT for predefined formats.\n\nThis method is aliased to <tt>to_s</tt>.\n\n  datetime = DateTime.civil(2007,12,4,0,0,0,0)   # Tue, 04 Dec 2007 00:00:00 +0000\n\n  datetime.stamp(:db)            # => \"2007-12-04 00:00:00\"\n  datetime.stamp(:db)            # => \"2007-12-04 00:00:00\"\n  datetime.stamp(:number)        # => \"20071204000000\"\n  datetime.stamp(:short)         # => \"04 Dec 00:00\"\n  datetime.stamp(:long)          # => \"December 04, 2007 00:00\"\n  datetime.stamp(:rfc822)        # => \"Tue, 04 Dec 2007 00:00:00 +0000\"\n\n== Adding your own datetime formats to stamp\n\nDateTime formats are shared with Time. You can add your own to the\nTime::FORMAT hash. Use the format name as the hash key and\na strftime string as the value. Eg.\n\n  Time::FORMAT[:month_and_year] = \"%B %Y\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stamp(format=:default)","arguments":[{"name":"format","default":":default"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def stamp(format=:default)\n  if formatter = ::Time::FORMAT[format]\n    strftime(formatter)\n  else\n    to_s\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#seconds_since_midnight":{"!":"method","declarations":["instance","public"],"path":"DateTime#seconds_since_midnight","name":"seconds_since_midnight","namespace":"DateTime","comment":"Seconds since midnight: DateTime.now.seconds_since_midnight","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"seconds_since_midnight()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def seconds_since_midnight\n  self.sec + (self.min * 60) + (self.hour * 3600)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#change":{"!":"method","declarations":["instance","public"],"path":"DateTime#change","name":"change","namespace":"DateTime","comment":"Returns a new DateTime where one or more of the elements have been\nchanged according to the +options+ parameter. The time options\n(hour, minute, sec) reset cascadingly, so if only the hour is \npassed, then minute and sec is set to 0. If the hour and\nminute is passed, then sec is set to 0.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"change(options)","arguments":[{"name":"options"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def change(options)\n  ::DateTime.civil(\n    options[:year]  || self.year,\n    options[:month] || self.month,\n    options[:day]   || self.day,\n    options[:hour]  || self.hour,\n    options[:min]   || (options[:hour] ? 0 : self.min),\n    options[:sec]   || ((options[:hour] || options[:min]) ? 0 : self.sec),\n    options[:offset]  || self.offset,\n    options[:start]  || self.start\n  )\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#advance":{"!":"method","declarations":["instance","public"],"path":"DateTime#advance","name":"advance","namespace":"DateTime","comment":"Uses Date to provide precise Time calculations for years, months, and days.\nThe +options+ parameter takes a hash with any of these keys: <tt>:years</tt>,\n<tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>,\n<tt>:minutes</tt>, <tt>:seconds</tt>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"advance(options)","arguments":[{"name":"options"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def advance(options)\n  d = to_date.advance(options)\n  datetime_advanced_by_date = change(:year => d.year, :month => d.month, :day => d.day)\n  seconds_to_advance = (options[:seconds] || 0) + (options[:minutes] || 0) * 60 + (options[:hours] || 0) * 3600\n  seconds_to_advance == 0 ? datetime_advanced_by_date : datetime_advanced_by_date.since(seconds_to_advance)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#ago":{"!":"method","declarations":["instance","public"],"path":"DateTime#ago","name":"ago","namespace":"DateTime","comment":"Returns a new DateTime representing the time a number of seconds ago\nDo not use this method in combination with x.months, use months_ago instead!","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ago(seconds)","arguments":[{"name":"seconds"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def ago(seconds)\n  self.since(-seconds)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#since":{"!":"method","declarations":["instance","public"],"path":"DateTime#since","name":"since","namespace":"DateTime","comment":"Returns a new DateTime representing the time a number of seconds since the instance time\nDo not use this method in combination with x.months, use months_since instead!","format":"rdoc","aliases":["DateTime#in"],"singleton":null,"interfaces":[{"signature":"since(seconds)","arguments":[{"name":"seconds"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def since(seconds)\n  self + Rational(seconds.round, 86400)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#in":{"!":"method","declarations":["instance","public"],"path":"DateTime#in","name":"in","namespace":"DateTime","comment":"Returns a new DateTime representing the time a number of seconds since the instance time\nDo not use this method in combination with x.months, use months_since instead!","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"since(seconds)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def since(seconds)\n  self + Rational(seconds.round, 86400)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#beginning_of_day":{"!":"method","declarations":["instance","public"],"path":"DateTime#beginning_of_day","name":"beginning_of_day","namespace":"DateTime","comment":"Returns a new DateTime representing the start of the day (0:00)","format":"rdoc","aliases":["DateTime#midnight"],"singleton":null,"interfaces":[{"signature":"beginning_of_day()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def beginning_of_day\n  change(:hour => 0)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#midnight":{"!":"method","declarations":["instance","public"],"path":"DateTime#midnight","name":"midnight","namespace":"DateTime","comment":"Returns a new DateTime representing the start of the day (0:00)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"beginning_of_day()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def beginning_of_day\n  change(:hour => 0)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#end_of_day":{"!":"method","declarations":["instance","public"],"path":"DateTime#end_of_day","name":"end_of_day","namespace":"DateTime","comment":"Returns a new DateTime representing the end of the day (23:59:59)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"end_of_day()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def end_of_day\n  change(:hour => 23, :min => 59, :sec => 59)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#utc":{"!":"method","declarations":["instance","public"],"path":"DateTime#utc","name":"utc","namespace":"DateTime","comment":"Adjusts DateTime to UTC by adding its offset value; offset is set to 0\n\nExample:\n\n  DateTime.civil(2005,2,21,10,11,12,Rational(-6, 24))      # Mon, 21 Feb 2005 10:11:12 -0600\n  DateTime.civil(2005,2,21,10,11,12,Rational(-6, 24)).utc  # Mon, 21 Feb 2005 16:11:12 +0000","format":"rdoc","aliases":["DateTime#getutc"],"singleton":null,"interfaces":[{"signature":"utc()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def utc\n  new_offset(0)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#getutc":{"!":"method","declarations":["instance","public"],"path":"DateTime#getutc","name":"getutc","namespace":"DateTime","comment":"Adjusts DateTime to UTC by adding its offset value; offset is set to 0\n\nExample:\n\n  DateTime.civil(2005,2,21,10,11,12,Rational(-6, 24))      # Mon, 21 Feb 2005 10:11:12 -0600\n  DateTime.civil(2005,2,21,10,11,12,Rational(-6, 24)).utc  # Mon, 21 Feb 2005 16:11:12 +0000","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"utc()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def utc\n  new_offset(0)\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#utc?":{"!":"method","declarations":["instance","public"],"path":"DateTime#utc?","name":"utc?","namespace":"DateTime","comment":"Returns true if offset == 0","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"utc?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/date.rb","line":null,"source":"def utc?\n  offset == 0\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#utc_offset":{"!":"method","declarations":["instance","public"],"path":"DateTime#utc_offset","name":"utc_offset","namespace":"DateTime","comment":"Returns the offset value in seconds","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"utc_offset()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def utc_offset\n  (offset * 86400).to_i\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#xmlschema":{"!":"method","declarations":["instance","public"],"path":"DateTime#xmlschema","name":"xmlschema","namespace":"DateTime","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"xmlschema()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def xmlschema\n  strftime(\"%Y-%m-%dT%H:%M:%S%Z\")\nend","language":"ruby","dynamic":null,"tags":{}},"DateTime#to_f":{"!":"method","declarations":["instance","public"],"path":"DateTime#to_f","name":"to_f","namespace":"DateTime","comment":"Converts self to a floating-point number of seconds since the Unix epoch","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_f()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_f\n  days_since_unix_epoch = self - ::DateTime.civil(1970)\n  (days_since_unix_epoch * 86_400).to_f\nend","language":"ruby","dynamic":null,"tags":{}},"Time":{"!":"class","superclass":"Object","path":"Time","name":"Time","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Time.local_time","Time.utc_time","Time.time_with_datetime_fallback","Time#to_date","Time#to_datetime"],"accessors":[],"files":["/lib/standard/facets/date.rb"],"tags":{}},"Time.local_time":{"!":"method","declarations":["class","public"],"path":"Time.local_time","name":"local_time","namespace":"Time","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"local_time(.)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def self.local_time(*args)\n  time_with_datetime_fallback(:local, *args)\nend","language":"ruby","dynamic":null,"tags":{}},"Time.utc_time":{"!":"method","declarations":["class","public"],"path":"Time.utc_time","name":"utc_time","namespace":"Time","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"utc_time(.)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def self.utc_time(*args)\n  time_with_datetime_fallback(:utc, *args)\nend","language":"ruby","dynamic":null,"tags":{}},"Time.time_with_datetime_fallback":{"!":"method","declarations":["class","public"],"path":"Time.time_with_datetime_fallback","name":"time_with_datetime_fallback","namespace":"Time","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"time_with_datetime_fallback(.)","arguments":[{"name":"utc_or_local"},{"name":"year"},{"name":"month","default":"1"},{"name":"day","default":"1"},{"name":"hour","default":"0"},{"name":"min","default":"0"},{"name":"sec","default":"0"},{"name":"usec","default":"0"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def self.time_with_datetime_fallback(utc_or_local, year, month=1, day=1, hour=0, min=0, sec=0, usec=0)\n  ::Time.send(utc_or_local, year, month, day, hour, min, sec, usec)\nrescue\n  offset = utc_or_local.to_sym == :local ? ::DateTime.local_offset : 0\n  ::DateTime.civil(year, month, day, hour, min, sec, offset)\nend","language":"ruby","dynamic":null,"tags":{}},"Time#to_date":{"!":"method","declarations":["instance","public"],"path":"Time#to_date","name":"to_date","namespace":"Time","comment":"Converts a Time object to a Date, dropping hour, minute, and second precision.\n\n  my_time = Time.now  # Mon Nov 12 22:59:51 -0500 2007\n  my_time.to_date     # Mon, 12 Nov 2007\n\n  your_time = Time.parse(\"1/13/2009 1:13:03 P.M.\")  # Tue Jan 13 13:13:03 -0500 2009\n  your_time.to_date                                 # Tue, 13 Jan 2009","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_date()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_date\n  ::Date.new(year, month, day)\nend","language":"ruby","dynamic":null,"tags":{}},"Time#to_datetime":{"!":"method","declarations":["instance","public"],"path":"Time#to_datetime","name":"to_datetime","namespace":"Time","comment":"Converts a Time instance to a Ruby DateTime instance, preserving UTC offset.\n\n  my_time = Time.now    # Mon Nov 12 23:04:21 -0500 2007\n  my_time.to_datetime   # Mon, 12 Nov 2007 23:04:21 -0500\n\n  your_time = Time.parse(\"1/13/2009 1:13:03 P.M.\")  # Tue Jan 13 13:13:03 -0500 2009\n  your_time.to_datetime                             # Tue, 13 Jan 2009 13:13:03 -0500","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_datetime()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_datetime\n  ::DateTime.civil(year, month, day, hour, min, sec, Rational(utc_offset, 86400))\nend","language":"ruby","dynamic":null,"tags":{}},"String":{"!":"class","superclass":"Object","path":"String","name":"String","namespace":"","comment":"","format":"rdoc","constants":[],"includes":["Random::StringExtensions"],"extensions":[],"modules":[],"classes":[],"methods":["String#to_time","String#to_datetime","String#to_date","String#to_t"],"accessors":[],"files":["/lib/standard/facets/date.rb","/lib/standard/facets/tuple.rb","/lib/standard/facets/random.rb"],"tags":{}},"String#to_time":{"!":"method","declarations":["instance","public"],"path":"String#to_time","name":"to_time","namespace":"String","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_time(form = :utc)","arguments":[{"name":"form","default":":utc"}]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_time(form = :utc)\n  ::Time.__send__(\"#{form}_time\", *::Date._parse(self, false).values_at(:year, :mon, :mday, :hour, :min, :sec).map{|arg| arg || 0 })\nend","language":"ruby","dynamic":null,"tags":{}},"String#to_datetime":{"!":"method","declarations":["instance","public"],"path":"String#to_datetime","name":"to_datetime","namespace":"String","comment":"Convert string to DateTime.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_datetime()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_datetime\n  date = ::Date._parse(self, false).values_at(:year, :mon, :mday, :hour, :min, :sec).map { |arg| arg || 0 }\n  ::DateTime.civil(*date)\nend","language":"ruby","dynamic":null,"tags":{}},"String#to_date":{"!":"method","declarations":["instance","public"],"path":"String#to_date","name":"to_date","namespace":"String","comment":"Parse data from string.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_date()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/date.rb","line":null,"source":"def to_date\n  #::Date::civil(*ParseDate.parsedate(self)[0..2])\n  ::Date.new(*::Date._parse(self, false).values_at(:year, :mon, :mday))\nend","language":"ruby","dynamic":null,"tags":{}},"Zlib":{"!":"module","path":"Zlib","name":"Zlib","namespace":"","comment":"A convenient wrapper for the zlib standard library that allows\ncompression/decompression of strings with gzip.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Zlib.decompress","Zlib.compress","Zlib.inflate","Zlib.deflate"],"accessors":[],"files":["/lib/standard/facets/zlib.rb"],"tags":{}},"Zlib.decompress":{"!":"method","declarations":["class","public"],"path":"Zlib.decompress","name":"decompress","namespace":"Zlib","comment":"Decompresses a gzipped string.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"decompress(.)","arguments":[{"name":"source"}]}],"returns":[],"file":"/lib/standard/facets/zlib.rb","line":null,"source":"def self.decompress(source)\n  GzipReader.new(StringIO.new(source)).read\nend","language":"ruby","dynamic":null,"tags":{}},"Zlib.compress":{"!":"method","declarations":["class","public"],"path":"Zlib.compress","name":"compress","namespace":"Zlib","comment":"Compresses a string using gzip.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"compress(.)","arguments":[{"name":"source"}]}],"returns":[],"file":"/lib/standard/facets/zlib.rb","line":null,"source":"def self.compress(source)\n  output = StringIO.new\n  class << output\n    def close; rewind; end\n  end\n  gz = GzipWriter.new(output)\n  gz.write(source)\n  gz.close\n  output.string\nend","language":"ruby","dynamic":null,"tags":{}},"Zlib.inflate":{"!":"method","declarations":["class","public"],"path":"Zlib.inflate","name":"inflate","namespace":"Zlib","comment":"Inflate a deflated sting.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inflate(.)","arguments":[{"name":"string"}]}],"returns":[],"file":"/lib/standard/facets/zlib.rb","line":null,"source":"def self.inflate(string)\n  Inflate.inflate(string)\nend","language":"ruby","dynamic":null,"tags":{}},"Zlib.deflate":{"!":"method","declarations":["class","public"],"path":"Zlib.deflate","name":"deflate","namespace":"Zlib","comment":"Deflate a string.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"deflate(.)","arguments":[{"name":"string"},{"name":"level","default":"DEFAULT_COMPRESSION"}]}],"returns":[],"file":"/lib/standard/facets/zlib.rb","line":null,"source":"def self.deflate(string, level=DEFAULT_COMPRESSION)\n  Deflate.deflate(string, level)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel":{"!":"module","path":"Kernel","name":"Kernel","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Kernel#yaml","Kernel#to_yamlfrag","Kernel#safe_memo","Kernel#sandbox","Kernel#null"],"accessors":[],"files":["/lib/standard/facets/yaml.rb","/lib/standard/facets/thread.rb","/lib/standard/facets/thread.rb","/lib/standard/facets/nullclass.rb"],"tags":{}},"Kernel#yaml":{"!":"method","declarations":["instance","public"],"path":"Kernel#yaml","name":"yaml","namespace":"Kernel","comment":"The Kernel method #yaml is a shortcut to YAML::load.\n\n  data = yaml %{\n    a: 1\n    b: 2\n  }  \n  data #=> {\"a\"=>1, \"b\"=>2}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"yaml(*args,&blk)","arguments":[{"name":"*args"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/standard/facets/yaml.rb","line":null,"source":"def yaml(*args,&blk)\n  YAML.load(*args,&blk)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#to_yamlfrag":{"!":"method","declarations":["instance","public"],"path":"Kernel#to_yamlfrag","name":"to_yamlfrag","namespace":"Kernel","comment":"As with #to_yaml but removes the header line (i.e. '---') to create\na \"YAML fragment\".\n\nCREDT: Thomas Sawyer","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_yamlfrag()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/yaml.rb","line":null,"source":"def to_yamlfrag\n  y = to_yaml\n  y.sub!(/---\\ */, '')\n  y\nend","language":"ruby","dynamic":null,"tags":{}},"File":{"!":"class","superclass":"Object","path":"File","name":"File","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["File.yaml?"],"accessors":[],"files":["/lib/standard/facets/yaml.rb"],"tags":{}},"File.yaml?":{"!":"method","declarations":["class","public"],"path":"File.yaml?","name":"yaml?","namespace":"File","comment":"File.yaml? provides a way to check if a file is a YAML\nformatted file:\n\n  File.yaml?('project.yaml')  #=> true\n  File.yaml?('project.xml')   #=> false\n\nNote this isn't perfect. At present it depends on the use\nuse of an initial document separator (eg. '---'). With\nYAML 1.1 the %YAML delaration is supposed to be manditory,\nso in the future this can be adapted to fit that standard.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"yaml?(.)","arguments":[{"name":"file"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/yaml.rb","line":null,"source":"def self.yaml?(file)\n  File.open(file) do |f|\n    until f.eof?\n      line = f.gets\n      break true if line =~ /^---/\n      break false unless line =~ /^(\\s*#.*?|\\s*)$/\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"YAML":{"!":"module","path":"YAML","name":"YAML","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["YAML.read"],"accessors":[],"files":["/lib/standard/facets/yaml.rb"],"tags":{}},"YAML.read":{"!":"method","declarations":["class","public"],"path":"YAML.read","name":"read","namespace":"YAML","comment":"Shortcut for:\n\n  YAML.load(File.new(file))","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"read(.)","arguments":[{"name":"file"}]}],"returns":[],"file":"/lib/standard/facets/yaml.rb","line":null,"source":"def self.read(file)\n  load(File.new(file))\nend","language":"ruby","dynamic":null,"tags":{}},"Find":{"!":"module","path":"Find","name":"Find","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Find.select"],"accessors":[],"files":["/lib/standard/facets/find.rb"],"tags":{}},"Find.select":{"!":"method","declarations":["class","public"],"path":"Find.select","name":"select","namespace":"Find","comment":"Identical to find except select returns the matching files as an array.\n(find returns nil, which is not very useful if you actually wanted an array.)\nCalls the associated block with the name of every file and directory listed\nas arguments, then recursively on their subdirectories, and so on.\nReturn a true (non-false) value from the block for every path that\nyou want to be returned in the resulting array. You can still use Find.prune.\n\nCREDIT: Tyler Rick","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"select(.)","arguments":[{"name":"*paths"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/find.rb","line":null,"source":"def self.select(*paths, &block)\n  Enumerator.new(self, :find, *paths).select{|value| yield value}\nend","language":"ruby","dynamic":null,"tags":{}},"OpEsc":{"!":"module","path":"OpEsc","name":"OpEsc","namespace":"","comment":"= OpEsc\n\nNOTE: As of v3.0 of Facets these have been renamed:\n\n   op_plus_self   -> op_plus\n   op_minus_self  -> op_minus\n   op_plus        -> op_add\n   op_minus       -> op_sub\n   op_case_eq     -> op_case\n\nTODO: In the future we might also rename:\n\n   op_lshift      -> op_push\n   op_rshift      -> op_pull\n   op_store       -> op_index\n   op_fetch       -> op_index  (b/c [] and []= in same file)","format":"rdoc","constants":["OpEsc::OPERATORS","OpEsc::OPERATORS_REGEXP","OpEsc::OPERATORS_ESC_TABLE"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["OpEsc.escape","OpEsc.method_to_filename"],"accessors":[],"files":["/lib/standard/facets/opesc.rb"],"tags":{}},"OpEsc::OPERATORS":{"!":"constant","path":"OpEsc::OPERATORS","name":"OPERATORS","namespace":"OpEsc","comment":"","format":"rdoc","value":"%w{ +@ -@ + - ** * / % ~ <=> << >> < > === == =~ <= >= | & ^ []= [] }","tags":{},"files":["/lib/standard/facets/opesc.rb"]},"OpEsc::OPERATORS_REGEXP":{"!":"constant","path":"OpEsc::OPERATORS_REGEXP","name":"OPERATORS_REGEXP","namespace":"OpEsc","comment":"","format":"rdoc","value":"Regexp.new( '(' << OPERATORS.collect{ |k| Regexp.escape(k) }.join('|') << ')' )","tags":{},"files":["/lib/standard/facets/opesc.rb"]},"OpEsc::OPERATORS_ESC_TABLE":{"!":"constant","path":"OpEsc::OPERATORS_ESC_TABLE","name":"OPERATORS_ESC_TABLE","namespace":"OpEsc","comment":"","format":"rdoc","value":"{\n    \"+@\"   => \"op_plus\",\n    \"-@\"   => \"op_minus\",\n    \"+\"    => \"op_add\",\n    \"-\"    => \"op_sub\",\n    \"**\"   => \"op_pow\",\n    \"*\"    => \"op_mul\",\n    \"/\"    => \"op_div\",\n    \"%\"    => \"op_mod\",\n    \"~\"    => \"op_tilde\",\n    \"<=>\"  => \"op_cmp\",\n    \"<<\"   => \"op_lshift\",  #push?\n    \">>\"   => \"op_rshift\",  #pull?\n    \"<\"    => \"op_lt\",\n    \">\"    => \"op_gt\",\n    \"===\"  => \"op_case\",\n    \"==\"   => \"op_equal\",\n    \"=~\"   => \"op_apply\",\n    \"<=\"   => \"op_lt_eq\",\n    \">=\"   => \"op_gt_eq\",\n    \"|\"    => \"op_or\",\n    \"&\"    => \"op_and\",\n    \"^\"    => \"op_xor\",\n    \"[]=\"  => \"op_store\",\n    \"[]\"   => \"op_fetch\"\n}","tags":{},"files":["/lib/standard/facets/opesc.rb"]},"OpEsc.escape":{"!":"method","declarations":["class","public"],"path":"OpEsc.escape","name":"escape","namespace":"OpEsc","comment":"Applies operator escape's according to OPERATORS_ESCAPE_TABLE.\n\n  OpEsc.escape('-') #=> \"op_sub\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"escape(.)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/standard/facets/opesc.rb","line":null,"source":"def self.escape(str)\n  str.to_s.gsub(OPERATORS_REGEXP){ OPERATORS_ESC_TABLE[$1] }\nend","language":"ruby","dynamic":null,"tags":{}},"OpEsc.method_to_filename":{"!":"method","declarations":["class","public"],"path":"OpEsc.method_to_filename","name":"method_to_filename","namespace":"OpEsc","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_to_filename(.)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/standard/facets/opesc.rb","line":null,"source":"def self.method_to_filename(name)\n  fname = escape(name)\n  fname = fname[0...-1] if fname =~ /[\\!\\=\\?]$/\n  fname\nend","language":"ruby","dynamic":null,"tags":{}},"Timer":{"!":"class","superclass":"Object","path":"Timer","name":"Timer","namespace":"","comment":"= Timer\n\nProvides a strightforward means for controlling time critical execution.\nCan be used as a \"stop watch\" timer or as a \"time bomb\" timer:\n\n  t = Timer.new(10) { raise TimeoutError, \"timeout!\" }\n  t.start\n    :      # done within 10sec timeout\n  t.stop\n  t.start\n    :\n  if condition then\n    t.reset       #--> restart timer\n  end\n\nA class method is also provided for easily timing the exectuion of a block.\n\n  Timer.time do |timer|\n   timer.total_time.round  #=> 0\n\n   sleep 1\n   timer.total_time.round  #=> 1\n\n   timer.stop\n   timer.total_time.round  #=> 1\n\n   sleep 1\n   timer.total_time.round  #=> 1\n\n   timer.start\n   timer.total_time.round  #=> 1\n\n   sleep 1\n   timer.total_time.round  #=> 2\n  end\n\nThanks to Paul Brannan for TimeLimit and Minero Aoki for Timer.\nThese two libraries served as models for building this class.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["Timer::Dummy"],"methods":["Timer#initialize","Timer#time_limit","Timer#time_limit=","Timer#start_time","Timer#end_time","Timer#on_timeout","Timer#start","Timer#limit","Timer#defuse","Timer#stop","Timer#reset","Timer#reset_limit","Timer#running?","Timer#stopped?","Timer#total_time","Timer.time"],"accessors":["Timer#time_limit"],"files":["/lib/standard/facets/timer.rb"],"tags":{}},"Timer#initialize":{"!":"method","declarations":["instance","public"],"path":"Timer#initialize","name":"initialize","namespace":"Timer","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(time_limit=nil, &block)","arguments":[{"name":"time_limit","default":"nil"}],"block":{"name":"&block"}}],"returns":[{"type":"Timer","comment":"a new instance of Timer"}],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def initialize(time_limit=nil, &block)\n  # standard timer\n  @start_time = nil\n  @end_time = nil\n  @total_time = 0\n  @runnning = nil\n  # for using time limit\n  @time_limit = time_limit\n  @on_timeout = block\n  @current_thread = nil\n  @timer_thread = nil\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#time_limit":{"!":"method","declarations":["instance","public"],"path":"Timer#time_limit","name":"time_limit","namespace":"Timer","comment":"Returns the value of attribute time_limit","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"time_limit","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def time_limit\n  @time_limit\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#time_limit=":{"!":"method","declarations":["instance","public"],"path":"Timer#time_limit=","name":"time_limit=","namespace":"Timer","comment":"Sets the attribute time_limit","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"time_limit=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def time_limit=(value)\n  @time_limit = value\nend","language":"ruby","dynamic":null,"tags":{"param":"the value to set the attribute time_limit to."}},"Timer#start_time":{"!":"method","declarations":["instance","public"],"path":"Timer#start_time","name":"start_time","namespace":"Timer","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"start_time()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def start_time\n  @start_time\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#end_time":{"!":"method","declarations":["instance","public"],"path":"Timer#end_time","name":"end_time","namespace":"Timer","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"end_time()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def end_time\n  @end_time\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#on_timeout":{"!":"method","declarations":["instance","public"],"path":"Timer#on_timeout","name":"on_timeout","namespace":"Timer","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"on_timeout(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def on_timeout( &block )\n  if block then\n    @on_timeout = block\n    true\n  else\n    false\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#start":{"!":"method","declarations":["instance","public"],"path":"Timer#start","name":"start","namespace":"Timer","comment":"Start the timer.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"start()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def start\n  @running = true\n  @start_time = Time.now\n\n  limit if @time_limit\n\n  self\n\n  ##if block_given? then\n  ##  begin\n  ##    yield( self )\n  ##  ensure\n  ##    stop\n  ##  end\n  ##else\n  ##  @time_limit\n  ##end\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#limit":{"!":"method","declarations":["instance","public"],"path":"Timer#limit","name":"limit","namespace":"Timer","comment":"Establish a time limit on execution.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"limit(time_limit=nil)","arguments":[{"name":"time_limit","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def limit( time_limit=nil )\n  if @time_limit || time_limit\n    @current_thread = Thread.current\n    @timer_thread = Thread.fork {\n      sleep @time_limit\n      if @on_timeout then\n        @on_timeout.call @time_limit\n      else\n        @current_thread.raise TimeoutError, \"#{@time_limit} seconds past\"\n      end\n    }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#defuse":{"!":"method","declarations":["instance","public"],"path":"Timer#defuse","name":"defuse","namespace":"Timer","comment":"Kill time limit thread, if any.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"defuse()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def defuse\n  if @timer_thread\n    #Thread.kill @timer_thread\n    @timer_thread.kill\n    @timer_thread = nil\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#stop":{"!":"method","declarations":["instance","public"],"path":"Timer#stop","name":"stop","namespace":"Timer","comment":"Stops timer and returns total time.\nIf timer was not running returns false.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stop()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def stop\n  if @running\n    defuse\n    # record running time\n    @end_time = Time.now\n    @running = false\n    @total_time += (@end_time - @start_time)\n  else\n    nil\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#reset":{"!":"method","declarations":["instance","public"],"path":"Timer#reset","name":"reset","namespace":"Timer","comment":"Stops and resets the timer. If the timer was running\nreturns the total time. If not returns 0.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"reset()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def reset\n  if running?\n    r = stop\n  else\n    r = 0\n  end\n  @total_time = 0\n  return r\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#reset_limit":{"!":"method","declarations":["instance","public"],"path":"Timer#reset_limit","name":"reset_limit","namespace":"Timer","comment":"Resets the time limit. Same as:\n\n  t.stop\n  t.start","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"reset_limit()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def reset_limit\n  #stop\n  #start\n  defuse\n  limit\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#running?":{"!":"method","declarations":["instance","public"],"path":"Timer#running?","name":"running?","namespace":"Timer","comment":"Queries whether the timer is still running.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"running?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def running?\n  return @running\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#stopped?":{"!":"method","declarations":["instance","public"],"path":"Timer#stopped?","name":"stopped?","namespace":"Timer","comment":"Queries whether the timer is still not running.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stopped?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def stopped?\n  return !@running\nend","language":"ruby","dynamic":null,"tags":{}},"Timer#total_time":{"!":"method","declarations":["instance","public"],"path":"Timer#total_time","name":"total_time","namespace":"Timer","comment":"Queries total recorded time of timer.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"total_time()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def total_time\n  if running? then\n    return @total_time + (Time.now - @start_time)\n  else\n    return @total_time\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Timer.time":{"!":"method","declarations":["class","public"],"path":"Timer.time","name":"time","namespace":"Timer","comment":"Takes a block and returns the total time it took to execute.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"time(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def self.time\n  yield( timer = Timer.new.start )\n  return timer.total_time\nend","language":"ruby","dynamic":null,"tags":{"yield":""}},"Timer::Dummy":{"!":"class","superclass":"Timer","path":"Timer::Dummy","name":"Dummy","namespace":"Timer","comment":"Timer::Dummy - Dummy Timer (i.e. no real time limit)\n--\nTODO: Timer::Dummy needs some work.\n++","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Timer::Dummy#start","Timer::Dummy#stop"],"accessors":[],"files":["/lib/standard/facets/timer.rb"],"tags":{}},"Timer::Dummy#start":{"!":"method","declarations":["instance","public"],"path":"Timer::Dummy#start","name":"start","namespace":"Timer::Dummy","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"start()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def start\n  if block_given? then\n    yield\n  else\n    time_limit()\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Timer::Dummy#stop":{"!":"method","declarations":["instance","public"],"path":"Timer::Dummy#stop","name":"stop","namespace":"Timer::Dummy","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stop()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/timer.rb","line":null,"source":"def stop\n  false\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple":{"!":"class","superclass":"Object","path":"Tuple","name":"Tuple","namespace":"","comment":"= Tuple\n\nTuple is essentially an Array, but Comaparable and Immutable.\n\nA tuple can be made using #new or #[] just as one builds an array,\nor using the #to_t method on a string or array. With a string tuple\nremembers the first non-alphanumeric character as the tuple divider.\n\n== Usage\n\n  t1 = Tuple[1,2,3]\n  t2 = Tuple[2,3,4]\n\n  (t1 < t2)   #=> true\n  (t1 > t2)   #=> false\n\n  t1 = '1.2.3'.to_t\n  t2 = '1-2-3'.to_t\n\n  t1.to_s  #=> \"1.2.3\"\n  t2.to_s  #=> \"1.2.3\"\n\n  (t1 == t2)  #=> true\n\nKeep in mind that Tuple[1,2,3] is not the same as Tuple['1','2','3'].\n\n--\nTODO: The #hash method needs a touch-up.\n\nTODO: There are a few more methods yet to borrow from Array.\nConsider how #+, #-, etc. ought to work.\n++","format":"rdoc","constants":["Tuple::SEGMENT_SEPARATOR"],"includes":["Comparable","Enumerable","Multiton"],"extensions":[],"modules":[],"classes":[],"methods":["Tuple.multiton_id","Tuple#initialize","Tuple#default","Tuple#default=","Tuple#values","Tuple#inspect","Tuple#to_t","Tuple#to_tuple","Tuple#to_a","Tuple#to_ary","Tuple#to_s","Tuple#size","Tuple#length","Tuple#empty?","Tuple#each","Tuple#each_index","Tuple#[]","Tuple#[]=","Tuple#index","Tuple#rindex","Tuple#<<","Tuple#pop","Tuple#push","Tuple#pull","Tuple#pot","Tuple#unshift","Tuple#shift","Tuple#eql?","Tuple#<=>","Tuple#=~","Tuple#first","Tuple#last","Tuple#major","Tuple#minor","Tuple#teeny","Tuple#hash","Tuple.[]","Tuple.cast_from_string","Tuple.cast_from_array","Tuple.constraint_to_lambda","Tuple.parse_constraint"],"accessors":["Tuple#default"],"files":["/lib/standard/facets/tuple.rb"],"tags":{}},"Tuple::SEGMENT_SEPARATOR":{"!":"constant","path":"Tuple::SEGMENT_SEPARATOR","name":"SEGMENT_SEPARATOR","namespace":"Tuple","comment":"","format":"rdoc","value":"'.'","tags":{},"files":["/lib/standard/facets/tuple.rb"]},"Tuple.multiton_id":{"!":"method","declarations":["class","public"],"path":"Tuple.multiton_id","name":"multiton_id","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"multiton_id(.)","arguments":[{"name":"arg","default":"0"},{"name":"default","default":"0"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def self.multiton_id(arg=0, default=0, &block)\n  if block_given?\n    values = []\n    arg.times { |i| values << block[i] }\n  elseif Integer === arg\n    values = [ default ] * arg\n  else\n    values = arg.to_ary\n  end\n  values\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#initialize":{"!":"method","declarations":["instance","public"],"path":"Tuple#initialize","name":"initialize","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(arg=0, default=0, &blk)","arguments":[{"name":"arg","default":"0"},{"name":"default","default":"0"}],"block":{"name":"&blk"}}],"returns":[{"type":"Tuple","comment":"a new instance of Tuple"}],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def initialize(arg=0, default=0, &blk)\n  if block_given?\n    @values = []\n    arg.times { |i| @values << blk[i] }\n  elseif Integer === arg\n    @values = [ default ] * arg\n  else\n    @values = arg.to_ary\n  end\n  @default = default\n  ##@divider = '.'\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#default":{"!":"method","declarations":["instance","public"],"path":"Tuple#default","name":"default","namespace":"Tuple","comment":"Returns the value of attribute default","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"default","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def default\n  @default\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#default=":{"!":"method","declarations":["instance","public"],"path":"Tuple#default=","name":"default=","namespace":"Tuple","comment":"Sets the attribute default","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"default=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def default=(value)\n  @default = value\nend","language":"ruby","dynamic":null,"tags":{"param":"the value to set the attribute default to."}},"Tuple#values":{"!":"method","declarations":["instance","protected"],"path":"Tuple#values","name":"values","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"values()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def values() @values end","language":"ruby","dynamic":null,"tags":{}},"Tuple#inspect":{"!":"method","declarations":["instance","public"],"path":"Tuple#inspect","name":"inspect","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def inspect() to_a.inspect end","language":"ruby","dynamic":null,"tags":{}},"Tuple#to_t":{"!":"method","declarations":["instance","public"],"path":"Tuple#to_t","name":"to_t","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_t()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def to_t()     self end","language":"ruby","dynamic":null,"tags":{}},"Tuple#to_tuple":{"!":"method","declarations":["instance","public"],"path":"Tuple#to_tuple","name":"to_tuple","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_tuple()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def to_tuple() self end","language":"ruby","dynamic":null,"tags":{}},"Tuple#to_a":{"!":"method","declarations":["instance","public"],"path":"Tuple#to_a","name":"to_a","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_a()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def to_a()   Array(@values) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#to_ary":{"!":"method","declarations":["instance","public"],"path":"Tuple#to_ary","name":"to_ary","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_ary()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def to_ary() Array(@values) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#to_s":{"!":"method","declarations":["instance","public"],"path":"Tuple#to_s","name":"to_s","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_s(divider=nil)","arguments":[{"name":"divider","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def to_s(divider=nil)\n  @values.join(divider || SEGMENT_SEPARATOR)\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#size":{"!":"method","declarations":["instance","public"],"path":"Tuple#size","name":"size","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"size()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def size()   @values.size end","language":"ruby","dynamic":null,"tags":{}},"Tuple#length":{"!":"method","declarations":["instance","public"],"path":"Tuple#length","name":"length","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"length()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def length() @values.size end","language":"ruby","dynamic":null,"tags":{}},"Tuple#empty?":{"!":"method","declarations":["instance","public"],"path":"Tuple#empty?","name":"empty?","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"empty?(\n)","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def empty?()\n  return true if @values.empty?\n  return true if @values == [ @default ] * @values.size\n  false\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#each":{"!":"method","declarations":["instance","public"],"path":"Tuple#each","name":"each","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def each( &block )\n  @values.each( &block )\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#each_index":{"!":"method","declarations":["instance","public"],"path":"Tuple#each_index","name":"each_index","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each_index(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def each_index( &block )\n  @values.each_index( &block )\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#[]":{"!":"method","declarations":["instance","public"],"path":"Tuple#[]","name":"[]","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](i)","arguments":[{"name":"i"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def [](i)\n  @values.fetch(i,@default)\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#[]=":{"!":"method","declarations":["instance","public"],"path":"Tuple#[]=","name":"[]=","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[]=(i,v)","arguments":[{"name":"i"},{"name":"v"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def []=(i,v)\n  @values[i] = v\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#index":{"!":"method","declarations":["instance","public"],"path":"Tuple#index","name":"index","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"index()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def index()  @values.index end","language":"ruby","dynamic":null,"tags":{}},"Tuple#rindex":{"!":"method","declarations":["instance","public"],"path":"Tuple#rindex","name":"rindex","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rindex()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def rindex() @values.rindex end","language":"ruby","dynamic":null,"tags":{}},"Tuple#<<":{"!":"method","declarations":["instance","public"],"path":"Tuple#<<","name":"<<","namespace":"Tuple","comment":"Unlike Array, Tuple#<< cannot act in place\nbecuase Tuple's are immutable.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"<<(obj)","arguments":[{"name":"obj"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def <<( obj )\n  self.class.instance( to_a << obj )\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#pop":{"!":"method","declarations":["instance","public"],"path":"Tuple#pop","name":"pop","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pop()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def pop() Tuple.instance( to_a.pop ) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#push":{"!":"method","declarations":["instance","public"],"path":"Tuple#push","name":"push","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"push(obj)","arguments":[{"name":"obj"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def push( obj ) Tuple.instance( to_a.push(obj) ) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#pull":{"!":"method","declarations":["instance","public"],"path":"Tuple#pull","name":"pull","namespace":"Tuple","comment":"Pulls a value off the beginning of a tuple.\nThis method is otherwsie known as #shift.","format":"rdoc","aliases":["Tuple#shift"],"singleton":null,"interfaces":[{"signature":"pull()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def pull() Tuple.instance( to_a.shift ) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#pot":{"!":"method","declarations":["instance","public"],"path":"Tuple#pot","name":"pot","namespace":"Tuple","comment":"Stands for \"Put On Top\". This method is the opposite of #pull and is\notherwise known as #unshift.","format":"rdoc","aliases":["Tuple#unshift"],"singleton":null,"interfaces":[{"signature":"pot(obj)","arguments":[{"name":"obj"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def pot( obj ) Tuple.instance( to_a.unshift(obj) ) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#unshift":{"!":"method","declarations":["instance","public"],"path":"Tuple#unshift","name":"unshift","namespace":"Tuple","comment":"Stands for \"Put On Top\". This method is the opposite of #pull and is\notherwise known as #unshift.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pot(obj)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def pot( obj ) Tuple.instance( to_a.unshift(obj) ) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#shift":{"!":"method","declarations":["instance","public"],"path":"Tuple#shift","name":"shift","namespace":"Tuple","comment":"Pulls a value off the beginning of a tuple.\nThis method is otherwsie known as #shift.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pull()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def pull() Tuple.instance( to_a.shift ) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#eql?":{"!":"method","declarations":["instance","public"],"path":"Tuple#eql?","name":"eql?","namespace":"Tuple","comment":"Returns true if two tuple references are for the\nvery same tuple.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"eql?(other)","arguments":[{"name":"other"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def eql?( other )\n  return true if object_id == other.object_id\n  ##return true if values.eql? other.values\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#<=>":{"!":"method","declarations":["instance","public"],"path":"Tuple#<=>","name":"<=>","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"<","arguments":[{"name":"other"}],"returns":"(other)"}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def <=>( other )\n  other = other.to_t\n  [size, other.size].max.times do |i|\n    c = self[i] <=> other[i]\n    return c if c != 0\n  end\n  0\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#=~":{"!":"method","declarations":["instance","public"],"path":"Tuple#=~","name":"=~","namespace":"Tuple","comment":"For pessimistic constraint (like '~>' in gems)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"=~(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def =~( other )\n  other = other.to_t\n  upver = other.dup\n  upver[0] += 1\n  self >= other and self < upver\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple#first":{"!":"method","declarations":["instance","public"],"path":"Tuple#first","name":"first","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"first()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def first() @values.first end","language":"ruby","dynamic":null,"tags":{}},"Tuple#last":{"!":"method","declarations":["instance","public"],"path":"Tuple#last","name":"last","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"last()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def last()  @values.last end","language":"ruby","dynamic":null,"tags":{}},"Tuple#major":{"!":"method","declarations":["instance","public"],"path":"Tuple#major","name":"major","namespace":"Tuple","comment":"These are useful for using a Tuple as a version.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"major()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def major() @values.first end","language":"ruby","dynamic":null,"tags":{}},"Tuple#minor":{"!":"method","declarations":["instance","public"],"path":"Tuple#minor","name":"minor","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"minor()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def minor() @values.at(1) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#teeny":{"!":"method","declarations":["instance","public"],"path":"Tuple#teeny","name":"teeny","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"teeny()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def teeny() @values.at(2) end","language":"ruby","dynamic":null,"tags":{}},"Tuple#hash":{"!":"method","declarations":["instance","public"],"path":"Tuple#hash","name":"hash","namespace":"Tuple","comment":"Unique hash value.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"hash()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def hash\n  # TODO: This needs to take into account the default\n  # and maybe the divider too.\n  to_a.hash\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple.[]":{"!":"method","declarations":["class","public"],"path":"Tuple.[]","name":"[]","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def []( *args )\n  instance( args )\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple.cast_from_string":{"!":"method","declarations":["class","public"],"path":"Tuple.cast_from_string","name":"cast_from_string","namespace":"Tuple","comment":"Translates a string in the form on a set of numerical and/or\nalphanumerical characters separated by non-word characters (eg \\W+)\ninto a Tuple. The values of the tuple will be converted to integers\nif they are purely numerical.\n\n  Tuple.cast_from_string('1.2.3a')  #=> [1,2,\"3a\"]\n\nIt you would like to control the interpretation of each value\nas it is added to the tuple you can supply a block.\n\n  Tuple.cast_from_string('1.2.3a'){ |v| v.upcase }  #=> [\"1\",\"2\",\"3A\"]\n\nThis method is called by String#to_t.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cast_from_string(str, &yld)","arguments":[{"name":"str"}],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def cast_from_string( str, &yld )\n  args = str.to_s.split(/\\W+/)\n  div = /\\W+/.match( str.to_s )[0]\n  if block_given?\n    args = args.collect{ |a| yld[a] }\n  else\n    args = args.collect { |i| /^[0-9]+$/ =~ i ? i.to_i : i }\n  end\n  self.instance(args) #.divider( div )\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple.cast_from_array":{"!":"method","declarations":["class","public"],"path":"Tuple.cast_from_array","name":"cast_from_array","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cast_from_array(arr)","arguments":[{"name":"arr"}]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def cast_from_array( arr )\n  self.instance( arr )\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple.constraint_to_lambda":{"!":"method","declarations":["class","public"],"path":"Tuple.constraint_to_lambda","name":"constraint_to_lambda","namespace":"Tuple","comment":"Parses a constraint returning the operation as a lambda.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"constraint_to_lambda(constraint, &yld)","arguments":[{"name":"constraint"}],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def constraint_to_lambda( constraint, &yld )\n  op, val = *parse_constraint( constraint, &yld )\n  lambda { |t| t.send(op, val) }\nend","language":"ruby","dynamic":null,"tags":{}},"Tuple.parse_constraint":{"!":"method","declarations":["class","public"],"path":"Tuple.parse_constraint","name":"parse_constraint","namespace":"Tuple","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"parse_constraint(constraint, &yld)","arguments":[{"name":"constraint"}],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def parse_constraint( constraint, &yld )\n  constraint = constraint.strip\n  re = %r{^(=~|~>|<=|>=|==|=|<|>)?\\s*(\\d+(:?[-.]\\d+)*)$}\n  if md = re.match( constraint )\n    if op = md[1]\n      op = '=~' if op == '~>'\n      op = '==' if op == '='\n      val = cast_from_string( md[2], &yld ) #instance( md[2] )\n    else\n      op = '=='\n      val = cast_from_string( constraint, &yld ) #instance( constraint )\n    end\n  else\n    raise ArgumentError, \"invalid constraint\"\n  end\n  return op, val\nend","language":"ruby","dynamic":null,"tags":{}},"String#to_t":{"!":"method","declarations":["instance","public"],"path":"String#to_t","name":"to_t","namespace":"String","comment":"Translates a string in the form on a set of numerical and/or\nalphanumerical characters separated by non-word characters (eg \\W+)\ninto a Tuple. The values of the tuple will be converted to integers\nif they are purely numerical.\n\n  '1.2.3a'.to_t  #=> [1,2,\"3a\"]\n\nIt you would like to control the interpretation of each value\nas it is added to the tuple you can supply a block.\n\n  '1.2.3a'.to_t { |v| v.upcase }  #=> [\"1\",\"2\",\"3A\"]\n\nThis method calls Tuple.cast_from_string.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_t(&yld)","arguments":[],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def to_t( &yld )\n  Tuple.cast_from_string( self, &yld )\nend","language":"ruby","dynamic":null,"tags":{}},"Array#to_t":{"!":"method","declarations":["instance","public"],"path":"Array#to_t","name":"to_t","namespace":"Array","comment":"Convert an array into a tuple.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_t()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/tuple.rb","line":null,"source":"def to_t\n  Tuple.cast_from_array( self )\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#safe_memo":{"!":"method","declarations":["instance","public"],"path":"Kernel#safe_memo","name":"safe_memo","namespace":"Kernel","comment":"Thead-safe instance-level memoization.\n\n  class MemoExample\n    attr_accessor :a\n    def m\n      safe_memo{ @a }\n    end\n  end\n\n  ex = MemoExample.new\n\n  ex.a = 10\n  ex.m  #=> 10\n\n  ex.a = 20\n  ex.m  #=> 10","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"safe_memo(*args, &block)","arguments":[{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/thread.rb","line":null,"source":"def safe_memo(*args, &block)\n  if args.empty?\n    args = block.binding.eval('[self, __method__]')\n  end\n  $MEMO_MUTEX.synchronize do\n    if $MEMO.key?(args)\n      $MEMO[args]\n    else\n      $MEMO[args] = block.call\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable":{"!":"module","path":"Enumerable","name":"Enumerable","namespace":"","comment":"This is a simple reimplementation of the core Enumerable module\nto allow the methods to take and pass-on arbitrary arguments to the\nunderlying #each call. This library uses Enumerator and scans\nEnumerable so it can alwasy stay in sync.\n\nNOTE Any Enumerable method with a negative arity cannot do pass arguments\ndue to ambiguity in the argument count. So the methods #inject and #zip\ndo NOT work this way, but simply work as they do in Enumerable.\nThe method #find (and #detect) though has been made to work by removing\nits rarely used optional parameter and providing instead an optional\nkeyword parameter (:ifnone => ...). Please keep these difference in mind.\n\n  require 'enumargs'\n\n  class T\n    include Enumerable::Arguments\n    def initialize(arr)\n      @arr = arr\n    end\n    def each(n)\n      arr.each{ |e| yield(e+n) }\n    end\n  end\n\n  t = T.new([1,2,3])\n  t.collect(4)\n  #=> [5,6,7]","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":["Enumerable::Arguments"],"classes":[],"methods":["Enumerable#threaded_map","Enumerable#threaded_map_send"],"accessors":[],"files":["/lib/standard/facets/enumargs.rb","/lib/standard/facets/thread.rb"],"tags":{}},"Enumerable#threaded_map":{"!":"method","declarations":["instance","public"],"path":"Enumerable#threaded_map","name":"threaded_map","namespace":"Enumerable","comment":"Like Enumerable#map but each iteration is processed via\na separate thread.\n\nCREDIT: Sean O'Halpin","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"threaded_map()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/thread.rb","line":null,"source":"def threaded_map #:yield:\n  map{ |e| Thread.new(e){ |t| yield(t) } }.map{ |t| t.value }\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#threaded_map_send":{"!":"method","declarations":["instance","public"],"path":"Enumerable#threaded_map_send","name":"threaded_map_send","namespace":"Enumerable","comment":"Like Enumerable#map_send but each iteration is processed via\na separate thread.\n\nCREDIT: Sean O'Halpin","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"threaded_map_send(meth, *args, &block)","arguments":[{"name":"meth"},{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/thread.rb","line":null,"source":"def threaded_map_send(meth, *args, &block)\n  map{ |e| Thread.new(e){ |t| t.send(meth, *args, &block) } }.map{ |t| t.value }\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#sandbox":{"!":"method","declarations":["instance","private"],"path":"Kernel#sandbox","name":"sandbox","namespace":"Kernel","comment":"CREDIT: Zucker","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sandbox(rescueblock_or_default=nil)","arguments":[{"name":"rescueblock_or_default","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/thread.rb","line":null,"source":"def sandbox(rescueblock_or_default=nil) #:yield:\n  Thread.start do\n    $SAFE = 4\n    yield\n  end.value\nrescue SecurityError => e\n  if !rescueblock_or_default.nil?\n    if rescueblock_or_default.is_a? Proc\n      rescueblock_or_default.call e\n    else\n      rescueblock_or_default\n    end\n  else\n    raise e\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Random":{"!":"class","superclass":"Object","path":"Random","name":"Random","namespace":"","comment":"= Randomization Extensions\n\nThis library extends Array, String, Hash and other classes with randomization\nmethods. Most of the methods are of one of two kinds. Either they \"pick\" a\nrandom element from the reciever or they randomly \"shuffle\" the reciever.\n\nThe most common example is Array#shuffle, which simply randmomizes the\norder of an array's elements.\n\n  [1,2,3].shuffle  #~> [2,3,1]\n\nThe other methods do similar things for their respective classes.\n\nThe classes are all extended via mixins which have been created within\nRuby's Random class.\n\nCredit for this work is due to:\n\n* Ilmari Heikkinen\n* Christian Neukirchen\n* Thomas Sawyer\n\nNOTE: Inline QED tests are almost pointless here b/c... yea, it's random.\nSo indtead of the usual `#=>` we use `#~>` which means approx. equal and\nprevens QED from making a hard assertion.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":["Random::RangeExtensions","Random::IntegerExtensions","Random::NumericExtensions","Random::ArrayExtensions","Random::HashExtensions","Random::StringExtensions"],"classes":[],"methods":["Random.number","Random.letter"],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Random.number":{"!":"method","declarations":["class","public"],"path":"Random.number","name":"number","namespace":"Random","comment":"Alias for Kernel#rand.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"number","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"alias_method :number, :rand","language":"ruby","dynamic":null,"tags":{}},"Random.letter":{"!":"method","declarations":["class","public"],"path":"Random.letter","name":"letter","namespace":"Random","comment":"Module method to generate a random letter.\n\n  Random.letter  #~> \"q\"\n  Random.letter  #~> \"r\"\n  Random.letter  #~> \"a\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"letter(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def self.letter\n  (Random.number(26) + (Random.number(2) == 0 ? 65 : 97) ).chr\nend","language":"ruby","dynamic":null,"tags":{}},"Random::RangeExtensions":{"!":"module","path":"Random::RangeExtensions","name":"RangeExtensions","namespace":"Random","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Random::RangeExtensions#at_rand"],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Random::RangeExtensions#at_rand":{"!":"method","declarations":["instance","public"],"path":"Random::RangeExtensions#at_rand","name":"at_rand","namespace":"Random::RangeExtensions","comment":"Return a random element from the range.\n\n  (1..4).at_rand           #~> 2\n  (1..4).at_rand           #~> 4\n\n  (1.5..2.5).at_rand       #~> 2.06309842754533\n  (1.5..2.5).at_rand       #~> 1.74976944931541\n\n  ('a'..'z').at_rand       #~> 'q'\n  ('a'..'z').at_rand       #~> 'f'\n\nCREDIT: Lavir the Whiolet, Thomas Sawyer","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"at_rand()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def at_rand\n  first, last = first(), last()\n  if first.respond_to?(:random_delta)  # TODO: work on this!!!\n    begin\n      first.random_delta(last, exclude_end?)\n    rescue\n      to_a.at_rand\n    end\n  else\n    to_a.at_rand\n  end\n  ##elsif first.respond_to?(:succ)\n  ##  # optimized algorithm\n  ##  if (Fixnum === first || Bignum === first) &&\n  ##     (Fixnum === last  || Bignum === last)\n  ##    last -= 1 if exclude_end?\n  ##    return nil if last < first\n  ##    return Random.number(last - first + 1) + first\n  ##  end\n  ##  # standard algorithm\n  ##  return to_a.at_rand\n  ##elsif Numeric === first && Numeric === last\n  ##  return nil if last < first\n  ##  return nil if exclude_end? && last == first\n  ##  return (last - first) * Random.number + first\n  ##else\n  ##  return nil\n  ##end\nend","language":"ruby","dynamic":null,"tags":{}},"Random::IntegerExtensions":{"!":"module","path":"Random::IntegerExtensions","name":"IntegerExtensions","namespace":"Random","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Random::IntegerExtensions#random_delta"],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Random::IntegerExtensions#random_delta":{"!":"method","declarations":["instance","public"],"path":"Random::IntegerExtensions#random_delta","name":"random_delta","namespace":"Random::IntegerExtensions","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"random_delta(last, exclude_end)","arguments":[{"name":"last"},{"name":"exclude_end"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def random_delta(last, exclude_end)\n  first = self\n  last -= 1 if exclude_end\n  return nil if last < first\n  return Random.number(last - first + 1) + first\nend","language":"ruby","dynamic":null,"tags":{}},"Random::NumericExtensions":{"!":"module","path":"Random::NumericExtensions","name":"NumericExtensions","namespace":"Random","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Random::NumericExtensions#random_delta"],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Random::NumericExtensions#random_delta":{"!":"method","declarations":["instance","public"],"path":"Random::NumericExtensions#random_delta","name":"random_delta","namespace":"Random::NumericExtensions","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"random_delta(last, exclude_end)","arguments":[{"name":"last"},{"name":"exclude_end"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def random_delta(last, exclude_end)\n  first = self\n  return nil if last < first\n  return nil if exclude_end && last == first\n  return (last - first) * Random.number + first\nend","language":"ruby","dynamic":null,"tags":{}},"Random::ArrayExtensions":{"!":"module","path":"Random::ArrayExtensions","name":"ArrayExtensions","namespace":"Random","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Random::ArrayExtensions#at_rand","Random::ArrayExtensions#at_rand!","Random::ArrayExtensions#pick","Random::ArrayExtensions#pick!","Random::ArrayExtensions#rand_index","Random::ArrayExtensions#rand_subset","Random::ArrayExtensions#shuffle","Random::ArrayExtensions#shuffle!"],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Random::ArrayExtensions#at_rand":{"!":"method","declarations":["instance","public"],"path":"Random::ArrayExtensions#at_rand","name":"at_rand","namespace":"Random::ArrayExtensions","comment":"Return a random element from the array.\n\n  [1, 2, 3, 4].at_rand           #~> 2\n  [1, 2, 3, 4].at_rand           #~> 4","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"at_rand()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def at_rand\n  at(Random.number(size))\nend","language":"ruby","dynamic":null,"tags":{}},"Random::ArrayExtensions#at_rand!":{"!":"method","declarations":["instance","public"],"path":"Random::ArrayExtensions#at_rand!","name":"at_rand!","namespace":"Random::ArrayExtensions","comment":"Same as #at_rand, but acts in place removing a\nrandom element from the array.\n\n  a = [1,2,3,4]\n  a.at_rand!       #~> 2\n  a                #~> [1,3,4]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"at_rand!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def at_rand!\n  return delete_at( Random.number( size ) )\nend","language":"ruby","dynamic":null,"tags":{}},"Random::ArrayExtensions#pick":{"!":"method","declarations":["instance","public"],"path":"Random::ArrayExtensions#pick","name":"pick","namespace":"Random::ArrayExtensions","comment":"Similar to #at_rand, but will return an array of randomly\npicked exclusive elements if given a number.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pick(n=nil)","arguments":[{"name":"n","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def pick(n=nil)\n  if n\n    a = self.dup\n    a.pick!(n)\n  else\n    at(Random.number(size))\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Random::ArrayExtensions#pick!":{"!":"method","declarations":["instance","public"],"path":"Random::ArrayExtensions#pick!","name":"pick!","namespace":"Random::ArrayExtensions","comment":"Similar to #at_rand!, but given a number will return\nan array of exclusive elements.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pick!(n=nil)","arguments":[{"name":"n","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def pick!(n=nil)\n  if n\n    if n > self.size\n      r = self.dup\n      self.replace([])\n      r\n    else\n      r = []\n      n.times { r << delete_at(Random.number(size)) }\n      r\n    end\n  else\n    delete_at(Random.number(size))\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Random::ArrayExtensions#rand_index":{"!":"method","declarations":["instance","public"],"path":"Random::ArrayExtensions#rand_index","name":"rand_index","namespace":"Random::ArrayExtensions","comment":"Random index.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_index()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_index\n  Random.number(size)\nend","language":"ruby","dynamic":null,"tags":{}},"Random::ArrayExtensions#rand_subset":{"!":"method","declarations":["instance","public"],"path":"Random::ArrayExtensions#rand_subset","name":"rand_subset","namespace":"Random::ArrayExtensions","comment":"Returns a random subset of an Array. If a _number_\nof elements is specified then returns that number of\nelements, otherwise returns a random number of elements\nupto the size of the Array.\n\nBy defualt the returned values are exclusive of\neach other, but if _exclusive_ is set to <tt>false</tt>,\nthe same values can be choosen more than once.\n\nWhen _exclusive_ is <tt>true</tt> (the default) and the\n_number_ given is greater than the size of the array,\nthen all values are returned.\n\n  [1, 2, 3, 4].rand_subset(1)        #~> [2]\n  [1, 2, 3, 4].rand_subset(4)        #~> [2, 1, 3, 4]\n  [1, 2, 3, 4].rand_subset           #~> [1, 3, 4]\n  [1, 2, 3, 4].rand_subset           #~> [2, 3]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_subset(number=nil, exclusive=true)","arguments":[{"name":"number","default":"nil"},{"name":"exclusive","default":"true"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_subset( number=nil, exclusive=true )\n  number = Random.number(size) unless number\n  number = number.to_int\n  #return self.dup if (number >= size and exlusive)\n  return sort_by{rand}.slice(0,number) if exclusive\n  ri =[]; number.times { |n| ri << Random.number(size) }\n  return values_at(*ri)\nend","language":"ruby","dynamic":null,"tags":{}},"Random::ArrayExtensions#shuffle":{"!":"method","declarations":["instance","public"],"path":"Random::ArrayExtensions#shuffle","name":"shuffle","namespace":"Random::ArrayExtensions","comment":"Randomize the order of an array.\n\n  [1,2,3,4].shuffle  #~> [2,4,1,3]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shuffle()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def shuffle\n  dup.shuffle!\n  #sort_by{Random.number}\nend","language":"ruby","dynamic":null,"tags":{}},"Random::ArrayExtensions#shuffle!":{"!":"method","declarations":["instance","public"],"path":"Random::ArrayExtensions#shuffle!","name":"shuffle!","namespace":"Random::ArrayExtensions","comment":"As with #shuffle but modifies the array in place.\nThe algorithm used here is known as a Fisher-Yates shuffle.\n\n  a = [1,2,3,4]\n  a.shuffle!\n\n  a  #~> [2,4,1,3]\n\nCREDIT Niel Spring","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shuffle!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def shuffle!\n  s = size\n  each_index do |j|\n    i = Random.number(s-j)\n    #self[j], self[j+i] = self[j+i], self[j]\n    tmp = self[j]\n    self[j] = self[j+i]\n    self[j+i] = tmp\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions":{"!":"module","path":"Random::HashExtensions","name":"HashExtensions","namespace":"Random","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Random::HashExtensions#rand_key","Random::HashExtensions#rand_key!","Random::HashExtensions#pick_key","Random::HashExtensions#rand_pair","Random::HashExtensions#rand_pair!","Random::HashExtensions#pick_pair","Random::HashExtensions#rand_value","Random::HashExtensions#rand_value!","Random::HashExtensions#pick","Random::HashExtensions#at_rand","Random::HashExtensions#at_rand!","Random::HashExtensions#shuffle","Random::HashExtensions#shuffle!"],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Random::HashExtensions#rand_key":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#rand_key","name":"rand_key","namespace":"Random::HashExtensions","comment":"Returns a random key.\n\n  {:one => 1, :two => 2, :three => 3}.pick_key  #~> :three","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_key()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_key\n  keys.at(Random.number(keys.size))\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#rand_key!":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#rand_key!","name":"rand_key!","namespace":"Random::HashExtensions","comment":"Delete a random key-value pair, returning the key.\n\n  a = {:one => 1, :two => 2, :three => 3}\n  a.rand_key!  #~> :two\n  a            #~> {:one => 1, :three => 3}","format":"rdoc","aliases":["Random::HashExtensions#pick_key"],"singleton":null,"interfaces":[{"signature":"rand_key!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_key!\n  k,v = rand_pair\n  delete(k)\n  return k\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#pick_key":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#pick_key","name":"pick_key","namespace":"Random::HashExtensions","comment":"Delete a random key-value pair, returning the key.\n\n  a = {:one => 1, :two => 2, :three => 3}\n  a.rand_key!  #~> :two\n  a            #~> {:one => 1, :three => 3}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_key!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_key!\n  k,v = rand_pair\n  delete(k)\n  return k\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#rand_pair":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#rand_pair","name":"rand_pair","namespace":"Random::HashExtensions","comment":"Returns a random key-value pair.\n\n  {:one => 1, :two => 2, :three => 3}.pick  #~> [:one, 1]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_pair()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_pair\n  k = rand_key\n  return k, fetch(k)\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#rand_pair!":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#rand_pair!","name":"rand_pair!","namespace":"Random::HashExtensions","comment":"Deletes a random key-value pair and returns that pair.\n\n  a = {:one => 1, :two => 2, :three => 3}\n  a.rand_pair!  #~> [:two, 2]\n  a             #~> {:one => 1, :three => 3}","format":"rdoc","aliases":["Random::HashExtensions#pick_pair"],"singleton":null,"interfaces":[{"signature":"rand_pair!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_pair!\n  k,v = rand_pair\n  delete( k )\n  return k,v\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#pick_pair":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#pick_pair","name":"pick_pair","namespace":"Random::HashExtensions","comment":"Deletes a random key-value pair and returns that pair.\n\n  a = {:one => 1, :two => 2, :three => 3}\n  a.rand_pair!  #~> [:two, 2]\n  a             #~> {:one => 1, :three => 3}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_pair!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_pair!\n  k,v = rand_pair\n  delete( k )\n  return k,v\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#rand_value":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#rand_value","name":"rand_value","namespace":"Random::HashExtensions","comment":"Returns a random hash value.\n\n  {:one => 1, :two => 2, :three => 3}.rand_value  #~> 2\n  {:one => 1, :two => 2, :three => 3}.rand_value  #~> 1","format":"rdoc","aliases":["Random::HashExtensions#at_rand"],"singleton":null,"interfaces":[{"signature":"rand_value()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_value\n  fetch(rand_key)\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#rand_value!":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#rand_value!","name":"rand_value!","namespace":"Random::HashExtensions","comment":"Deletes a random key-value pair and returns the value.\n\n  a = {:one => 1, :two => 2, :three => 3}\n  a.at_rand!  #~> 2\n  a           #~> {:one => 1, :three => 3}","format":"rdoc","aliases":["Random::HashExtensions#pick","Random::HashExtensions#at_rand!"],"singleton":null,"interfaces":[{"signature":"rand_value!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_value!\n  k,v = rand_pair\n  delete( k )\n  return v\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#pick":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#pick","name":"pick","namespace":"Random::HashExtensions","comment":"Deletes a random key-value pair and returns the value.\n\n  a = {:one => 1, :two => 2, :three => 3}\n  a.at_rand!  #~> 2\n  a           #~> {:one => 1, :three => 3}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_value!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_value!\n  k,v = rand_pair\n  delete( k )\n  return v\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#at_rand":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#at_rand","name":"at_rand","namespace":"Random::HashExtensions","comment":"Returns a random hash value.\n\n  {:one => 1, :two => 2, :three => 3}.rand_value  #~> 2\n  {:one => 1, :two => 2, :three => 3}.rand_value  #~> 1","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_value()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_value\n  fetch(rand_key)\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#at_rand!":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#at_rand!","name":"at_rand!","namespace":"Random::HashExtensions","comment":"Deletes a random key-value pair and returns the value.\n\n  a = {:one => 1, :two => 2, :three => 3}\n  a.at_rand!  #~> 2\n  a           #~> {:one => 1, :three => 3}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_value!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_value!\n  k,v = rand_pair\n  delete( k )\n  return v\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#shuffle":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#shuffle","name":"shuffle","namespace":"Random::HashExtensions","comment":"Returns a copy of the hash with _values_ arranged\nin new random order.\n\n  h = {:a=>1, :b=>2, :c=>3}\n  h.shuffle  #~> {:b=>2, :c=>1, :a>3}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shuffle()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def shuffle\n  ::Hash.zip( keys.sort_by{Random.number}, values.sort_by{Random.number} )\nend","language":"ruby","dynamic":null,"tags":{}},"Random::HashExtensions#shuffle!":{"!":"method","declarations":["instance","public"],"path":"Random::HashExtensions#shuffle!","name":"shuffle!","namespace":"Random::HashExtensions","comment":"Destructive shuffle_hash. Arrange the values in\na new random order.\n\n  h = {:a => 1, :b => 2, :c => 3}\n  h.shuffle!\n  h  #~> {:b=>2, :c=>1, :a=>3}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shuffle!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def shuffle!\n  self.replace(shuffle)\nend","language":"ruby","dynamic":null,"tags":{}},"Random::StringExtensions":{"!":"module","path":"Random::StringExtensions","name":"StringExtensions","namespace":"Random","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":["Random::StringExtensions::Self"],"classes":[],"methods":["Random::StringExtensions.included","Random::StringExtensions#at_rand","Random::StringExtensions#at_rand!","Random::StringExtensions#rand_byte","Random::StringExtensions#rand_byte!","Random::StringExtensions#rand_index","Random::StringExtensions#shuffle","Random::StringExtensions#shuffle!"],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Random::StringExtensions.included":{"!":"method","declarations":["class","public"],"path":"Random::StringExtensions.included","name":"included","namespace":"Random::StringExtensions","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"included(.)","arguments":[{"name":"base"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def self.included(base)\n  base.extend(Self)\nend","language":"ruby","dynamic":null,"tags":{"private":null}},"Random::StringExtensions::Self":{"!":"module","path":"Random::StringExtensions::Self","name":"Self","namespace":"Random::StringExtensions","comment":"Class-level methods.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Random::StringExtensions::Self#random"],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Random::StringExtensions::Self#random":{"!":"method","declarations":["instance","public"],"path":"Random::StringExtensions::Self#random","name":"random","namespace":"Random::StringExtensions::Self","comment":"Returns a randomly generated string. One possible use is\npassword initialization. Takes a max legnth of characters\n(default 8) and an optional valid char Regexp (default /\\w\\d/).\n\n  String.random    #~> 'dd4qed4r'\n\nCREDIT George Moschovitis\n--\nTODO: This is not very efficient. Better way?\n++","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"random(max_length = 8, char_re = /[\\w\\d]/)","arguments":[{"name":"max_length","default":"8"},{"name":"char_re","default":"/[\\w\\d]/"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def random(max_length = 8, char_re = /[\\w\\d]/)\n  raise ArgumentError.new('char_re must be a regular expression!') unless char_re.is_a?(Regexp)\n  string = \"\"\n  while string.length < max_length\n      ch = Random.number(255).chr\n      string << ch if ch =~ char_re\n  end\n  return string\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Random::StringExtensions#at_rand":{"!":"method","declarations":["instance","public"],"path":"Random::StringExtensions#at_rand","name":"at_rand","namespace":"Random::StringExtensions","comment":"Return a random separation of the string.\nDefault separation is by charaacter.\n\n  \"Ruby rules\".at_rand(' ')  #~> [\"Ruby\"]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"at_rand(separator=//)","arguments":[{"name":"separator","default":"//"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def at_rand( separator=// )\n  #separator = self.class.patterns( separator )\n  self.split(separator,-1).at_rand\nend","language":"ruby","dynamic":null,"tags":{}},"Random::StringExtensions#at_rand!":{"!":"method","declarations":["instance","public"],"path":"Random::StringExtensions#at_rand!","name":"at_rand!","namespace":"Random::StringExtensions","comment":"Return a random separation while removing it\nfrom the string. Default separation is by character.\n\n  s = \"Ruby rules\"\n  s.at_rand!(' ')    #~> \"Ruby\"\n  s                  #~> \"rules\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"at_rand!(separator=//)","arguments":[{"name":"separator","default":"//"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def at_rand!( separator=// )\n  #separator = self.class.patterns( separator )\n  a = self.shatter( separator )\n  w = []; a.each_with_index { |s,i| i % 2 == 0 ? w << s : w.last << s }\n  i = Random.number(w.size)\n  r = w.delete_at( i )\n  self.replace( w.join('') )\n  return r\nend","language":"ruby","dynamic":null,"tags":{}},"Random::StringExtensions#rand_byte":{"!":"method","declarations":["instance","public"],"path":"Random::StringExtensions#rand_byte","name":"rand_byte","namespace":"Random::StringExtensions","comment":"Return a random byte of _self_.\n\n  \"Ruby rules\".rand_byte  #~> 121","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_byte()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_byte\n  self[Random.number(size)]\nend","language":"ruby","dynamic":null,"tags":{}},"Random::StringExtensions#rand_byte!":{"!":"method","declarations":["instance","public"],"path":"Random::StringExtensions#rand_byte!","name":"rand_byte!","namespace":"Random::StringExtensions","comment":"Destructive rand_byte. Delete a random byte of _self_ and return it.\n\n  s = \"Ruby rules\"\n  s.rand_byte!      #~> 121\n  s                 #~> \"Rub rules\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_byte!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_byte!\n  i = Random.number(size)\n  rv = self[i,1]\n  self[i,1] = ''\n  rv\nend","language":"ruby","dynamic":null,"tags":{}},"Random::StringExtensions#rand_index":{"!":"method","declarations":["instance","public"],"path":"Random::StringExtensions#rand_index","name":"rand_index","namespace":"Random::StringExtensions","comment":"Return a random string index.\n\n  \"Ruby rules\".rand_index  #~> 3","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rand_index()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def rand_index\n  Random.number(size)\nend","language":"ruby","dynamic":null,"tags":{}},"Random::StringExtensions#shuffle":{"!":"method","declarations":["instance","public"],"path":"Random::StringExtensions#shuffle","name":"shuffle","namespace":"Random::StringExtensions","comment":"Return the string with seperated sections arranged\nin a random order. The default seperation is by character.\n\n  \"Ruby rules\".shuffle  #~> \"e lybRsuur\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shuffle(separator=//)","arguments":[{"name":"separator","default":"//"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def shuffle(separator=//)\n  split(separator).shuffle.join('')\nend","language":"ruby","dynamic":null,"tags":{}},"Random::StringExtensions#shuffle!":{"!":"method","declarations":["instance","public"],"path":"Random::StringExtensions#shuffle!","name":"shuffle!","namespace":"Random::StringExtensions","comment":"In place version of shuffle.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shuffle!(separator=//)","arguments":[{"name":"separator","default":"//"}]}],"returns":[],"file":"/lib/standard/facets/random.rb","line":null,"source":"def shuffle!(separator=//)\n  self.replace( shuffle(separator) )\nend","language":"ruby","dynamic":null,"tags":{}},"Range":{"!":"class","superclass":"Object","path":"Range","name":"Range","namespace":"","comment":"","format":"rdoc","constants":[],"includes":["Random::RangeExtensions"],"extensions":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Integer":{"!":"class","superclass":"Object","path":"Integer","name":"Integer","namespace":"","comment":"","format":"rdoc","constants":[],"includes":["Random::IntegerExtensions"],"extensions":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/standard/facets/random.rb"],"tags":{}},"Numeric":{"!":"class","superclass":"Object","path":"Numeric","name":"Numeric","namespace":"","comment":"","format":"rdoc","constants":[],"includes":["Numeric::Multipliers","Random::NumericExtensions"],"extensions":[],"modules":["Numeric::Multipliers"],"classes":[],"methods":[],"accessors":[],"files":["/lib/standard/facets/random.rb","/lib/standard/facets/multipliers.rb"],"tags":{}},"OpenStruct":{"!":"class","superclass":"Object","path":"OpenStruct","name":"OpenStruct","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["OpenStruct#initialize","OpenStruct#each","OpenStruct#to_h","OpenStruct#[]","OpenStruct#[]=","OpenStruct#instance_delegate","OpenStruct#ostruct_delegate","OpenStruct#ostruct_update","OpenStruct#ostruct_merge","OpenStruct#__update__","OpenStruct#__merge__","OpenStruct#to_ostruct"],"accessors":[],"files":["/lib/standard/facets/ostruct.rb"],"tags":{}},"OpenStruct#initialize":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#initialize","name":"initialize","namespace":"OpenStruct","comment":"Allows the initialization of an OpenStruct with a setter block:\n\n  person = OpenStruct.new do |o|\n    o.name    = 'John Smith'\n    o.gender  = :M\n    o.age     = 71\n  end\n\nYou can still provide a hash for initialization purposes, and even combine\nthe two approaches if you wish.\n\n  person = OpenStruct.new(:name => 'John Smith', :age => 31) do |p|\n    p.gender = :M\n  end\n\nAlternatively you can provide a default block:\n\n  stuff = OpenStruct.new{ |o,k| o[k] = [] }\n  stuff.place << :a\n  stuff.place << :b\n  stuff.place #=> [:a, :b]\n\nA setter block versus a defualt block is determined by the arity of\nthe block. You can not provide both at the same time.\n\nCREDIT: Noah Gibbs, Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(hash=nil, &block)","arguments":[{"name":"hash","default":"nil"}],"block":{"name":"&block"}}],"returns":[{"type":"OpenStruct","comment":"a new instance of OpenStruct"}],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def initialize(hash=nil, &block)\n  if block && block.arity==2\n    @table = Hash.new(&block)\n  else\n    @table = {}\n  end\n  if hash\n    for k,v in hash\n      @table[k.to_sym] = v\n      new_ostruct_member(k)\n    end\n  end\n  if block && block.arity==1\n    yield self\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"OpenStruct#each":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#each","name":"each","namespace":"OpenStruct","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each(&blk)","arguments":[],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def each(&blk)\n  @table.each(&blk)\nend","language":"ruby","dynamic":null,"tags":{}},"OpenStruct#to_h":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#to_h","name":"to_h","namespace":"OpenStruct","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def to_h\n  @table.dup\nend","language":"ruby","dynamic":null,"tags":{}},"OpenStruct#[]":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#[]","name":"[]","namespace":"OpenStruct","comment":"Access a value in the OpenStruct by key, like a Hash.\nThis increases OpenStruct's \"duckiness\".\n\n  o = OpenStruct.new\n  o.t = 4\n  o['t']  #=> 4","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](key)","arguments":[{"name":"key"}]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def [](key)\n  key = key.to_sym unless key.is_a?(Symbol)\n  @table[key]\nend","language":"ruby","dynamic":null,"tags":{}},"OpenStruct#[]=":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#[]=","name":"[]=","namespace":"OpenStruct","comment":"Set a value in the OpenStruct by key, like a Hash.\n\n  o = OpenStruct.new\n  o['t'] = 4\n  o.t  #=> 4","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[]=(key,val)","arguments":[{"name":"key"},{"name":"val"}]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def []=(key,val)\n  raise TypeError, \"can't modify frozen #{self.class}\", caller(1) if self.frozen?\n  key = key.to_sym unless key.is_a?(Symbol)\n  @table[key]=val\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"OpenStruct#instance_delegate":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#instance_delegate","name":"instance_delegate","namespace":"OpenStruct","comment":"Provides access to an OpenStruct's inner table.\n\n  o = OpenStruct.new\n  o.a = 1\n  o.b = 2\n  o.instance_delegate.map { |k, v| \"#{k} #{v}\" }\n  #=> [\"a 1\", \"b 2\"]","format":"rdoc","aliases":["OpenStruct#ostruct_delegate"],"singleton":null,"interfaces":[{"signature":"instance_delegate()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def instance_delegate\n  @table\nend","language":"ruby","dynamic":null,"tags":{}},"OpenStruct#ostruct_delegate":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#ostruct_delegate","name":"ostruct_delegate","namespace":"OpenStruct","comment":"Provides access to an OpenStruct's inner table.\n\n  o = OpenStruct.new\n  o.a = 1\n  o.b = 2\n  o.instance_delegate.map { |k, v| \"#{k} #{v}\" }\n  #=> [\"a 1\", \"b 2\"]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_delegate()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def instance_delegate\n  @table\nend","language":"ruby","dynamic":null,"tags":{}},"OpenStruct#ostruct_update":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#ostruct_update","name":"ostruct_update","namespace":"OpenStruct","comment":"Insert/update hash data on the fly.\n\n  o = OpenStruct.new\n  o.ostruct_update(:a => 2)\n  o.a  #=> 2","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ostruct_update(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def ostruct_update(other)\n  raise TypeError, \"can't modify frozen #{self.class}\", caller(1) if self.frozen?\n  ##other = other.to_hash  #to_h ?\n  for k,v in other\n    @table[k.to_sym] = v\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"OpenStruct#ostruct_merge":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#ostruct_merge","name":"ostruct_merge","namespace":"OpenStruct","comment":"Merge hash data creating a new OpenStruct object.\n\n  o = OpenStruct.new\n  x = o.ostruct_merge(:a => 2)\n  x.a  #=> 2","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ostruct_merge(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def ostruct_merge(other)\n  o = dup\n  o.ostruct_update(other)\n  o\nend","language":"ruby","dynamic":null,"tags":{}},"OpenStruct#__update__":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#__update__","name":"__update__","namespace":"OpenStruct","comment":"Insert/update hash data on the fly.\n\n  o = OpenStruct.new\n  o.ostruct_update(:a => 2)\n  o.a  #=> 2","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__update__(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def __update__(other)\n  raise TypeError, \"can't modify frozen #{self.class}\", caller(1) if self.frozen?\n  ##other = other.to_hash #to_h?\n  for k,v in other\n    @table[k.to_sym] = v\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"OpenStruct#__merge__":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#__merge__","name":"__merge__","namespace":"OpenStruct","comment":"Merge hash data creating a new OpenStruct object.\n\n  o = OpenStruct.new\n  x = o.ostruct_merge(:a => 2)\n  x.a  #=> 2","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__merge__(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def __merge__(other)\n  o = dup\n  o.__update__(other)\n  o\nend","language":"ruby","dynamic":null,"tags":{}},"OpenStruct#to_ostruct":{"!":"method","declarations":["instance","public"],"path":"OpenStruct#to_ostruct","name":"to_ostruct","namespace":"OpenStruct","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_ostruct()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def to_ostruct\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#to_ostruct":{"!":"method","declarations":["instance","public"],"path":"Hash#to_ostruct","name":"to_ostruct","namespace":"Hash","comment":"Turns a hash into a generic object using an OpenStruct.\n\n  o = {'a' => 1}.to_ostruct\n  o.a  #=> 1","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_ostruct()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def to_ostruct\n  OpenStruct.new(self)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#to_ostruct_recurse":{"!":"method","declarations":["instance","public"],"path":"Hash#to_ostruct_recurse","name":"to_ostruct_recurse","namespace":"Hash","comment":"Like to_ostruct but recusively objectifies all hash elements as well.\n\n  o = {'a' => { 'b' => 1 }}.to_ostruct_recurse\n  o.a.b  #=> 1\n\nThe +exclude+ parameter is used internally to prevent infinite\nrecursion and is not intended to be utilized by the end-user.\nBut for more advance use, if there is a particular subhash you\nwould like to prevent from being converted to an OpoenStruct\nthen include it in the +exclude+ hash referencing itself. Eg.\n\n  h = { 'a' => { 'b' => 1 } }\n  o = h.to_ostruct_recurse( { h['a'] => h['a'] } )\n  o.a['b']  #=> 1\n\nCREDIT: Alison Rowland, Jamie Macey, Mat Schaffer","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_ostruct_recurse(exclude={})","arguments":[{"name":"exclude","default":"{}"}]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def to_ostruct_recurse(exclude={})\n  return exclude[self] if exclude.key?( self )\n  o = exclude[self] = OpenStruct.new\n  h = self.dup\n  each_pair do |k,v|\n    h[k] = v.to_ostruct_recurse( exclude ) if v.respond_to?(:to_ostruct_recurse)\n  end\n  o.__update__(h)\nend","language":"ruby","dynamic":null,"tags":{}},"NilClass":{"!":"class","superclass":"Object","path":"NilClass","name":"NilClass","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["NilClass#to_ostruct","NilClass#to_path"],"accessors":[],"files":["/lib/standard/facets/ostruct.rb","/lib/standard/facets/pathname.rb"],"tags":{}},"NilClass#to_ostruct":{"!":"method","declarations":["instance","public"],"path":"NilClass#to_ostruct","name":"to_ostruct","namespace":"NilClass","comment":"Create an empty OpenStruct object.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_ostruct()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/ostruct.rb","line":null,"source":"def to_ostruct\n  OpenStruct.new\nend","language":"ruby","dynamic":null,"tags":{}},"StringScanner":{"!":"class","superclass":"Object","path":"StringScanner","name":"StringScanner","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["StringScanner#scan_before"],"accessors":[],"files":["/lib/standard/facets/strscan.rb"],"tags":{}},"StringScanner#scan_before":{"!":"method","declarations":["instance","public"],"path":"StringScanner#scan_before","name":"scan_before","namespace":"StringScanner","comment":"scans string until +pattern+ is encountered. If +pattern+ will not be\nencountered then it returns _nil_ but if +scan_anyway+ is _true_ then\nit scans until the end of the string.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"scan_before(pattern, scan_anyway = false)","arguments":[{"name":"pattern"},{"name":"scan_anyway","default":"false"}]}],"returns":[],"file":"/lib/standard/facets/strscan.rb","line":null,"source":"def scan_before(pattern, scan_anyway = false)\n  if not check_until(pattern) and not scan_anyway then return nil; end\n  result = \"\"\n  result << getch until check(pattern) or eos?\n  return result\nend","language":"ruby","dynamic":null,"tags":{}},"Math":{"!":"module","path":"Math","name":"Math","namespace":"","comment":"","format":"rdoc","constants":["Math::INVERSE_LN_2","Math::FACTORIALS","Math::EPSILON"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Math.cdf","Math.abs","Math.std","Math.standard_deviation","Math.pstd","Math.stderr","Math.rmd","Math.relative_mean_difference","Math.pow","Math.sqr","Math.csc","Math.sum","Math.sec","Math.lcm","Math.cot","Math.gcd","Math.amd","Math.absolute_mean_difference","Math.min","Math.max","Math.csch","Math.mean","Math.mean_average","Math.acot","Math.beta","Math.sinc","Math.root","Math.sech","Math.coth","Math.log2","Math.acsc","Math.exp2","Math.sign","Math.ceil","Math.asec","Math#acsch","Math.floor","Math.delta","Math.round","Math.exp10","Math#asech","Math.acoth","Math.gamma","Math.median","Math.lgamma","Math.tgamma","Math.sqsolve","Math.epsilon","Math.variance","Math.variance2","Math.pvariance","Math.linsolve","Math.factorial","Math.percentile","Math.theil_index","Math.approx_equal","Math.kldivergence","Math.summed_sqdevs","Math.atkinson_index","Math.gini_coefficient"],"accessors":[],"files":["/lib/standard/facets/math/cdf.rb","/lib/standard/facets/math/abs.rb","/lib/standard/facets/math/std.rb","/lib/standard/facets/math/rmd.rb","/lib/standard/facets/math/pow.rb","/lib/standard/facets/math/sqr.rb","/lib/standard/facets/math/csc.rb","/lib/standard/facets/math/sum.rb","/lib/standard/facets/math/sec.rb","/lib/standard/facets/math/lcm.rb","/lib/standard/facets/math/cot.rb","/lib/standard/facets/math/gcd.rb","/lib/standard/facets/math/amd.rb","/lib/standard/facets/math/min.rb","/lib/standard/facets/math/csch.rb","/lib/standard/facets/math/mean.rb","/lib/standard/facets/math/acot.rb","/lib/standard/facets/math/beta.rb","/lib/standard/facets/math/sinc.rb","/lib/standard/facets/math/root.rb","/lib/standard/facets/math/sech.rb","/lib/standard/facets/math/coth.rb","/lib/standard/facets/math/log2.rb","/lib/standard/facets/math/acsc.rb","/lib/standard/facets/math/exp2.rb","/lib/standard/facets/math/sign.rb","/lib/standard/facets/math/ceil.rb","/lib/standard/facets/math/asec.rb","/lib/standard/facets/math/acsch.rb","/lib/standard/facets/math/floor.rb","/lib/standard/facets/math/delta.rb","/lib/standard/facets/math/round.rb","/lib/standard/facets/math/exp10.rb","/lib/standard/facets/math/asech.rb","/lib/standard/facets/math/acoth.rb","/lib/standard/facets/math/gamma.rb","/lib/standard/facets/math/median.rb","/lib/standard/facets/math/lgamma.rb","/lib/standard/facets/math/tgamma.rb","/lib/standard/facets/math/sqsolve.rb","/lib/standard/facets/math/epsilon.rb","/lib/standard/facets/math/variance.rb","/lib/standard/facets/math/linsolve.rb","/lib/standard/facets/math/factorial.rb","/lib/standard/facets/math/percentile.rb","/lib/standard/facets/math/theil_index.rb","/lib/standard/facets/math/approx_equal.rb","/lib/standard/facets/math/kldivergence.rb","/lib/standard/facets/math/summed_sqdevs.rb","/lib/standard/facets/math/atkinson_index.rb","/lib/standard/facets/math/gini_coefficient.rb"],"tags":{}},"Math::INVERSE_LN_2":{"!":"constant","path":"Math::INVERSE_LN_2","name":"INVERSE_LN_2","namespace":"Math","comment":"","format":"rdoc","value":"1.0 / ::Math.log(2.0)","tags":{},"files":["/lib/standard/facets/math/log2.rb"]},"Math::FACTORIALS":{"!":"constant","path":"Math::FACTORIALS","name":"FACTORIALS","namespace":"Math","comment":"First 16 factorials.","format":"rdoc","value":"[\n  1,\n  1,\n  2,\n  6,\n  24,\n  120,\n  720,\n  5_040,\n  40_320,\n  362_880,\n  3_628_800,\n  39_916_800,\n  479_001_600,\n  6_227_020_800,\n  87_178_291_200,\n  1_307_674_368_000\n]","tags":{},"files":["/lib/standard/facets/math/factorial.rb"]},"Math::EPSILON":{"!":"constant","path":"Math::EPSILON","name":"EPSILON","namespace":"Math","comment":"","format":"rdoc","value":"0.000000001","tags":{},"files":["/lib/standard/facets/math/approx_equal.rb"]},"Math.cdf":{"!":"method","declarations":["class","public"],"path":"Math.cdf","name":"cdf","namespace":"Math","comment":"Returns the Cumulative Density Function of this\nsample (normalised to a fraction of 1.0).","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cdf(.)","arguments":[{"name":"array"},{"name":"normalised","default":"1.0"}]}],"returns":[],"file":"/lib/standard/facets/math/cdf.rb","line":null,"source":"def self.cdf(array, normalised=1.0)\n  s = sum(array).to_f\n  array.sort.inject([0.0]) { |c,d| c << c[-1] + normalised*d.to_f/s }\nend","language":"ruby","dynamic":null,"tags":{}},"Math.abs":{"!":"method","declarations":["class","public"],"path":"Math.abs","name":"abs","namespace":"Math","comment":"Absolute value of +x+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"abs(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/abs.rb","line":null,"source":"def self.abs(x)\n  x.abs\nend","language":"ruby","dynamic":null,"tags":{}},"Math.std":{"!":"method","declarations":["class","public"],"path":"Math.std","name":"std","namespace":"Math","comment":"Standard deviation of a sample.","format":"rdoc","aliases":["Math.standard_deviation"],"singleton":null,"interfaces":[{"signature":"std(.)","arguments":[{"name":"array"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/math/std.rb","line":null,"source":"def self.std(array, &block)\n  sqrt(variance(array, &block))\nend","language":"ruby","dynamic":null,"tags":{}},"Math.standard_deviation":{"!":"method","declarations":["class","public"],"path":"Math.standard_deviation","name":"standard_deviation","namespace":"Math","comment":"Standard deviation of a sample.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"std(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/math/std.rb","line":null,"source":"def self.std(array, &block)\n  sqrt(variance(array, &block))\nend","language":"ruby","dynamic":null,"tags":{}},"Math.pstd":{"!":"method","declarations":["class","public"],"path":"Math.pstd","name":"pstd","namespace":"Math","comment":"Standard deviation of a population.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pstd(.)","arguments":[{"name":"array"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/math/std.rb","line":null,"source":"def self.pstd(array, &block)\n  Math::sqrt(pvariance(array, &block))\nend","language":"ruby","dynamic":null,"tags":{}},"Math.stderr":{"!":"method","declarations":["class","public"],"path":"Math.stderr","name":"stderr","namespace":"Math","comment":"Calculates the standard error of a sample.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stderr(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/std.rb","line":null,"source":"def self.stderr(array)\n  return 0.0 if array.size < 2\n  std(array) / sqrt(array.size)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.rmd":{"!":"method","declarations":["class","public"],"path":"Math.rmd","name":"rmd","namespace":"Math","comment":"Calculates the relative mean difference of this sample.\nMakes use of the fact that the Gini Coefficient is half the RMD.","format":"rdoc","aliases":["Math.relative_mean_difference"],"singleton":null,"interfaces":[{"signature":"rmd(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/rmd.rb","line":null,"source":"def self.rmd(array)\n  return 0.0 if approx_equal(mean(array), 0.0)\n  gini_coefficient(array) * 2\nend","language":"ruby","dynamic":null,"tags":{}},"Math.relative_mean_difference":{"!":"method","declarations":["class","public"],"path":"Math.relative_mean_difference","name":"relative_mean_difference","namespace":"Math","comment":"Calculates the relative mean difference of this sample.\nMakes use of the fact that the Gini Coefficient is half the RMD.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rmd(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/math/rmd.rb","line":null,"source":"def self.rmd(array)\n  return 0.0 if approx_equal(mean(array), 0.0)\n  gini_coefficient(array) * 2\nend","language":"ruby","dynamic":null,"tags":{}},"Math.pow":{"!":"method","declarations":["class","public"],"path":"Math.pow","name":"pow","namespace":"Math","comment":"+x+ to the power +y+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pow(.)","arguments":[{"name":"x"},{"name":"y"}]}],"returns":[],"file":"/lib/standard/facets/math/pow.rb","line":null,"source":"def self.pow(x, y)\n  x ** y\nend","language":"ruby","dynamic":null,"tags":{}},"Math.sqr":{"!":"method","declarations":["class","public"],"path":"Math.sqr","name":"sqr","namespace":"Math","comment":"Square of number.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sqr(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/sqr.rb","line":null,"source":"def self.sqr(x)\n  x * x\nend","language":"ruby","dynamic":null,"tags":{}},"Math.csc":{"!":"method","declarations":["class","public"],"path":"Math.csc","name":"csc","namespace":"Math","comment":"Cosecans of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"csc(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/csc.rb","line":null,"source":"def self.csc(x)\n  1.0 / sin(x)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.sum":{"!":"method","declarations":["class","public"],"path":"Math.sum","name":"sum","namespace":"Math","comment":"Returns sum.  When a block is given, summation is taken over the \neach result of block evaluation.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sum(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/sum.rb","line":null,"source":"def self.sum(array) #:yield:\n  sum = 0.0\n  if block_given?\n    array.each{|i| sum += yield(i)}\n  else\n    array.each{|i| sum += i}\n  end\n  sum\nend","language":"ruby","dynamic":null,"tags":{}},"Math.sec":{"!":"method","declarations":["class","public"],"path":"Math.sec","name":"sec","namespace":"Math","comment":"Secans of +x+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sec(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/sec.rb","line":null,"source":"def self.sec(x)\n  1.0 / cos(x)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.lcm":{"!":"method","declarations":["class","public"],"path":"Math.lcm","name":"lcm","namespace":"Math","comment":"Least common multiple of +m+ and +n+, computed by multiplying\n+m+ and +n+ and dividing the product by the gcd of +m+ and +n+,\n+nil+ for non-positive numbers.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"lcm(.)","arguments":[{"name":"m"},{"name":"n"}]}],"returns":[],"file":"/lib/standard/facets/math/lcm.rb","line":null,"source":"def self.lcm(m, n)\n  m = Integer(m)\n  n = Integer(n)\n  if m <= 0 || n <= 0\n    return nil\n  end\n  m / gcd(m, n) * n\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Arguments":{"!":"module","path":"Enumerable::Arguments","name":"Arguments","namespace":"Enumerable","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Enumerable::Arguments.wrap_enumerable_method","Enumerable::Arguments#to_a","Enumerable::Arguments#find","Enumerable::Arguments#detect"],"accessors":[],"files":["/lib/standard/facets/enumargs.rb"],"tags":{}},"Enumerable::Arguments.wrap_enumerable_method":{"!":"method","declarations":["class","public"],"path":"Enumerable::Arguments.wrap_enumerable_method","name":"wrap_enumerable_method","namespace":"Enumerable::Arguments","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"wrap_enumerable_method(.)","arguments":[{"name":"methodname"}]}],"returns":[],"file":"/lib/standard/facets/enumargs.rb","line":null,"source":"def self.wrap_enumerable_method( methodname )\n\n  m = methodname\n  meth = Enumerable.instance_method(m)\n  arity = meth.arity\n\n  case arity <=> 0\n  when 0\n    class_eval %{\n      def #{m}( *args, &yld )\n        enum_for(:each, *args).#{m}( &yld )\n      end\n    }\n  when 1\n    class_eval %{\n      def #{m}( *args, &yld )\n        args, each_args = args[0...#{arity}], args[#{arity}..-1]\n        enum_for(:each, *each_args).#{m}( *args, &yld )\n      end\n    }\n  else\n    class_eval %{\n      def #{m}( *args, &yld )\n        enum_for(:each).#{m}( *args, &yld )\n      end\n    }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Arguments#to_a":{"!":"method","declarations":["instance","public"],"path":"Enumerable::Arguments#to_a","name":"to_a","namespace":"Enumerable::Arguments","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_a(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/enumargs.rb","line":null,"source":"def to_a(*args)\n  map(*args){ |x| x }\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Arguments#find":{"!":"method","declarations":["instance","public"],"path":"Enumerable::Arguments#find","name":"find","namespace":"Enumerable::Arguments","comment":"Make exception for #find (a negative arity method) to accept\nkeyword argument.\n\n  ObjectSpace.find(Class, :ifnone=>lambda{1}) { |e| ... }\n  ObjectSpace.find(Class, :ifnone=>lambda{1}) { |e| ... }","format":"rdoc","aliases":["Enumerable::Arguments#detect"],"singleton":null,"interfaces":[{"signature":"find(*args, &yld)","arguments":[{"name":"*args"}],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/standard/facets/enumargs.rb","line":null,"source":"def find(*args, &yld)  # future use **keys ?\n  if Hash === args.last and args.last.key?(:ifnone)\n    ifnone = args.last.delete(:ifnone)\n    args.pop if args.last.empty?\n    enum_for(:each, *args).find( ifnone, &yld )\n  else\n    enum_for(:each, *args).find( &yld )\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Arguments#detect":{"!":"method","declarations":["instance","public"],"path":"Enumerable::Arguments#detect","name":"detect","namespace":"Enumerable::Arguments","comment":"Make exception for #find (a negative arity method) to accept\nkeyword argument.\n\n  ObjectSpace.find(Class, :ifnone=>lambda{1}) { |e| ... }\n  ObjectSpace.find(Class, :ifnone=>lambda{1}) { |e| ... }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"find(*args, &yld)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/enumargs.rb","line":null,"source":"def find(*args, &yld)  # future use **keys ?\n  if Hash === args.last and args.last.key?(:ifnone)\n    ifnone = args.last.delete(:ifnone)\n    args.pop if args.last.empty?\n    enum_for(:each, *args).find( ifnone, &yld )\n  else\n    enum_for(:each, *args).find( &yld )\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Math.cot":{"!":"method","declarations":["class","public"],"path":"Math.cot","name":"cot","namespace":"Math","comment":"Cotangens of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cot(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/cot.rb","line":null,"source":"def self.cot(x)\n  tan((PI * 0.5) - x)\nend","language":"ruby","dynamic":null,"tags":{}},"Interval":{"!":"class","superclass":"Object","path":"Interval","name":"Interval","namespace":"","comment":"While Ruby support the Range class out of the box, is does not quite\nfullfil the role od a real Interval class. For instance, it does\nnot support excluding the front sentinel. This is because Range also\ntries to do triple duty as a simple sequence and as a simple tuple-pair,\nthus limiting its potential as an Interval. The Interval class remedies\nthe situation by commiting to interval behavior, and then extends the class'\ncapabilites beyond that of the standard Range in ways that naturally\nfall out of that.\n\nRange depends on two methods: #succ and #<=>. If numeric ranges were the\nonly concern, those could just as well be #+ and #<=>, but esoteric forms\nmake that unfeasible --the obvious example being a String range. But a\nproper Interval class requires mathematical continuation, thus the Interval\ndepends on #+ and #<=>, as well as #- as the inverse of #+.\n\n  i = Interval.new(1,5)\n  i.to_a            #=> [1,2,3,4,5]\n\n  i = Interval[0,5]\n  i..step(2).to_a   #=> [0,2,4]\n\n  i = Interval[1,5]\n  i.step(-1).to_a   #=> [5,4,3,2,1]\n\n  i = Interval[1,3]\n  i.step(1,2).to_a  #=> [1.0,1.5,2.0,2.5,3.0]","format":"rdoc","constants":[],"includes":["Enumerable::Arguments","Multiton"],"extensions":[],"modules":[],"classes":[],"methods":["Interval.[]","Interval#initialize","Interval#sentinels","Interval#first","Interval#last","Interval#exclude_first?","Interval#exclude_last?","Interval#begin","Interval#end","Interval#exclude_begin?","Interval#exclude_end?","Interval#degenerate?","Interval#null?","Interval#direction","Interval#closed","Interval#opened","Interval#half_closed","Interval#first_closed","Interval#last_closed","Interval#first_opened","Interval#last_opened","Interval#+@","Interval#-@","Interval#~@","Interval#reversed","Interval#distance","Interval#length","Interval#size","Interval#min","Interval#max","Interval#include?","Interval#===","Interval#member?","Interval#each","Interval#step","Interval#eql?"],"accessors":[],"files":["/lib/standard/facets/interval.rb"],"tags":{}},"Interval.[]":{"!":"method","declarations":["class","public"],"path":"Interval.[]","name":"[]","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](.)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def self.[]( *args )\n  self.new( *args )\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#initialize":{"!":"method","declarations":["instance","public"],"path":"Interval#initialize","name":"initialize","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(first, last, exclude_first=false, exclude_last=false)","arguments":[{"name":"first"},{"name":"last"},{"name":"exclude_first","default":"false"},{"name":"exclude_last","default":"false"}]}],"returns":[{"type":"Interval","comment":"a new instance of Interval"}],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def initialize(first, last, exclude_first=false, exclude_last=false )\n  raise ArgumentError, \"bad value for interval\" if first.class != last.class\n  @first = first\n  @last = last\n  @exclude_first = exclude_first\n  @exclude_last = exclude_last\n  @direction = (@last <=> @first)\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Interval#sentinels":{"!":"method","declarations":["instance","public"],"path":"Interval#sentinels","name":"sentinels","namespace":"Interval","comment":"Returns a two element array of first and last sentinels.\n\n (0..10).sentinels   #=> [0,10]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sentinels()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def sentinels\n  return [@first, @last]\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#first":{"!":"method","declarations":["instance","public"],"path":"Interval#first","name":"first","namespace":"Interval","comment":"Returns the first or last sentinal of the interval.","format":"rdoc","aliases":["Interval#begin"],"singleton":null,"interfaces":[{"signature":"first()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def first ; @first ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#last":{"!":"method","declarations":["instance","public"],"path":"Interval#last","name":"last","namespace":"Interval","comment":"","format":"rdoc","aliases":["Interval#end"],"singleton":null,"interfaces":[{"signature":"last()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def last ; @last ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#exclude_first?":{"!":"method","declarations":["instance","public"],"path":"Interval#exclude_first?","name":"exclude_first?","namespace":"Interval","comment":"","format":"rdoc","aliases":["Interval#exclude_begin?"],"singleton":null,"interfaces":[{"signature":"exclude_first?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def exclude_first? ; @exclude_first ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#exclude_last?":{"!":"method","declarations":["instance","public"],"path":"Interval#exclude_last?","name":"exclude_last?","namespace":"Interval","comment":"","format":"rdoc","aliases":["Interval#exclude_end?"],"singleton":null,"interfaces":[{"signature":"exclude_last?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def exclude_last? ; @exclude_last ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#begin":{"!":"method","declarations":["instance","public"],"path":"Interval#begin","name":"begin","namespace":"Interval","comment":"Returns the first or last sentinal of the interval.\n(IMHO) these should be deprectated","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"first()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def first ; @first ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#end":{"!":"method","declarations":["instance","public"],"path":"Interval#end","name":"end","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"last()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def last ; @last ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#exclude_begin?":{"!":"method","declarations":["instance","public"],"path":"Interval#exclude_begin?","name":"exclude_begin?","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"exclude_first?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def exclude_first? ; @exclude_first ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#exclude_end?":{"!":"method","declarations":["instance","public"],"path":"Interval#exclude_end?","name":"exclude_end?","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"exclude_last?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def exclude_last? ; @exclude_last ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#degenerate?":{"!":"method","declarations":["instance","public"],"path":"Interval#degenerate?","name":"degenerate?","namespace":"Interval","comment":"Returns +true+ if the start and end sentinels are equal and the interval is closed; otherwise +false+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"degenerate?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def degenerate? ; @direction == 0 and ! (@exclusive_first or @exclusive_last) ;  end","language":"ruby","dynamic":null,"tags":{}},"Interval#null?":{"!":"method","declarations":["instance","public"],"path":"Interval#null?","name":"null?","namespace":"Interval","comment":"Returns +true+ if the start and end sentinels are equal and the interval is open; otherwise +false+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"null?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def null? ; @direction == 0 and @exclusive_first and @exclusive_last ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#direction":{"!":"method","declarations":["instance","public"],"path":"Interval#direction","name":"direction","namespace":"Interval","comment":"Returns the direction of the interval indicated by +1, 0 or -1.\n\n  (1..5).direction  #=> 1\n  (5..1).direction  #=> -1\n  (1..1).direction  #=> 0","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"direction()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def direction ; @direction ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#closed":{"!":"method","declarations":["instance","public"],"path":"Interval#closed","name":"closed","namespace":"Interval","comment":"Returns a new interval inclusive of of both sentinels.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"closed()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def closed; Interval.new(@first, @last, true, true) ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#opened":{"!":"method","declarations":["instance","public"],"path":"Interval#opened","name":"opened","namespace":"Interval","comment":"Returns a new interval exclusive of both sentinels.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"opened()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def opened; Interval.new(@first, @last, true, true) ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#half_closed":{"!":"method","declarations":["instance","public"],"path":"Interval#half_closed","name":"half_closed","namespace":"Interval","comment":"Returns a new interval with either the first or the last sentinel exclusive.\nIf the parameter is false, the deafult, then the first sentinel is excluded;\nif the parameter is true, the last sentinel is excluded.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"half_closed(e=false)","arguments":[{"name":"e","default":"false"}]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def half_closed(e=false)\n  e ? Interval.new(@first, @last, true, false) : Interval.new(@first, @last, false, true)\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#first_closed":{"!":"method","declarations":["instance","public"],"path":"Interval#first_closed","name":"first_closed","namespace":"Interval","comment":"Returns a new interval with one of the two sentinels opened or closed","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"first_closed()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def first_closed ; Interval.new(@first, @last, false, true) ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#last_closed":{"!":"method","declarations":["instance","public"],"path":"Interval#last_closed","name":"last_closed","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"last_closed()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def last_closed  ; Interval.new(@first, @last, true, false) ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#first_opened":{"!":"method","declarations":["instance","public"],"path":"Interval#first_opened","name":"first_opened","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"first_opened()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def first_opened ; Interval.new(@first, @last, true, false) ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#last_opened":{"!":"method","declarations":["instance","public"],"path":"Interval#last_opened","name":"last_opened","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"last_opened()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def last_opened  ; Interval.new(@first, @last, false, true) ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#+@":{"!":"method","declarations":["instance","public"],"path":"Interval#+@","name":"+@","namespace":"Interval","comment":"Unary shorthands. These return a new interval exclusive of first,\nlast or both sentinels, repectively.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"+@()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def +@ ; Interval.new(first, last, true, false) ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#-@":{"!":"method","declarations":["instance","public"],"path":"Interval#-@","name":"-@","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"-@()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def -@ ; Interval.new(first, last, false, true) ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#~@":{"!":"method","declarations":["instance","public"],"path":"Interval#~@","name":"~@","namespace":"Interval","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"~@()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def ~@ ; Interval.new(first, last, true, true) ; end","language":"ruby","dynamic":null,"tags":{}},"Interval#reversed":{"!":"method","declarations":["instance","public"],"path":"Interval#reversed","name":"reversed","namespace":"Interval","comment":"Returns a new interval with the sentinels reversed.\n\n  (0..10).reversed  #=> 10..0","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"reversed()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def reversed\n  Interval.new(@last, @first, true, true)\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#distance":{"!":"method","declarations":["instance","public"],"path":"Interval#distance","name":"distance","namespace":"Interval","comment":"Returns the length of the interval as the difference between\nthe first and last elements. Returns +nil+ if the sentinal objects\ndo not support distance comparison (#distance).\n\nTODO: Add +n+ parameter to count segmentations like those produced by #each.","format":"rdoc","aliases":["Interval#length","Interval#size"],"singleton":null,"interfaces":[{"signature":"distance()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def distance\n  @last - @first\n  #if @last.respond_to?( :distance )\n  #  @last.distance( @first )\n  #else\n  #  #self.to_a.length\n  #end\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#length":{"!":"method","declarations":["instance","public"],"path":"Interval#length","name":"length","namespace":"Interval","comment":"Returns the length of the interval as the difference between\nthe first and last elements. Returns +nil+ if the sentinal objects\ndo not support distance comparison (#distance).\n\nTODO: Add +n+ parameter to count segmentations like those produced by #each.\nif @last.respond_to?( :distance )\n @last.distance( @first )\nelse\n #self.to_a.length\nend","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"distance()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def distance\n  @last - @first\n  #if @last.respond_to?( :distance )\n  #  @last.distance( @first )\n  #else\n  #  #self.to_a.length\n  #end\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#size":{"!":"method","declarations":["instance","public"],"path":"Interval#size","name":"size","namespace":"Interval","comment":"Returns the length of the interval as the difference between\nthe first and last elements. Returns +nil+ if the sentinal objects\ndo not support distance comparison (#distance).\n\nTODO: Add +n+ parameter to count segmentations like those produced by #each.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"distance()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def distance\n  @last - @first\n  #if @last.respond_to?( :distance )\n  #  @last.distance( @first )\n  #else\n  #  #self.to_a.length\n  #end\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#min":{"!":"method","declarations":["instance","public"],"path":"Interval#min","name":"min","namespace":"Interval","comment":"Returns the lesser of the first and last sentinals.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"min()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def min\n  ((@first <=> @last) == -1) ? @first : @last\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#max":{"!":"method","declarations":["instance","public"],"path":"Interval#max","name":"max","namespace":"Interval","comment":"Returns the greater of the first and last sentinals.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"max()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def max\n  ((@first <=> @last) == 1) ? @first : @last\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#include?":{"!":"method","declarations":["instance","public"],"path":"Interval#include?","name":"include?","namespace":"Interval","comment":"Returns true or false if the element is part of the interval.","format":"rdoc","aliases":["Interval#===","Interval#member?"],"singleton":null,"interfaces":[{"signature":"include?(x)","arguments":[{"name":"x"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def include?(x)\n  # todo: infinity?\n  tf = exclude_first? ? 1 : 0\n  tl = exclude_last? ? -1 : 0\n  (x <=> first) >= tf and (x <=> last) <= tl\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#===":{"!":"method","declarations":["instance","public"],"path":"Interval#===","name":"===","namespace":"Interval","comment":"Returns true or false if the element is part of the interval.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"include?(x)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def include?(x)\n  # todo: infinity?\n  tf = exclude_first? ? 1 : 0\n  tl = exclude_last? ? -1 : 0\n  (x <=> first) >= tf and (x <=> last) <= tl\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#member?":{"!":"method","declarations":["instance","public"],"path":"Interval#member?","name":"member?","namespace":"Interval","comment":"Returns true or false if the element is part of the interval.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"include?(x)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def include?(x)\n  # todo: infinity?\n  tf = exclude_first? ? 1 : 0\n  tl = exclude_last? ? -1 : 0\n  (x <=> first) >= tf and (x <=> last) <= tl\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#each":{"!":"method","declarations":["instance","public"],"path":"Interval#each","name":"each","namespace":"Interval","comment":"Iterates over the interval, passing each _n_th element to the block.\nIf n is not given then n defaults to 1. Each _n_th step is determined\nby invoking +\\++ or +\\-+ n, depending on the direction of the interval.\nIf n is negative the iteration is preformed in reverse form end sentinal\nto front sentinal. A second parameter, d, can be given in which case\nthe applied step is calculated as a fraction of the interval's length\ntimes n / d. This allows iteration over the whole interval in equal sized\nsegments.\n\n  1..5.each { |e| ... }        #=> 1 2 3 4 5\n  1..5.each(2) { |e| ... }     #=> 1 3 5\n  1..5.each(1,2) { |e| ... }   #=> 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each(n=nil, d=nil)","arguments":[{"name":"n","default":"nil"},{"name":"d","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def each(n=nil, d=nil)  # :yield:\n  if n\n    warn \"FACETS: `interval.each(n,d){...}` will be deprecated.\\n\" +\n         \"Use `interval.step(n,d).each{...}` instead.\"\n  else\n    n = 1\n  end\n\n  return (n < 0 ? @last : @first) if degenerate?  # is this right for all values of n ?\n\n  s = d ? self.length.to_f * (n.to_f / d.to_f) : n.abs\n  raise \"Cannot iterate over zero length steps.\" if s == 0\n  s = s * @direction\n  if n < 0\n    e = @exclude_last ? @last - s : @last\n    #e = @exclude_last ? @last.pred(s) : @last\n    t = @exclude_last ? 1 : 0\n    #while e.cmp(@first) >= t\n    while (e <=> @first) >= t\n      yield(e)\n      e -= s\n      #e = e.pred(s)\n    end\n  else\n    e = @exclude_first ? @first + s : @first\n    #e = @exclude_first ? @first.succ(s) : @first\n    t = @exclude_last ? -1 : 0\n    #while e.cmp(@last) <= t\n    while (e <=> @last) <= t\n      yield(e)\n      e += s\n      #e = e.succ(s)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{"todo":"Deprecate arguments and simplify each definition accordingly."}},"Interval#step":{"!":"method","declarations":["instance","public"],"path":"Interval#step","name":"step","namespace":"Interval","comment":":yield:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"step(n=1, d=nil)","arguments":[{"name":"n","default":"1"},{"name":"d","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def step(n=1, d=nil)  # :yield:\n  return (n < 0 ? @last : @first) if degenerate?  # is this right for all values of n ?\n\n  if block_given?\n    s = d ? self.length.to_f * (n.to_f / d.to_f) : n.abs\n    raise \"Cannot iterate over zero length steps.\" if s == 0\n    s = s * @direction\n    if n < 0\n      e = @exclude_last ? @last - s : @last\n      #e = @exclude_last ? @last.pred(s) : @last\n      t = @exclude_last ? 1 : 0\n      #while e.cmp(@first) >= t\n      while (e <=> @first) >= t\n        yield(e)\n        e -= s\n        #e = e.pred(s)\n      end\n    else\n      e = @exclude_first ? @first + s : @first\n      #e = @exclude_first ? @first.succ(s) : @first\n      t = @exclude_last ? -1 : 0\n      #while e.cmp(@last) <= t\n      while (e <=> @last) <= t\n        yield(e)\n        e += s\n        #e = e.succ(s)\n      end\n    end\n  else\n    Enumerator.new(self, :step, n, d)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Interval#eql?":{"!":"method","declarations":["instance","public"],"path":"Interval#eql?","name":"eql?","namespace":"Interval","comment":"Compares two intervals to see if they are equal","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"eql?(other)","arguments":[{"name":"other"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/interval.rb","line":null,"source":"def eql?(other)\n  return false unless @first == other.first\n  return false unless @last == other.last\n  return false unless @exclude_first == other.exclude_first?\n  return false unless @exclude_last == other.exclude_last?\n  true\nend","language":"ruby","dynamic":null,"tags":{}},"Net":{"!":"module","path":"Net","name":"Net","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Net.download","Net.download_and_save"],"accessors":[],"files":["/lib/standard/facets/net/http.rb"],"tags":{}},"Net.download":{"!":"method","declarations":["class","public"],"path":"Net.download","name":"download","namespace":"Net","comment":"CREDIT: Daniel Huckstep","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"download(.)","arguments":[{"name":"url"},{"name":"limit","default":"10"}]}],"returns":[],"file":"/lib/standard/facets/net/http.rb","line":null,"source":"def self.download(url, limit=10)\n  raise ArgumentError, 'HTTP redirect too deep' if limit == 0\n  #url = URI.parse(url)\n  #req = Net::HTTP::Get.new(url.path)\n  #req['User-Agent'] = \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.7) Gecko/2009030422 Ubuntu/8.10 (intrepid) Firefox/3.0.7\"\n  #resp = Net::HTTP.new(url.host, url.port).start { |http| http.request(req) }\n  resp = Net::HTTP.get_response(URI.parse(url))\n  case resp\n  when Net::HTTPSuccess     then resp\n  when Net::HTTPRedirection then download(resp['location'], limit - 1)\n  else resp.error!\n  end\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Net.download_and_save":{"!":"method","declarations":["class","public"],"path":"Net.download_and_save","name":"download_and_save","namespace":"Net","comment":"CREDIT: Daniel Huckstep","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"download_and_save(.)","arguments":[{"name":"url"},{"name":"path","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/net/http.rb","line":null,"source":"def self.download_and_save(url, path=nil)\n  if path.nil?\n    path = File.expand_path(url.split('/').last)\n  else\n    path = File.expand_path(path)\n  end\n  raise ArgumentError.new('Save path is a directory') if File.directory?(path)\n  resp = download(url)\n  open(path,'w') { |file| file.write(resp.body) } if resp.is_a?(Net::HTTPSuccess)\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Multiton":{"!":"module","path":"Multiton","name":"Multiton","namespace":"","comment":"= Multiton\n\nMultiton design pattern ensures only one object is allocated for a given state.\n\nThe 'multiton' pattern is similar to a singleton, but instead of only one\ninstance, there are several similar instances.  It is useful when you want to\navoid constructing objects many times because of some huge expense (connecting\nto a database for example), require a set of similar but not identical\nobjects, and cannot easily control how many times a contructor may be called.\n\n  class SomeMultitonClass\n    include Multiton\n    attr :arg\n    def initialize(arg)\n      @arg = arg\n    end\n  end\n\n  a = SomeMultitonClass.new(4)\n  b = SomeMultitonClass.new(4)   # a and b are same object\n  c = SomeMultitonClass.new(2)   # c is a different object\n\n== How It Works\n\nA pool of objects is searched for a previously cached object,\nif one is not found we construct one and cache it in the pool\nbased on class and the args given to the contructor.\n\nA limitation of this approach is that it is impossible to\ndetect if different blocks were given to a contructor (if it takes a\nblock).  So it is the constructor arguments _only_ which determine\nthe uniqueness of an object. To workaround this, define the _class_\nmethod ::multiton_id.\n\n  def SomeMultitonClass.multiton_id(*args, &block)\n    # ...\n  end\n\nWhich should return a hash key used to identify the object being\nconstructed as (not) unique.","format":"rdoc","constants":[],"includes":[],"extensions":["Multiton::Inclusive"],"modules":["Multiton::Inclusive","Multiton::MetaMethods"],"classes":["Multiton::InstanceMutex"],"methods":["Multiton#clone","Multiton#dup","Multiton#_dump"],"accessors":[],"files":["/lib/standard/facets/multiton.rb"],"tags":{}},"Multiton#clone":{"!":"method","declarations":["instance","public"],"path":"Multiton#clone","name":"clone","namespace":"Multiton","comment":"Disable build-in copying methods.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"clone()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def clone\n  raise TypeError, \"can't clone Multiton #{self}\"\n  ##self\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Multiton#dup":{"!":"method","declarations":["instance","public"],"path":"Multiton#dup","name":"dup","namespace":"Multiton","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def dup\n  raise TypeError, \"can't dup Multiton #{self}\"\n  ##self\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Multiton#_dump":{"!":"method","declarations":["instance","protected"],"path":"Multiton#_dump","name":"_dump","namespace":"Multiton","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"_dump(depth=-1))","arguments":[{"name":"depth","default":"-1)"}]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def _dump(depth=-1)\n  Marshal.dump(@multiton_initializer)\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::InstanceMutex":{"!":"class","superclass":"Hash","path":"Multiton::InstanceMutex","name":"InstanceMutex","namespace":"Multiton","comment":"Mutex to safely store multiton instances.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Multiton::InstanceMutex#initialize","Multiton::InstanceMutex#initialized","Multiton::InstanceMutex.synchronize","Multiton::InstanceMutex#default"],"accessors":[],"files":["/lib/standard/facets/multiton.rb"],"tags":{}},"Multiton::InstanceMutex#initialize":{"!":"method","declarations":["instance","public"],"path":"Multiton::InstanceMutex#initialize","name":"initialize","namespace":"Multiton::InstanceMutex","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize()","arguments":[]}],"returns":[{"type":"InstanceMutex","comment":"a new instance of InstanceMutex"}],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def initialize\n  @global = Mutex.new\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::InstanceMutex#initialized":{"!":"method","declarations":["instance","public"],"path":"Multiton::InstanceMutex#initialized","name":"initialized","namespace":"Multiton::InstanceMutex","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialized(arg)","arguments":[{"name":"arg"}]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def initialized(arg)\n  store(arg, DummyMutex)\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::InstanceMutex.synchronize":{"!":"method","declarations":["class","public"],"path":"Multiton::InstanceMutex.synchronize","name":"synchronize","namespace":"Multiton::InstanceMutex","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"synchronize(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def (DummyMutex = Object.new).synchronize\n  yield\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::InstanceMutex#default":{"!":"method","declarations":["instance","public"],"path":"Multiton::InstanceMutex#default","name":"default","namespace":"Multiton::InstanceMutex","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"default(arg)","arguments":[{"name":"arg"}]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def default(arg)\n  @global.synchronize{ fetch(arg){ store(arg, Mutex.new) } }\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::Inclusive":{"!":"module","path":"Multiton::Inclusive","name":"Inclusive","namespace":"Multiton","comment":"Multiton can be included in another module, in which case that module\neffectively becomes a multiton behavior distributor too. This is why we\npropogate #included to the base module by putting it in another module.\n\n--\n   def append_features(mod)\n     # help out people counting on transitive mixins\n     unless mod.instance_of?(Class)\n       raise TypeError, \"Inclusion of Multiton in module #{mod}\"\n     end\n     super\n   end\n++","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Multiton::Inclusive#included"],"accessors":[],"files":["/lib/standard/facets/multiton.rb"],"tags":{}},"Multiton::Inclusive#included":{"!":"method","declarations":["instance","private"],"path":"Multiton::Inclusive#included","name":"included","namespace":"Multiton::Inclusive","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"included(base)","arguments":[{"name":"base"}]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def included(base)\n  class << base\n    ##alias_method(:new!, :new) unless method_defined?(:new!)\n    ## gracefully handle multiple inclusions of Multiton\n    unless include?(Multiton::MetaMethods)\n      alias_method :new!, :new\n      private :allocate #, :new\n      include Multiton::MetaMethods\n\n      if method_defined?(:marshal_dump)\n        undef_method :marshal_dump\n        warn \"warning: marshal_dump was undefined since it is incompatible with the Multiton pattern\"\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::MetaMethods":{"!":"module","path":"Multiton::MetaMethods","name":"MetaMethods","namespace":"Multiton","comment":"","format":"rdoc","constants":[],"includes":["Multiton::Inclusive"],"extensions":[],"modules":[],"classes":[],"methods":["Multiton::MetaMethods#instance","Multiton::MetaMethods#new","Multiton::MetaMethods#initialized?","Multiton::MetaMethods#multiton_instance","Multiton::MetaMethods#multiton_mutex","Multiton::MetaMethods#reinitialize","Multiton::MetaMethods#_load","Multiton::MetaMethods#multiton_id","Multiton::MetaMethods#singleton_method_added"],"accessors":[],"files":["/lib/standard/facets/multiton.rb"],"tags":{}},"Multiton::MetaMethods#instance":{"!":"method","declarations":["instance","public"],"path":"Multiton::MetaMethods#instance","name":"instance","namespace":"Multiton::MetaMethods","comment":"","format":"rdoc","aliases":["Multiton::MetaMethods#new"],"singleton":null,"interfaces":[{"signature":"instance(*e, &b)","arguments":[{"name":"*e"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def instance(*e, &b)\n  arg = multiton_id(*e, &b)\n  multiton_instance.fetch(arg) do\n    multiton_mutex[arg].synchronize do\n      multiton_instance.fetch(arg) do\n        val = multiton_instance[arg] = new!(*e, &b) #new(*e, &b)\n        val.instance_variable_set(:@multiton_initializer, e, &b)\n        multiton_mutex.initialized(arg)\n        val\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::MetaMethods#new":{"!":"method","declarations":["instance","public"],"path":"Multiton::MetaMethods#new","name":"new","namespace":"Multiton::MetaMethods","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance(*e, &b)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def instance(*e, &b)\n  arg = multiton_id(*e, &b)\n  multiton_instance.fetch(arg) do\n    multiton_mutex[arg].synchronize do\n      multiton_instance.fetch(arg) do\n        val = multiton_instance[arg] = new!(*e, &b) #new(*e, &b)\n        val.instance_variable_set(:@multiton_initializer, e, &b)\n        multiton_mutex.initialized(arg)\n        val\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::MetaMethods#initialized?":{"!":"method","declarations":["instance","public"],"path":"Multiton::MetaMethods#initialized?","name":"initialized?","namespace":"Multiton::MetaMethods","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialized?(*e, &b)","arguments":[{"name":"*e"}],"block":{"name":"&b"}}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def initialized?(*e, &b)\n  multiton_instance.key?(multiton_id(*e, &b))\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::MetaMethods#multiton_instance":{"!":"method","declarations":["instance","protected"],"path":"Multiton::MetaMethods#multiton_instance","name":"multiton_instance","namespace":"Multiton::MetaMethods","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"multiton_instance()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def multiton_instance\n  @multiton_instance ||= Hash.new\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::MetaMethods#multiton_mutex":{"!":"method","declarations":["instance","protected"],"path":"Multiton::MetaMethods#multiton_mutex","name":"multiton_mutex","namespace":"Multiton::MetaMethods","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"multiton_mutex()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def multiton_mutex\n  @multiton_mutex ||= InstanceMutex.new\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::MetaMethods#reinitialize":{"!":"method","declarations":["instance","protected"],"path":"Multiton::MetaMethods#reinitialize","name":"reinitialize","namespace":"Multiton::MetaMethods","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"reinitialize()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def reinitialize\n  multiton_instance.clear\n  multiton_mutex.clear\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::MetaMethods#_load":{"!":"method","declarations":["instance","protected"],"path":"Multiton::MetaMethods#_load","name":"_load","namespace":"Multiton::MetaMethods","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"_load(str)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def _load(str)\n  instance(*Marshal.load(str))\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::MetaMethods#multiton_id":{"!":"method","declarations":["instance","private"],"path":"Multiton::MetaMethods#multiton_id","name":"multiton_id","namespace":"Multiton::MetaMethods","comment":"Default method to to create a key to cache already constructed\ninstances. In the use case MultitonClass.new(e), MultiClass.new(f)\nmust be semantically equal if multiton_id(e).eql?(multiton_id(f))\nevaluates to true.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"multiton_id(*e, &b)","arguments":[{"name":"*e"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def multiton_id(*e, &b)\n  e\nend","language":"ruby","dynamic":null,"tags":{}},"Multiton::MetaMethods#singleton_method_added":{"!":"method","declarations":["instance","private"],"path":"Multiton::MetaMethods#singleton_method_added","name":"singleton_method_added","namespace":"Multiton::MetaMethods","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"singleton_method_added(sym)","arguments":[{"name":"sym"}]}],"returns":[],"file":"/lib/standard/facets/multiton.rb","line":null,"source":"def singleton_method_added(sym)\n  super\n  if (sym == :marshal_dump) & singleton_methods.include?('marshal_dump')\n    raise TypeError, \"Don't use marshal_dump - rely on _dump and _load instead\"\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Math.gcd":{"!":"method","declarations":["class","public"],"path":"Math.gcd","name":"gcd","namespace":"Math","comment":"Greatest common divisor of +m+ and +n+, +nil+ for non-positive\nnumbers - gcd is computed by means of the Euclidian algorithm.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"gcd(.)","arguments":[{"name":"m"},{"name":"n"}]}],"returns":[],"file":"/lib/standard/facets/math/gcd.rb","line":null,"source":"def self.gcd(m, n)\n  m = Integer(m)\n  n = Integer(n)\n  if m <= 0 || n <= 0\n    return nil\n  end\n  loop {\n    if m < n\n      m, n = n, m\n    end\n    if (l = m % n) == 0\n      break\n    end\n    m = l\n  }\n  n\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig":{"!":"module","path":"RbConfig","name":"RbConfig","namespace":"","comment":"An extended rendition of the Ruby's standard RbConfig module.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["RbConfig.inspect","RbConfig.method_missing","RbConfig.datadir","RbConfig.host_os","RbConfig#linux?","RbConfig#mac?","RbConfig#bsd?","RbConfig#windows?","RbConfig#solaris?","RbConfig#symbian?","RbConfig#posix?"],"accessors":[],"files":["/lib/standard/facets/rbconfig.rb"],"tags":{}},"RbConfig.inspect":{"!":"method","declarations":["class","public"],"path":"RbConfig.inspect","name":"inspect","namespace":"RbConfig","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inspect(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def self.inspect\n  CONFIG.inspect\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig.method_missing":{"!":"method","declarations":["class","public"],"path":"RbConfig.method_missing","name":"method_missing","namespace":"RbConfig","comment":"Methodized lookup of config.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(.)","arguments":[{"name":"s"},{"name":"*a"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def self.method_missing(s,*a,&b)\n  s = s.to_s\n  if CONFIG.key?(s)\n    CONFIG[s]\n  elsif CONFIG.key?(s.upcase)\n    CONFIG[s.upcase]\n  else\n    super(s,*a,&b)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig.datadir":{"!":"method","declarations":["class","public"],"path":"RbConfig.datadir","name":"datadir","namespace":"RbConfig","comment":"Return the path to the data directory associated with the\ngiven library/package name. Normally this is just\n\n  \"#{Config::CONFIG['datadir']}/#{name}\"\n\nbut may be modified by tools like RubyGems to handle\nversioned data directories.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"datadir(.)","arguments":[{"name":"package_name"}]}],"returns":[],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def self.datadir(package_name)\n  File.join(CONFIG['datadir'], package_name)\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig.host_os":{"!":"method","declarations":["class","public"],"path":"RbConfig.host_os","name":"host_os","namespace":"RbConfig","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"host_os(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def self.host_os\n  CONFIG['host_os']\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig#linux?":{"!":"method","declarations":["instance","public"],"path":"RbConfig#linux?","name":"linux?","namespace":"RbConfig","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"linux?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def linux?\n  host_os =~ /linux|cygwin/\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig#mac?":{"!":"method","declarations":["instance","public"],"path":"RbConfig#mac?","name":"mac?","namespace":"RbConfig","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mac?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def mac?\n  host_os =~ /mac|darwin/\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig#bsd?":{"!":"method","declarations":["instance","public"],"path":"RbConfig#bsd?","name":"bsd?","namespace":"RbConfig","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bsd?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def bsd?\n  host_os =~ /bsd/\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig#windows?":{"!":"method","declarations":["instance","public"],"path":"RbConfig#windows?","name":"windows?","namespace":"RbConfig","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"windows?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def windows?\n  host_os =~ /mswin|mingw/\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig#solaris?":{"!":"method","declarations":["instance","public"],"path":"RbConfig#solaris?","name":"solaris?","namespace":"RbConfig","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"solaris?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def solaris?\n  host_os =~ /solaris|sunos/\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig#symbian?":{"!":"method","declarations":["instance","public"],"path":"RbConfig#symbian?","name":"symbian?","namespace":"RbConfig","comment":"TODO: who knows what symbian returns?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"symbian?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def symbian?\n  host_os =~ /symbian/\nend","language":"ruby","dynamic":null,"tags":{}},"RbConfig#posix?":{"!":"method","declarations":["instance","public"],"path":"RbConfig#posix?","name":"posix?","namespace":"RbConfig","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"posix?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/rbconfig.rb","line":null,"source":"def posix?\n  linux? or mac? or bsd? or solaris? or begin \n    fork do end\n    true\n  rescue NotImplementedError, NoMethodError\n    false\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Math.amd":{"!":"method","declarations":["class","public"],"path":"Math.amd","name":"amd","namespace":"Math","comment":"The average absolute difference of two independent values drawn \nfrom the sample. Equal to the RMD * mean.","format":"rdoc","aliases":["Math.absolute_mean_difference"],"singleton":null,"interfaces":[{"signature":"amd(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/amd.rb","line":null,"source":"def self.amd(array)\n rmd(array) * mean(array)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.absolute_mean_difference":{"!":"method","declarations":["class","public"],"path":"Math.absolute_mean_difference","name":"absolute_mean_difference","namespace":"Math","comment":"The average absolute difference of two independent values drawn \nfrom the sample. Equal to the RMD * mean.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"amd(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/math/amd.rb","line":null,"source":"def self.amd(array)\n rmd(array) * mean(array)\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname":{"!":"class","superclass":"Object","path":"Pathname","name":"Pathname","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Pathname#to_str","Pathname.[]","Pathname./","Pathname.root","Pathname.home","Pathname.work","Pathname.null","Pathname#/","Pathname#rootname","Pathname#split_root","Pathname#glob","Pathname#glob_first","Pathname#glob_relative","Pathname#glob_flags","Pathname#empty?","Pathname#uptodate?","Pathname#outofdate?","Pathname#visit","Pathname#include?"],"accessors":[],"files":["/lib/standard/facets/pathname.rb"],"tags":{}},"Pathname#to_str":{"!":"method","declarations":["instance","public"],"path":"Pathname#to_str","name":"to_str","namespace":"Pathname","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_str","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"alias_method(:to_str, :to_s)","language":"ruby","dynamic":null,"tags":{}},"Pathname.[]":{"!":"method","declarations":["class","public"],"path":"Pathname.[]","name":"[]","namespace":"Pathname","comment":"Alternate to Pathname#new.\n\n  Pathname['/usr/share']","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](.)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def self.[](path)\n  new(path)\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname./":{"!":"method","declarations":["class","public"],"path":"Pathname./","name":"/","namespace":"Pathname","comment":"Start a path. Another alias for #new.\n\n  Pathname / 'usr'","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"/(.)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def self./(path)\n  new(path)\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname.root":{"!":"method","declarations":["class","public"],"path":"Pathname.root","name":"root","namespace":"Pathname","comment":"Root constant for building paths from root directory onward.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"root(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def self.root\n  Pathname.new('/')\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname.home":{"!":"method","declarations":["class","public"],"path":"Pathname.home","name":"home","namespace":"Pathname","comment":"Home constant for building paths from root directory onward.\n\nTODO: Pathname#home needs to be more robust.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"home(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def self.home\n  Pathname.new('~')\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname.work":{"!":"method","declarations":["class","public"],"path":"Pathname.work","name":"work","namespace":"Pathname","comment":"Work constant for building paths from root directory onward.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"work(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def self.work\n  Pathname.new('.')\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname.null":{"!":"method","declarations":["class","public"],"path":"Pathname.null","name":"null","namespace":"Pathname","comment":"Platform dependent null device.\n\nCREDIT Daniel Burger","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"null(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def self.null\n  case RUBY_PLATFORM\n  when /mswin/i\n    'NUL'\n  when /amiga/i\n    'NIL:'\n  when /openvms/i\n    'NL:'\n  else\n    '/dev/null'\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#/":{"!":"method","declarations":["instance","public"],"path":"Pathname#/","name":"/","namespace":"Pathname","comment":"Try to get this into standard Pathname class.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"/","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"alias_method :/, :+","language":"ruby","dynamic":null,"tags":{}},"Pathname#rootname":{"!":"method","declarations":["instance","public"],"path":"Pathname#rootname","name":"rootname","namespace":"Pathname","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rootname()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def rootname\n  self.class.new(File.rootname(to_s))\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#split_root":{"!":"method","declarations":["instance","public"],"path":"Pathname#split_root","name":"split_root","namespace":"Pathname","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"split_root()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def split_root\n  head, tail = *::File.split_root(to_s)\n  [self.class.new(head), self.class.new(tail)]\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#glob":{"!":"method","declarations":["instance","public"],"path":"Pathname#glob","name":"glob","namespace":"Pathname","comment":"Glob pathnames.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"glob(match, *opts)","arguments":[{"name":"match"},{"name":"*opts"}]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def glob(match, *opts)\n  flags = glob_flags(opts)\n  Dir.glob(::File.join(self.to_s, match), flags).collect{ |m| self.class.new(m) }\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#glob_first":{"!":"method","declarations":["instance","public"],"path":"Pathname#glob_first","name":"glob_first","namespace":"Pathname","comment":"Return the first glob match.\n\nDEPRECATE: While slightly faster then glob().first, not really worth it\nunless this can be rewritten to shortcut on first match (using fnmatch?).\nIn wich case, is there a better name for this method?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"glob_first(match, *opts)","arguments":[{"name":"match"},{"name":"*opts"}]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def glob_first(match, *opts)\n  flags = glob_flags(opts)\n  file = ::Dir.glob(::File.join(self.to_s, match), flags).first\n  file ? self.class.new(file) : nil\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#glob_relative":{"!":"method","declarations":["instance","public"],"path":"Pathname#glob_relative","name":"glob_relative","namespace":"Pathname","comment":"Return globbed matches with pathnames relative to the current pathname.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"glob_relative(match, *opts)","arguments":[{"name":"match"},{"name":"*opts"}]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def glob_relative(match, *opts)\n  flags = glob_flags(opts)\n  files = Dir.glob(::File.join(self.to_s, match), flags)\n  files = files.map{ |f| f.sub(self.to_s.chomp('/') + '/', '') }\n  files.collect{ |m| self.class.new(m) }\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#glob_flags":{"!":"method","declarations":["instance","private"],"path":"Pathname#glob_flags","name":"glob_flags","namespace":"Pathname","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"glob_flags(opts)","arguments":[{"name":"opts"}]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def glob_flags(opts)\n  flags = 0\n  opts.each do |opt|\n    case opt when Symbol, String\n      flags += ::File.const_get(\"FNM_#{opt}\".upcase)\n    else\n      flags += opt\n    end\n  end\n  flags\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#empty?":{"!":"method","declarations":["instance","public"],"path":"Pathname#empty?","name":"empty?","namespace":"Pathname","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"empty?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def empty?\n  Dir.glob(::File.join(to_s, '*')).empty?\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#uptodate?":{"!":"method","declarations":["instance","public"],"path":"Pathname#uptodate?","name":"uptodate?","namespace":"Pathname","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"uptodate?(*sources)","arguments":[{"name":"*sources"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def uptodate?(*sources)\n  ::FileUtils.uptodate?(to_s, sources.flatten)\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#outofdate?":{"!":"method","declarations":["instance","public"],"path":"Pathname#outofdate?","name":"outofdate?","namespace":"Pathname","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"outofdate?(*sources)","arguments":[{"name":"*sources"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def outofdate?(*sources)\n  ::FileUtils.outofdate?(to_s, sources.flatten)\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#visit":{"!":"method","declarations":["instance","public"],"path":"Pathname#visit","name":"visit","namespace":"Pathname","comment":"Recursively visit a directory located by its path, yielding each resource\nas its full matching pathname object. If called on a file, yield the file.\n\ncall-seq:\n  visit => yield each file\n  visit(all: true) => yield visited directories as well\n  visit(hidden: true) => yield hidden files and directories as well\n\nExample use case:\n\n  # Locate any file but *.haml within app/**/*\n  Pathname.new(\"app\").visit do |f|\n    next unless f.to_s =~ /\\.haml$/\n    f\n  end \n\nTODO: Use #map instead of #each ?\n\nCREDIT: Jean-Denis Vauguet","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"visit(options = {:all","arguments":[{"name":"options","default":"{:all => false, :hidden => false}"}],"returns":"false, :hidden"}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def visit(options = {:all => false, :hidden => false})\n  if self.directory?\n    children.each do |entry|\n      next if entry.basename.to_s[0] == \".\" && !options[:hidden]\n      yield(entry) unless entry.directory? && !options[:all]\n      ##entry.visit(:all => options[:all]) { |sub_entry| yield sub_entry } if entry.directory?\n      entry.visit(:all => options[:all], :hidden => options[:hidden]) do |sub_entry|\n        yield(sub_entry)\n      end if entry.directory?\n    end\n  else\n    yield self\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Pathname#include?":{"!":"method","declarations":["instance","public"],"path":"Pathname#include?","name":"include?","namespace":"Pathname","comment":"Does a directory contain a matching entry?\nOr if the pathname is a file, same as #fnmatch.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"include?(pattern,*opts)","arguments":[{"name":"pattern"},{"name":"*opts"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def include?(pattern,*opts)\n  if directory?\n    glob_first(pattern,*opts)\n  else\n    fnmatch(pattern,*opts)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"NilClass#to_path":{"!":"method","declarations":["instance","public"],"path":"NilClass#to_path","name":"to_path","namespace":"NilClass","comment":"Provide platform dependent null path.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_path()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def to_path\n  Pathname.null\nend","language":"ruby","dynamic":null,"tags":{"standard":"require 'facets/pathname'","author":"Daniel Burger"}},"Array#to_path":{"!":"method","declarations":["instance","public"],"path":"Array#to_path","name":"to_path","namespace":"Array","comment":"Convert array to Pathname instance.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_path()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/pathname.rb","line":null,"source":"def to_path\n  Pathname.new(join('/'))\nend","language":"ruby","dynamic":null,"tags":{"standard":"require 'facets/pathname'"}},"Math.min":{"!":"method","declarations":["class","public"],"path":"Math.min","name":"min","namespace":"Math","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"min(.)","arguments":[{"name":"array"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/math/min.rb","line":null,"source":"def self.min(array, &block)\n  if block_given?\n    if min = array.find{ |i| i }\n      min = yield(min)\n      array.each do |i|\n        j = yield(i)\n        min = j if min > j\n      end\n      min\n    end\n  else\n    array.min\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Math.max":{"!":"method","declarations":["class","public"],"path":"Math.max","name":"max","namespace":"Math","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"max(.)","arguments":[{"name":"array"},{"name":"block"}]}],"returns":[],"file":"/lib/standard/facets/math/min.rb","line":null,"source":"def self.max(array, block)\n  if block_given?\n    if max = find{|i| i}\n      max = yield(max)\n      each{|i|\n        j = yield(i)\n        max = j if max < j\n      }\n      max\n    end\n  else\n    array.max\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Platform":{"!":"class","superclass":"Object","path":"Platform","name":"Platform","namespace":"","comment":"Platform class\n\nOriginal version from RubyGems, Copyright (c) 2007 Eric Hodel","format":"rdoc","constants":["Platform::RUBY","Platform::CURRENT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Platform#cpu","Platform#cpu=","Platform#os","Platform#os=","Platform#version","Platform#version=","Platform.supported","Platform.local","Platform.match","Platform.new","Platform#initialize","Platform#inspect","Platform#to_a","Platform#to_s","Platform#==","Platform#===","Platform#=~","Platform#byte_order","Platform#byteorder","Platform#little_endian?","Platform#big_endian?","Platform#interpreter","Platform#mri?","Platform#official_ruby?","Platform#ruby?","Platform#jruby?","Platform#java?","Platform#rubinius?","Platform#rbx?","Platform#ree?","Platform#enterprise?","Platform#ironruby?","Platform#iron_ruby?","Platform#cardinal?","Platform#parrot?","Platform#perl?","Platform#host_os","Platform#linux?","Platform#mac?","Platform#bsd?","Platform#windows?","Platform#solaris?","Platform#symbian?","Platform#posix?"],"accessors":["Platform#cpu","Platform#os","Platform#version"],"files":["/lib/standard/facets/platform.rb"],"tags":{}},"Platform::RUBY":{"!":"constant","path":"Platform::RUBY","name":"RUBY","namespace":"Platform","comment":"A pure-ruby gem that may use Gem::Specification#extensions to build\nbinary files.","format":"rdoc","value":"'ruby'","tags":{},"files":["/lib/standard/facets/platform.rb"]},"Platform::CURRENT":{"!":"constant","path":"Platform::CURRENT","name":"CURRENT","namespace":"Platform","comment":"A platform-specific gem that is built for the packaging ruby's platform.\nThis will be replaced with Gem::Platform::local.","format":"rdoc","value":"'current'","tags":{},"files":["/lib/standard/facets/platform.rb"]},"Platform#cpu":{"!":"method","declarations":["instance","public"],"path":"Platform#cpu","name":"cpu","namespace":"Platform","comment":"Returns the value of attribute cpu","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cpu","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def cpu\n  @cpu\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#cpu=":{"!":"method","declarations":["instance","public"],"path":"Platform#cpu=","name":"cpu=","namespace":"Platform","comment":"Sets the attribute cpu","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cpu=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def cpu=(value)\n  @cpu = value\nend","language":"ruby","dynamic":null,"tags":{"param":"the value to set the attribute cpu to."}},"Platform#os":{"!":"method","declarations":["instance","public"],"path":"Platform#os","name":"os","namespace":"Platform","comment":"Returns the value of attribute os","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"os","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def os\n  @os\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#os=":{"!":"method","declarations":["instance","public"],"path":"Platform#os=","name":"os=","namespace":"Platform","comment":"Sets the attribute os","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"os=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def os=(value)\n  @os = value\nend","language":"ruby","dynamic":null,"tags":{"param":"the value to set the attribute os to."}},"Platform#version":{"!":"method","declarations":["instance","public"],"path":"Platform#version","name":"version","namespace":"Platform","comment":"Returns the value of attribute version","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"version","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def version\n  @version\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#version=":{"!":"method","declarations":["instance","public"],"path":"Platform#version=","name":"version=","namespace":"Platform","comment":"Sets the attribute version","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"version=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def version=(value)\n  @version = value\nend","language":"ruby","dynamic":null,"tags":{"param":"the value to set the attribute version to."}},"Platform.supported":{"!":"method","declarations":["class","public"],"path":"Platform.supported","name":"supported","namespace":"Platform","comment":"Array of supported platforms (ie. pure-Ruby and local platform).","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"supported(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def self.supported\n  @suported ||= [Platform::RUBY, Platform.local]\nend","language":"ruby","dynamic":null,"tags":{}},"Platform.local":{"!":"method","declarations":["class","public"],"path":"Platform.local","name":"local","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"local(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def self.local\n  arch = Config::CONFIG['arch']\n  arch = \"#{arch}_60\" if arch =~ /mswin32$/\n  @local ||= new(arch)\nend","language":"ruby","dynamic":null,"tags":{}},"Platform.match":{"!":"method","declarations":["class","public"],"path":"Platform.match","name":"match","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"match(.)","arguments":[{"name":"platform"}]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def self.match(platform)\n  supported.any? do |local_platform|\n    platform.nil? or local_platform == platform or\n      (local_platform != Platform::RUBY and local_platform =~ platform)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Platform.new":{"!":"method","declarations":["class","public"],"path":"Platform.new","name":"new","namespace":"Platform","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"new(.)","arguments":[{"name":"arch"}]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def self.new(arch) # :nodoc:\n  case arch\n  when Platform::CURRENT then\n    Platform.local\n  when Platform::RUBY, nil, '' then\n    Platform::RUBY\n  else\n    super\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#initialize":{"!":"method","declarations":["instance","public"],"path":"Platform#initialize","name":"initialize","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(arch)","arguments":[{"name":"arch"}]}],"returns":[{"type":"Platform","comment":"a new instance of Platform"}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def initialize(arch)\n  case arch\n  when Array then\n    @cpu, @os, @version = arch\n  when String then\n    arch = arch.split '-'\n\n    if arch.length > 2 and arch.last !~ /\\d/ then # reassemble x86-linux-gnu\n      extra = arch.pop\n      arch.last << \"-#{extra}\"\n    end\n\n    cpu = arch.shift\n\n    @cpu = case cpu\n           when /i\\d86/ then 'x86'\n           else cpu\n           end\n\n    if arch.length == 2 and arch.last =~ /^\\d+$/ then # for command-line\n      @os, @version = arch\n      return\n    end\n\n    os, = arch\n    @cpu, os = nil, cpu if os.nil? # legacy jruby\n\n    @os, @version = case os\n      when /aix(\\d+)/ then             [ 'aix',       $1  ]\n      when /cygwin/ then               [ 'cygwin',    nil ]\n      when /darwin(\\d+)?/ then         [ 'darwin',    $1  ]\n      when /freebsd(\\d+)/ then         [ 'freebsd',   $1  ]\n      when /hpux(\\d+)/ then            [ 'hpux',      $1  ]\n      when /^java$/, /^jruby$/ then    [ 'java',      nil ]\n      when /^java([\\d.]*)/ then        [ 'java',      $1  ]\n      when /linux/ then                [ 'linux',     $1  ]\n      when /mingw32/ then              [ 'mingw32',   nil ]\n      when /(mswin\\d+)(\\_(\\d+))?/ then\n        os, version = $1, $3\n        @cpu = 'x86' if @cpu.nil? and os =~ /32$/\n        [os, version]\n      when /netbsdelf/ then            [ 'netbsdelf', nil ]\n      when /openbsd(\\d+\\.\\d+)/ then    [ 'openbsd',   $1  ]\n      when /solaris(\\d+\\.\\d+)/ then    [ 'solaris',   $1  ]\n      # test\n      when /^(\\w+_platform)(\\d+)/ then [ $1,          $2  ]\n      else                             [ 'unknown',   nil ]\n    end\n  when Platform then\n    @cpu = arch.cpu\n    @os = arch.os\n    @version = arch.version\n  else\n    raise ArgumentError, \"invalid argument #{arch.inspect}\"\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#inspect":{"!":"method","declarations":["instance","public"],"path":"Platform#inspect","name":"inspect","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def inspect\n  \"#s:0x%x @cpu=%p, @os=%p, @version=%p>\" % [self.class, object_id, *to_a]\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#to_a":{"!":"method","declarations":["instance","public"],"path":"Platform#to_a","name":"to_a","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_a()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def to_a\n  [@cpu, @os, @version]\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#to_s":{"!":"method","declarations":["instance","public"],"path":"Platform#to_s","name":"to_s","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_s()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def to_s\n  to_a.compact.join '-'\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#==":{"!":"method","declarations":["instance","public"],"path":"Platform#==","name":"==","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"==(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def ==(other)\n  self.class === other and\n    @cpu == other.cpu and @os == other.os and @version == other.version\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#===":{"!":"method","declarations":["instance","public"],"path":"Platform#===","name":"===","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"===(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def ===(other)\n  return nil unless Platform === other\n\n  # cpu\n  (@cpu == 'universal' or other.cpu == 'universal' or @cpu == other.cpu) and\n\n  # os\n  @os == other.os and\n\n  # version\n  (@version.nil? or other.version.nil? or @version == other.version)\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#=~":{"!":"method","declarations":["instance","public"],"path":"Platform#=~","name":"=~","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"=~(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def =~(other)\n  case other\n  when Platform then # nop\n  when String then\n    # This data is from http://gems.rubyforge.org/gems/yaml on 19 Aug 2007\n    other = case other\n      when /^i686-darwin(\\d)/ then     ['x86',       'darwin',  $1]\n      when /^i\\d86-linux/ then         ['x86',       'linux',   nil]\n      when 'java', 'jruby' then        [nil,         'java',    nil]\n      when /mswin32(\\_(\\d+))?/ then    ['x86',       'mswin32', $2]\n      when 'powerpc-darwin' then       ['powerpc',   'darwin',  nil]\n      when /powerpc-darwin(\\d)/ then   ['powerpc',   'darwin',  $1]\n      when /sparc-solaris2.8/ then     ['sparc',     'solaris', '2.8']\n      when /universal-darwin(\\d)/ then ['universal', 'darwin',  $1]\n      else                             other\n    end\n\n    other = Platform.new other\n  else\n    return nil\n  end\n\n  self === other\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#byte_order":{"!":"method","declarations":["instance","public"],"path":"Platform#byte_order","name":"byte_order","namespace":"Platform","comment":"Byte order of CPU. Determine byte order of underlying machine.\n\nExamines the byte order of the underlying machine. Returns <code>:big</code>\nif Big Endian and <code>:little</code> if Little Endian.\n\nTODO: This doesn't work well apearently. We need to use a chart for possible\ncpus instead, maybe.","format":"rdoc","aliases":["Platform#byteorder"],"singleton":null,"interfaces":[{"signature":"byte_order()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def byte_order\n  if [0x12345678].pack(\"L\") == \"\\x12\\x34\\x56\\x78\"\n    :big\n  else\n    :little\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#byteorder":{"!":"method","declarations":["instance","public"],"path":"Platform#byteorder","name":"byteorder","namespace":"Platform","comment":"Byte order of CPU. Determine byte order of underlying machine.\n\nExamines the byte order of the underlying machine. Returns <code>:big</code>\nif Big Endian and <code>:little</code> if Little Endian.\n\nTODO: This doesn't work well apearently. We need to use a chart for possible\ncpus instead, maybe.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"byte_order()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def byte_order\n  if [0x12345678].pack(\"L\") == \"\\x12\\x34\\x56\\x78\"\n    :big\n  else\n    :little\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#little_endian?":{"!":"method","declarations":["instance","public"],"path":"Platform#little_endian?","name":"little_endian?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"little_endian?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def little_endian?\n  byte_order == :little\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#big_endian?":{"!":"method","declarations":["instance","public"],"path":"Platform#big_endian?","name":"big_endian?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"big_endian?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def big_endian?\n  byte_order == :big\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#interpreter":{"!":"method","declarations":["instance","public"],"path":"Platform#interpreter","name":"interpreter","namespace":"Platform","comment":"Return the name of the ruby interpreter.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"interpreter()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def interpreter\n  @interpreter ||= (\n    if RUBY_PLATFORM == 'parrot'\n      'cardinal'\n    elsif RUBY_ENGINE == 'ruby'\n      if RUBY_DESCRIPTION =~ /Enterprise/i\n        'ree'\n      else\n        'mri'\n      end\n    else\n      RUBY_ENGINE.to_s # jruby, rbx, ironruby, macruby, etc.\n    end\n  )\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#mri?":{"!":"method","declarations":["instance","public"],"path":"Platform#mri?","name":"mri?","namespace":"Platform","comment":"","format":"rdoc","aliases":["Platform#official_ruby?","Platform#ruby?"],"singleton":null,"interfaces":[{"signature":"mri?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def mri?\n  'mri' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#official_ruby?":{"!":"method","declarations":["instance","public"],"path":"Platform#official_ruby?","name":"official_ruby?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mri?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def mri?\n  'mri' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#ruby?":{"!":"method","declarations":["instance","public"],"path":"Platform#ruby?","name":"ruby?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mri?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def mri?\n  'mri' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#jruby?":{"!":"method","declarations":["instance","public"],"path":"Platform#jruby?","name":"jruby?","namespace":"Platform","comment":"","format":"rdoc","aliases":["Platform#java?"],"singleton":null,"interfaces":[{"signature":"jruby?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def jruby?\n  'jruby' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#java?":{"!":"method","declarations":["instance","public"],"path":"Platform#java?","name":"java?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"jruby?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def jruby?\n  'jruby' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#rubinius?":{"!":"method","declarations":["instance","public"],"path":"Platform#rubinius?","name":"rubinius?","namespace":"Platform","comment":"","format":"rdoc","aliases":["Platform#rbx?"],"singleton":null,"interfaces":[{"signature":"rubinius?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def rubinius?\n  'rbx' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#rbx?":{"!":"method","declarations":["instance","public"],"path":"Platform#rbx?","name":"rbx?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rubinius?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def rubinius?\n  'rbx' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#ree?":{"!":"method","declarations":["instance","public"],"path":"Platform#ree?","name":"ree?","namespace":"Platform","comment":"","format":"rdoc","aliases":["Platform#enterprise?"],"singleton":null,"interfaces":[{"signature":"ree?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def ree?\n  'ree' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#enterprise?":{"!":"method","declarations":["instance","public"],"path":"Platform#enterprise?","name":"enterprise?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ree?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def ree?\n  'ree' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#ironruby?":{"!":"method","declarations":["instance","public"],"path":"Platform#ironruby?","name":"ironruby?","namespace":"Platform","comment":"","format":"rdoc","aliases":["Platform#iron_ruby?"],"singleton":null,"interfaces":[{"signature":"ironruby?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def ironruby?\n  'ironruby' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#iron_ruby?":{"!":"method","declarations":["instance","public"],"path":"Platform#iron_ruby?","name":"iron_ruby?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ironruby?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def ironruby?\n  'ironruby' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#cardinal?":{"!":"method","declarations":["instance","public"],"path":"Platform#cardinal?","name":"cardinal?","namespace":"Platform","comment":"","format":"rdoc","aliases":["Platform#parrot?","Platform#perl?"],"singleton":null,"interfaces":[{"signature":"cardinal?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def cardinal?\n  'cardinal' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#parrot?":{"!":"method","declarations":["instance","public"],"path":"Platform#parrot?","name":"parrot?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cardinal?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def cardinal?\n  'cardinal' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#perl?":{"!":"method","declarations":["instance","public"],"path":"Platform#perl?","name":"perl?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cardinal?()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def cardinal?\n  'cardinal' === interpreter\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#host_os":{"!":"method","declarations":["instance","public"],"path":"Platform#host_os","name":"host_os","namespace":"Platform","comment":"O P E R A T I N G  S Y S T E M","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"host_os()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def host_os\n  RbConfig::CONFIG['host_os']\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#linux?":{"!":"method","declarations":["instance","public"],"path":"Platform#linux?","name":"linux?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"linux?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def linux?\n  host_os =~ /linux|cygwin/\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#mac?":{"!":"method","declarations":["instance","public"],"path":"Platform#mac?","name":"mac?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mac?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def mac?\n  host_os =~ /mac|darwin/\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#bsd?":{"!":"method","declarations":["instance","public"],"path":"Platform#bsd?","name":"bsd?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bsd?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def bsd?\n  host_os =~ /bsd/\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#windows?":{"!":"method","declarations":["instance","public"],"path":"Platform#windows?","name":"windows?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"windows?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def windows?\n  host_os =~ /mswin|mingw/\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#solaris?":{"!":"method","declarations":["instance","public"],"path":"Platform#solaris?","name":"solaris?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"solaris?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def solaris?\n  host_os =~ /solaris|sunos/\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#symbian?":{"!":"method","declarations":["instance","public"],"path":"Platform#symbian?","name":"symbian?","namespace":"Platform","comment":"TODO: who knows what symbian returns?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"symbian?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def symbian?\n  host_os =~ /symbian/\nend","language":"ruby","dynamic":null,"tags":{}},"Platform#posix?":{"!":"method","declarations":["instance","public"],"path":"Platform#posix?","name":"posix?","namespace":"Platform","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"posix?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/platform.rb","line":null,"source":"def posix?\n  linux? or mac? or bsd? or solaris? or begin \n    fork do end\n    true\n  rescue NotImplementedError, NoMethodError\n    false\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector":{"!":"class","superclass":"Object","path":"Argvector","name":"Argvector","namespace":"","comment":"= Argvector\n\nArgvector provides a very simple means of parsing\ncommand line arguments.\n\nUnlike other more complex libs this provides only\nthe most basic and standard parsing functionality.\nIn many cases that's all one really needs.\n\nUsage is straight foward. Simply instantiate the\nclass and query it for the particular \"views\" of\nthe command line you want.\n\n  cargs = Argvector.new(\"-a foo -b=2\")\n\n  cargs.parameters    #=> [['foo'],{'a'=>true,'b'=>'2'}]\n  cargs.flags         #=> ['a']\n  cargs.preoptions    #=> {'a'=>true}\n  cargs.preflags      #=> ['a']\n  cargs.subcommand    #=> ['foo', [], {'b'=>'2'}]","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Argvector.parameters","Argvector#line","Argvector#argv","Argvector#arity","Argvector#initialize","Argvector#operands","Argvector#arguments","Argvector#options","Argvector#parameters","Argvector#flags","Argvector#subcommand_with_parameters","Argvector#subcommand","Argvector#subcommand_with_preoptions","Argvector#subcommand_with_arguments","Argvector#preoptions","Argvector#preflags","Argvector#parameters_without_duplicates","Argvector#parse","Argvector#parse_line","Argvector#parse_arity","Argvector#parse_preoptions","Argvector#assoc_options","Argvector#multi_flag","Argvector#format_options"],"accessors":["Argvector#line","Argvector#argv","Argvector#arity"],"files":["/lib/standard/facets/argvector.rb"],"tags":{}},"Argvector.parameters":{"!":"method","declarations":["class","public"],"path":"Argvector.parameters","name":"parameters","namespace":"Argvector","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"parameters(.)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def self.parameters(*args)\n  new.parameters(*args)\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#line":{"!":"method","declarations":["instance","public"],"path":"Argvector#line","name":"line","namespace":"Argvector","comment":"Returns the value of attribute line","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"line","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def line\n  @line\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#argv":{"!":"method","declarations":["instance","public"],"path":"Argvector#argv","name":"argv","namespace":"Argvector","comment":"Returns the value of attribute argv","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"argv","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def argv\n  @argv\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#arity":{"!":"method","declarations":["instance","public"],"path":"Argvector#arity","name":"arity","namespace":"Argvector","comment":"Returns the value of attribute arity","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"arity","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def arity\n  @arity\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#initialize":{"!":"method","declarations":["instance","public"],"path":"Argvector#initialize","name":"initialize","namespace":"Argvector","comment":"Takes the command line string (or array) and options.\nOptions have flags and end with a hash of option arity.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(line=nil, arity=nil)","arguments":[{"name":"line","default":"nil"},{"name":"arity","default":"nil"}]}],"returns":[{"type":"Argvector","comment":"a new instance of Argvector"}],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def initialize(line=nil, arity=nil)\n  @line, @argv  = parse_line(line)\n  @arity = parse_arity(arity||{})\n  parse\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#operands":{"!":"method","declarations":["instance","public"],"path":"Argvector#operands","name":"operands","namespace":"Argvector","comment":"Returns operand array.","format":"rdoc","aliases":["Argvector#arguments"],"singleton":null,"interfaces":[{"signature":"operands()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def operands\n  @operands\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#arguments":{"!":"method","declarations":["instance","public"],"path":"Argvector#arguments","name":"arguments","namespace":"Argvector","comment":"Returns operand array.\ndeprecate alias ?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"operands()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def operands\n  @operands\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#options":{"!":"method","declarations":["instance","public"],"path":"Argvector#options","name":"options","namespace":"Argvector","comment":"Returns options hash.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"options()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def options\n  @options\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#parameters":{"!":"method","declarations":["instance","public"],"path":"Argvector#parameters","name":"parameters","namespace":"Argvector","comment":"Returns [operands, options], which is good for plugging\ndirectly into a method.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"parameters()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def parameters\n  return @operands, @options\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#flags":{"!":"method","declarations":["instance","public"],"path":"Argvector#flags","name":"flags","namespace":"Argvector","comment":"Return flags, which are true options.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"flags()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def flags\n  f = []\n  @options.each do |k, v|\n    if TrueClass===v or FalseClass===v  # not that it's ever false\n      f << k\n    end\n  end\n  return f\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#subcommand_with_parameters":{"!":"method","declarations":["instance","public"],"path":"Argvector#subcommand_with_parameters","name":"subcommand_with_parameters","namespace":"Argvector","comment":"Assumes the first operand is a \"subcommand\" and\nreturns it and the argments following it as\nparameters.","format":"rdoc","aliases":["Argvector#subcommand"],"singleton":null,"interfaces":[{"signature":"subcommand_with_parameters()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def subcommand_with_parameters\n  opts, args = *parse_preoptions(argv)\n  cmd = args.shift\n  subargs = self.class.new(args, @arity)\n  return [cmd, *subargs.parameters]\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#subcommand":{"!":"method","declarations":["instance","public"],"path":"Argvector#subcommand","name":"subcommand","namespace":"Argvector","comment":"Assumes the first operand is a \"subcommand\" and\nreturns it and the argments following it as\nparameters.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"subcommand_with_parameters()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def subcommand_with_parameters\n  opts, args = *parse_preoptions(argv)\n  cmd = args.shift\n  subargs = self.class.new(args, @arity)\n  return [cmd, *subargs.parameters]\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#subcommand_with_preoptions":{"!":"method","declarations":["instance","public"],"path":"Argvector#subcommand_with_preoptions","name":"subcommand_with_preoptions","namespace":"Argvector","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"subcommand_with_preoptions()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def subcommand_with_preoptions\n  pre, args = *parse_preoptions(argv)\n  cmd = args.shift\n  subargs = self.class.new(args, @arity)\n  args, opts = *subargs.parameters\n  return [cmd, args, pre.merge(opts)]\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#subcommand_with_arguments":{"!":"method","declarations":["instance","public"],"path":"Argvector#subcommand_with_arguments","name":"subcommand_with_arguments","namespace":"Argvector","comment":"Assumes the first operand is a \"subcommand\" and\nreturns it and the argments following it as\nanother Arguments object.\n\nTODO: This probably should be called 'subcommand'.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"subcommand_with_arguments()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def subcommand_with_arguments\n  opts, args = *parse_preoptions(argv)\n  cmd = args.shift\n  subargs = self.class.new(args, @arity)\n  return cmd, subargs\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#preoptions":{"!":"method","declarations":["instance","public"],"path":"Argvector#preoptions","name":"preoptions","namespace":"Argvector","comment":"Returns a hash of options that occur before\nthe first operand. This works well with\nsubcommand to get the main command's options.\n\n  line = \"--trace stamp --file VERSION\"\n  cargs = Argvector.new(line)\n  opts = cargs.preoptions\n  opts #=> {\"trace\"=>true}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"preoptions()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def preoptions\n  preopts, remainder = *parse_preoptions(argv)\n  return preopts\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#preflags":{"!":"method","declarations":["instance","public"],"path":"Argvector#preflags","name":"preflags","namespace":"Argvector","comment":"Same as +flags+ but only returns flags in the\npreoptions.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"preflags()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def preflags\n  preopts, remainder = *parse_preoptions(argv)\n  f = []\n  preopts.each do |k, v|\n    if TrueClass===v or FalseClass===v  # not that it's ever false\n      f << k\n    end\n  end\n  return f\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#parameters_without_duplicates":{"!":"method","declarations":["instance","public"],"path":"Argvector#parameters_without_duplicates","name":"parameters_without_duplicates","namespace":"Argvector","comment":"Like parameters but without allowing for duplicate options.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"parameters_without_duplicates()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def parameters_without_duplicates\n  opts = {}\n  @options.each do |k,v|\n    if Array===v\n      opts[k] = v[0]\n    else\n      opts[k] =  v\n    end\n  end\n  return @operands, opts\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#parse":{"!":"method","declarations":["instance","public"],"path":"Argvector#parse","name":"parse","namespace":"Argvector","comment":"Basic parser partitions the command line into options and\noperands. Options are converted to a hash and the two \nparts are returned.\n\n  line = \"--trace stamp --file=VERSION\"\n  argv = Argvector.new(line)\n\n  args, keys = *argv.parse\n\n  args #=> [\"stamp\"]\n  keys #=> {\"trace\"=>true, \"file\"=>\"VERSION\"}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"parse()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def parse\n  args = assoc_options(argv) #, *opts_arity)\n\n  opts, opds = args.partition{ |a| Array === a }\n\n  @operands = opds\n  @options  = format_options(opts)\n\n  return @operands, @options\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#parse_line":{"!":"method","declarations":["instance","public"],"path":"Argvector#parse_line","name":"parse_line","namespace":"Argvector","comment":"First pass parser to split the command line into an\narray using Shellwords, if not already so divided.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"parse_line(line=nil)","arguments":[{"name":"line","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def parse_line(line=nil)\n  if line\n    case line\n    when String\n      argv = Shellwords.shellwords(line)\n    else\n      argv = line.to_ary.dup\n      line = argv.join(' ')\n    end\n  else\n    argv = ARGV.dup\n    line = argv.join(' ')\n  end\n  return line, argv\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#parse_arity":{"!":"method","declarations":["instance","public"],"path":"Argvector#parse_arity","name":"parse_arity","namespace":"Argvector","comment":"Ensure arity is uniform.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"parse_arity(arity)","arguments":[{"name":"arity"}]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def parse_arity(arity)\n  arity2 = {}\n  arity.each{ |k,v| arity2[k.to_s] = v.to_i }\n  return arity2\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#parse_preoptions":{"!":"method","declarations":["instance","public"],"path":"Argvector#parse_preoptions","name":"parse_preoptions","namespace":"Argvector","comment":"Parse preoptions. A \"preoption\" is one that\noccurs before the first operans (if any).","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"parse_preoptions(args)","arguments":[{"name":"args"}]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def parse_preoptions(args)\n  ##args = args.dup\n  args = multi_flag(args) #unless opts.include?(:simple)\n\n  flags = []\n  while args.first =~ /^-/\n    key = args.shift\n    key.sub!(/^-{1,2}/,'')\n    if key.index('=')\n      key, val = key.split('=')\n    elsif a = arity[key]\n      val = args.slice!(0,a)\n      val = val.first if a == 1\n    else\n      val = true\n    end\n    flags << [key, val]\n  end\n\n  flags = format_options(flags)\n\n  return flags, args\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#assoc_options":{"!":"method","declarations":["instance","public"],"path":"Argvector#assoc_options","name":"assoc_options","namespace":"Argvector","comment":"Parse flags takes the command line and transforms it such that\nflags (eg. -x and --x) are elemental associative arrays.\n\n  line = \"--foo hello --try=this\"\n  argv = Argvector.new(line)\n\n  args = line.split(/\\s/)\n  argv.assoc_options(args)  #=> [ [\"foo\",true], \"hello\", [\"try\",\"this\"] ]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"assoc_options(args)","arguments":[{"name":"args"}]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def assoc_options(args)\n  ##args = args.dup\n  args = multi_flag(args) #unless opts.include?(:simple)\n  i = 0\n  while i < args.size\n    arg = args[i]\n    case arg\n    when /^-/\n      arg = arg.sub(/^-{1,2}/,'')\n      if arg.index('=')\n        key, val = arg.split('=')\n        args[i] = [key, val||true]\n      elsif arity.key?(arg)\n        cnt = arity[arg]\n        key = arg\n        val = args[i+1,cnt]\n        args[i,cnt+1] = [[key, *val]]\n        i += (cnt - 1)\n      else\n        key = arg\n        args[i] = [key,true]\n      end\n    end\n    i += 1\n  end\n  return args\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#multi_flag":{"!":"method","declarations":["instance","public"],"path":"Argvector#multi_flag","name":"multi_flag","namespace":"Argvector","comment":"Split single letter option groupings into separate options.\nie. -xyz => -x -y -z","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"multi_flag(args=nil)","arguments":[{"name":"args","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def multi_flag(args=nil)\n  args ||= argv\n  args.collect { |arg|\n    if md = /^-(\\w{2,})/.match( arg )\n      md[1].split(//).collect { |c| \"-#{c}\" }\n    else\n      arg.dup\n    end\n  }.flatten\nend","language":"ruby","dynamic":null,"tags":{}},"Argvector#format_options":{"!":"method","declarations":["instance","public"],"path":"Argvector#format_options","name":"format_options","namespace":"Argvector","comment":"Format flag options. This converts the associative array of\noptions/flags into a hash. Repeat options will be placed in arrays.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"format_options(assoc_options)","arguments":[{"name":"assoc_options"}]}],"returns":[],"file":"/lib/standard/facets/argvector.rb","line":null,"source":"def format_options(assoc_options)\n  opts = {}\n  assoc_options.each do |k,v|\n    if opts.key?(k)\n      opts[k] = [opts[k]].flatten << v\n    else\n      opts[k] = v\n    end\n  end\n  return opts\nend","language":"ruby","dynamic":null,"tags":{}},"ArgVector":{"!":"constant","path":"ArgVector","name":"ArgVector","namespace":"","comment":"","format":"rdoc","value":"Argvector","tags":{},"files":["/lib/standard/facets/argvector.rb"]},"Cloneable":{"!":"module","path":"Cloneable","name":"Cloneable","namespace":"","comment":"Clonable provides a standard basis for adding deep cloneablity to a class\nvia the standard #dup and #clone methods.\n\nCloneable was originally ported from Jim Weirich's Rake.\nThe current version is the work of Ken Bloom.\n\nCREDIT: Ken Bloom","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Cloneable#initialize_copy"],"accessors":[],"files":["/lib/standard/facets/cloneable.rb"],"tags":{}},"Cloneable#initialize_copy":{"!":"method","declarations":["instance","public"],"path":"Cloneable#initialize_copy","name":"initialize_copy","namespace":"Cloneable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize_copy(sibling)","arguments":[{"name":"sibling"}]}],"returns":[],"file":"/lib/standard/facets/cloneable.rb","line":null,"source":"def initialize_copy(sibling)\n  #first duplicate my superclass' state. Note that if it's duplicating\n  #instance variables, this will be overwritten, but this is important\n  #because we could be dealing with a C extension with state hidden from\n  #the Ruby interpreter\n  super\n\n  #we want to know if we're being dup'ed or clone'd, because we want to\n  #preserve the state of our internals the same way our state is being\n  #preserved. (If we can't figure it out, we'll just use #dup.)\n  operation = (\n    copy_call  = caller.find{|x| x !~ /'initialize_copy'/}\n    copy_match = copy_call.match(/`(dup|clone)'/)\n    copy_match ? copy_match[1] : :dup\n  )\n\n  sibling.instance_variables.each do |ivar|\n    value = sibling.instance_variable_get(ivar)\n\n    #set my instance variable to be a #dup or #clone\n    #or my sibling, depending on what's happening to me right now\n    instance_variable_set(ivar, value.send(operation))\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Math.csch":{"!":"method","declarations":["class","public"],"path":"Math.csch","name":"csch","namespace":"Math","comment":"Cosecans hyperbolicus of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"csch(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/csch.rb","line":null,"source":"def self.csch(x)\n  1.0 / sinh(x)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.mean":{"!":"method","declarations":["class","public"],"path":"Math.mean","name":"mean","namespace":"Math","comment":"Mean average.","format":"rdoc","aliases":["Math.mean_average"],"singleton":null,"interfaces":[{"signature":"mean(.)","arguments":[{"name":"array"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/standard/facets/math/mean.rb","line":null,"source":"def self.mean(array, &blk)\n  s = array.size\n  return 0.0 if s == 0\n  sum(array, &blk) / s\nend","language":"ruby","dynamic":null,"tags":{}},"Math.mean_average":{"!":"method","declarations":["class","public"],"path":"Math.mean_average","name":"mean_average","namespace":"Math","comment":"Mean average.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mean(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/math/mean.rb","line":null,"source":"def self.mean(array, &blk)\n  s = array.size\n  return 0.0 if s == 0\n  sum(array, &blk) / s\nend","language":"ruby","dynamic":null,"tags":{}},"Equitable":{"!":"module","path":"Equitable","name":"Equitable","namespace":"","comment":"= Equitable\n\nThis mixin provides methods of equality based\non a single #identity method which must return\na list of accessors used as the identity keys.\n\nIt also provides a \"shortcut\" for creating the\n#identity method based on given accessors and returns\nthe Equitable module for inclusion.\n\n  include Equitable(:a, :b)\n\nis equivalent to including a module containing:\n\n  def ==(other)\n    self.a == other.a && self.b == other.b\n  end\n\n  def eql?(other)\n    self.a.eql?(other.a) && self.b.eql?(other.b)\n  end\n\n  def hash()\n    self.a.hash ^ self.b.hash\n  end","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Equitable.identify","Equitable#==","Equitable#eql?","Equitable#hash"],"accessors":[],"files":["/lib/standard/facets/equitable.rb"],"tags":{}},"Equitable.identify":{"!":"method","declarations":["class","public"],"path":"Equitable.identify","name":"identify","namespace":"Equitable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"identify(.)","arguments":[{"name":"base"},{"name":"*accessors"}]}],"returns":[],"file":"/lib/standard/facets/equitable.rb","line":null,"source":"def self.identify(base, *accessors)\n  base.send(:define_method, :identity){ accessors }\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Equitable#==":{"!":"method","declarations":["instance","public"],"path":"Equitable#==","name":"==","namespace":"Equitable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"==(o)","arguments":[{"name":"o"}]}],"returns":[],"file":"/lib/standard/facets/equitable.rb","line":null,"source":"def ==(o)\n  identity.all?{ |a| send(a) == o.send(a) }\nend","language":"ruby","dynamic":null,"tags":{}},"Equitable#eql?":{"!":"method","declarations":["instance","public"],"path":"Equitable#eql?","name":"eql?","namespace":"Equitable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"eql?(o)","arguments":[{"name":"o"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/equitable.rb","line":null,"source":"def eql?(o)\n  identity.all?{ |a| send(a).eql?(o.send(a)) }\nend","language":"ruby","dynamic":null,"tags":{}},"Equitable#hash":{"!":"method","declarations":["instance","public"],"path":"Equitable#hash","name":"hash","namespace":"Equitable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"hash()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/equitable.rb","line":null,"source":"def hash\n  identity.inject(0){ |memo, a| memo ^ send(a).hash }\nend","language":"ruby","dynamic":null,"tags":{}},"Module":{"!":"class","superclass":"Object","path":"Module","name":"Module","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Module#Equitable"],"accessors":[],"files":["/lib/standard/facets/equitable.rb"],"tags":{}},"Module#Equitable":{"!":"method","declarations":["instance","public"],"path":"Module#Equitable","name":"Equitable","namespace":"Module","comment":"This function provided a \"shortcut\" for creating the\n#identity method based on given accessors and returns\nthe Equitable module for inclusion.\n\n include Equitable(:a, :b)\n\nis equivalent to including a module containing:\n\n  def ==(other)\n    self.a == other.a && self.b == other.b\n  end\n\n  def eql?(other)\n    self.a.eql?(other.a) && self.b.eql?(other.b)\n  end\n\n  def hash()\n    self.a.hash ^ self.b.hash\n  end","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"Equitable(*accessors)","arguments":[{"name":"*accessors"}]}],"returns":[],"file":"/lib/standard/facets/equitable.rb","line":null,"source":"def Equitable(*accessors)\n  Equitable.identify(self, *accessors)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.acot":{"!":"method","declarations":["class","public"],"path":"Math.acot","name":"acot","namespace":"Math","comment":"Arcus cotangens of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"acot(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/acot.rb","line":null,"source":"def self.acot(x)\n  (PI * 0.5) - atan(x)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.beta":{"!":"method","declarations":["class","public"],"path":"Math.beta","name":"beta","namespace":"Math","comment":"Beta function of +x+ and +y+ - <code>beta(+x+, +y+) =\ntgamma(+x+) * tgamma(+y+) / tgamma(+x+ + +y+)</code>","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"beta(.)","arguments":[{"name":"x"},{"name":"y"}]}],"returns":[],"file":"/lib/standard/facets/math/beta.rb","line":null,"source":"def self.beta(x, y)\n  exp(lgamma(x) + lgamma(y) - lgamma(x+y))\nend","language":"ruby","dynamic":null,"tags":{}},"Math.sinc":{"!":"method","declarations":["class","public"],"path":"Math.sinc","name":"sinc","namespace":"Math","comment":"Sinc function of +x+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sinc(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/sinc.rb","line":null,"source":"def self.sinc(x)\n  (x == 0.0) ? 1.0 : sin(x) / x\nend","language":"ruby","dynamic":null,"tags":{}},"Math.root":{"!":"method","declarations":["class","public"],"path":"Math.root","name":"root","namespace":"Math","comment":"The +y+ root of +x+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"root(.)","arguments":[{"name":"x"},{"name":"y"}]}],"returns":[],"file":"/lib/standard/facets/math/root.rb","line":null,"source":"def self.root(x, y)\n  x ** (1.0 / y)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.sech":{"!":"method","declarations":["class","public"],"path":"Math.sech","name":"sech","namespace":"Math","comment":"Secans hyperbolicus of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sech(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/sech.rb","line":null,"source":"def self.sech(x)\n  1.0 / cosh(x)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.coth":{"!":"method","declarations":["class","public"],"path":"Math.coth","name":"coth","namespace":"Math","comment":"Cotangens hyperbolicus of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"coth(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/coth.rb","line":null,"source":"def self.coth(x)\n  1.0 / tanh(x)\nend","language":"ruby","dynamic":null,"tags":{}},"NullClass":{"!":"class","superclass":"Object","path":"NullClass","name":"NullClass","namespace":"","comment":"= Nullclass\n\nNullClass is essentially NilClass but it differs in one\nimportant way. When a method is called against it that it\ndeoesn't have, it will simply return null value rather then\nraise an error.\n\nTODO: Perhaps NullClass should be called NackClass?","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["NullClass.new","NullClass#inspect","NullClass#nil?","NullClass#null?","NullClass#[]","NullClass#method_missing"],"accessors":[],"files":["/lib/standard/facets/nullclass.rb"],"tags":{}},"NullClass.new":{"!":"method","declarations":["class","public"],"path":"NullClass.new","name":"new","namespace":"NullClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"new()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/nullclass.rb","line":null,"source":"def new\n  @null ||= NullClass.allocate\nend","language":"ruby","dynamic":null,"tags":{}},"NullClass#inspect":{"!":"method","declarations":["instance","public"],"path":"NullClass#inspect","name":"inspect","namespace":"NullClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/nullclass.rb","line":null,"source":"def inspect ; 'null' ; end","language":"ruby","dynamic":null,"tags":{}},"NullClass#nil?":{"!":"method","declarations":["instance","public"],"path":"NullClass#nil?","name":"nil?","namespace":"NullClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"nil?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/nullclass.rb","line":null,"source":"def nil?  ; true ; end","language":"ruby","dynamic":null,"tags":{}},"NullClass#null?":{"!":"method","declarations":["instance","public"],"path":"NullClass#null?","name":"null?","namespace":"NullClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"null?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/nullclass.rb","line":null,"source":"def null? ; true ; end","language":"ruby","dynamic":null,"tags":{}},"NullClass#[]":{"!":"method","declarations":["instance","public"],"path":"NullClass#[]","name":"[]","namespace":"NullClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](key)","arguments":[{"name":"key"}]}],"returns":[],"file":"/lib/standard/facets/nullclass.rb","line":null,"source":"def [](key); nil; end","language":"ruby","dynamic":null,"tags":{}},"NullClass#method_missing":{"!":"method","declarations":["instance","public"],"path":"NullClass#method_missing","name":"method_missing","namespace":"NullClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(sym, *args)","arguments":[{"name":"sym"},{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/nullclass.rb","line":null,"source":"def method_missing(sym, *args)\n  return nil if sym.to_s[-1,1] == '?'\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#null":{"!":"method","declarations":["instance","public"],"path":"Kernel#null","name":"null","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"null()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/nullclass.rb","line":null,"source":"def null\n  NullClass.new\nend","language":"ruby","dynamic":null,"tags":{}},"Object#null?":{"!":"method","declarations":["instance","public"],"path":"Object#null?","name":"null?","namespace":"Object","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"null?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/nullclass.rb","line":null,"source":"def null?\n  false\nend","language":"ruby","dynamic":null,"tags":{}},"Math.log2":{"!":"method","declarations":["class","public"],"path":"Math.log2","name":"log2","namespace":"Math","comment":"Logarithmus dualis of +x+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"log2(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/log2.rb","line":null,"source":"def self.log2(x)\n  Math.log(x) * INVERSE_LN_2\nend","language":"ruby","dynamic":null,"tags":{}},"Math.acsc":{"!":"method","declarations":["class","public"],"path":"Math.acsc","name":"acsc","namespace":"Math","comment":"Arcus cosecans of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"acsc(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/acsc.rb","line":null,"source":"def self.acsc(x)\n  asin(1.0 / x)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.exp2":{"!":"method","declarations":["class","public"],"path":"Math.exp2","name":"exp2","namespace":"Math","comment":"2 to the power +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"exp2(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/exp2.rb","line":null,"source":"def self.exp2(x)\n  2.0 ** x\nend","language":"ruby","dynamic":null,"tags":{}},"Math.sign":{"!":"method","declarations":["class","public"],"path":"Math.sign","name":"sign","namespace":"Math","comment":"Sign of +x+.\nReturns -1 for negative x, +1 for positive x and zero for x = 0","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sign(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/sign.rb","line":null,"source":"def self.sign(x)\n  (x > 0.0) ? 1.0 : ((x < 0.0) ? -1.0 : 0.0)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.ceil":{"!":"method","declarations":["class","public"],"path":"Math.ceil","name":"ceil","namespace":"Math","comment":"Smallest integer not smaller than +x+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ceil(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/ceil.rb","line":null,"source":"def self.ceil(x)\n  x.ceil\nend","language":"ruby","dynamic":null,"tags":{}},"Math.asec":{"!":"method","declarations":["class","public"],"path":"Math.asec","name":"asec","namespace":"Math","comment":"Arcus secans of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"asec(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/asec.rb","line":null,"source":"def self.asec(x)\n  acos(1.0 / x)\nend","language":"ruby","dynamic":null,"tags":{}},"Math#acsch":{"!":"method","declarations":["instance","public"],"path":"Math#acsch","name":"acsch","namespace":"Math","comment":"Area cosecans hyperbolicus of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"acsch(x)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/acsch.rb","line":null,"source":"def acsch(x)\n  ::Math.log(1.0 / x + Math.sqrt(1.0 + 1.0 / (x * x)))\nend","language":"ruby","dynamic":null,"tags":{}},"Math.floor":{"!":"method","declarations":["class","public"],"path":"Math.floor","name":"floor","namespace":"Math","comment":"Largest integer not larger than +x+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"floor(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/floor.rb","line":null,"source":"def self.floor(x)\n  x.floor\nend","language":"ruby","dynamic":null,"tags":{}},"Math.delta":{"!":"method","declarations":["class","public"],"path":"Math.delta","name":"delta","namespace":"Math","comment":"Kronecker symbol of +i+ and +j+.\nReturns 1 if +i+ and +j+ are equal, 0 otherwise.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"delta(.)","arguments":[{"name":"i"},{"name":"j"}]}],"returns":[],"file":"/lib/standard/facets/math/delta.rb","line":null,"source":"def self.delta(i, j)\n  return Integer(i) == Integer(j) ? 1 : 0\nend","language":"ruby","dynamic":null,"tags":{}},"GetoptLong":{"!":"class","superclass":"Object","path":"GetoptLong","name":"GetoptLong","namespace":"","comment":"= GetoptLong\n\nRuby's standard GetoptLong class with an added DSL.\n\n  opts = GetoptLong.new do\n    reqs '--expect', '-x'\n    flag '--help', '-h'\n  end\n\nSee GetoptLong::DSL for details.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["GetoptLong::DSL"],"methods":["GetoptLong#init","GetoptLong#initialize"],"accessors":[],"files":["/lib/standard/facets/getoptlong.rb"],"tags":{}},"GetoptLong#init":{"!":"method","declarations":["instance","public"],"path":"GetoptLong#init","name":"init","namespace":"GetoptLong","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"init","arguments":[]}],"returns":[],"file":"/lib/standard/facets/getoptlong.rb","line":null,"source":"alias :init :initialize","language":"ruby","dynamic":null,"tags":{}},"GetoptLong#initialize":{"!":"method","declarations":["instance","public"],"path":"GetoptLong#initialize","name":"initialize","namespace":"GetoptLong","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(*arguments, &block)","arguments":[{"name":"*arguments"}],"block":{"name":"&block"}}],"returns":[{"type":"GetoptLong","comment":"a new instance of GetoptLong"}],"file":"/lib/standard/facets/getoptlong.rb","line":null,"source":"def initialize(*arguments, &block)\n  if block_given?\n    raise ArgumentError unless arguments.empty?\n    arguments = DSL.new(&block).arguments\n  end\n  init(*arguments)\nend","language":"ruby","dynamic":null,"tags":{}},"GetoptLong::DSL":{"!":"class","superclass":"Object","path":"GetoptLong::DSL","name":"DSL","namespace":"GetoptLong","comment":"DSL-mode parser.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["GetoptLong::DSL#arguments","GetoptLong::DSL#initialize","GetoptLong::DSL#flag","GetoptLong::DSL#required","GetoptLong::DSL#reqs","GetoptLong::DSL#optional","GetoptLong::DSL#opts"],"accessors":["GetoptLong::DSL#arguments"],"files":["/lib/standard/facets/getoptlong.rb"],"tags":{}},"GetoptLong::DSL#arguments":{"!":"method","declarations":["instance","public"],"path":"GetoptLong::DSL#arguments","name":"arguments","namespace":"GetoptLong::DSL","comment":"Returns the value of attribute arguments","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"arguments","arguments":[]}],"returns":[],"file":"/lib/standard/facets/getoptlong.rb","line":null,"source":"def arguments\n  @arguments\nend","language":"ruby","dynamic":null,"tags":{}},"GetoptLong::DSL#initialize":{"!":"method","declarations":["instance","public"],"path":"GetoptLong::DSL#initialize","name":"initialize","namespace":"GetoptLong::DSL","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[{"type":"DSL","comment":"a new instance of DSL"}],"file":"/lib/standard/facets/getoptlong.rb","line":null,"source":"def initialize(&block)\n  @arguments = []\n  instance_eval(&block)\nend","language":"ruby","dynamic":null,"tags":{}},"GetoptLong::DSL#flag":{"!":"method","declarations":["instance","public"],"path":"GetoptLong::DSL#flag","name":"flag","namespace":"GetoptLong::DSL","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"flag(*opts)","arguments":[{"name":"*opts"}]}],"returns":[],"file":"/lib/standard/facets/getoptlong.rb","line":null,"source":"def flag(*opts)\n  @arguments << (opts << GetoptLong::NO_ARGUMENT)\nend","language":"ruby","dynamic":null,"tags":{}},"GetoptLong::DSL#required":{"!":"method","declarations":["instance","public"],"path":"GetoptLong::DSL#required","name":"required","namespace":"GetoptLong::DSL","comment":"","format":"rdoc","aliases":["GetoptLong::DSL#reqs"],"singleton":null,"interfaces":[{"signature":"required(*opts)","arguments":[{"name":"*opts"}]}],"returns":[],"file":"/lib/standard/facets/getoptlong.rb","line":null,"source":"def required(*opts)\n  @arguments << (opts <<  GetoptLong::REQUIRED_ARGUMENT)\nend","language":"ruby","dynamic":null,"tags":{}},"GetoptLong::DSL#reqs":{"!":"method","declarations":["instance","public"],"path":"GetoptLong::DSL#reqs","name":"reqs","namespace":"GetoptLong::DSL","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"required(*opts)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/getoptlong.rb","line":null,"source":"def required(*opts)\n  @arguments << (opts <<  GetoptLong::REQUIRED_ARGUMENT)\nend","language":"ruby","dynamic":null,"tags":{}},"GetoptLong::DSL#optional":{"!":"method","declarations":["instance","public"],"path":"GetoptLong::DSL#optional","name":"optional","namespace":"GetoptLong::DSL","comment":"","format":"rdoc","aliases":["GetoptLong::DSL#opts"],"singleton":null,"interfaces":[{"signature":"optional(*opts)","arguments":[{"name":"*opts"}]}],"returns":[],"file":"/lib/standard/facets/getoptlong.rb","line":null,"source":"def optional(*opts)\n  @arguments << (opts << GetoptLong::OPTIONAL_ARGUMENT)\nend","language":"ruby","dynamic":null,"tags":{}},"GetoptLong::DSL#opts":{"!":"method","declarations":["instance","public"],"path":"GetoptLong::DSL#opts","name":"opts","namespace":"GetoptLong::DSL","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"optional(*opts)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/getoptlong.rb","line":null,"source":"def optional(*opts)\n  @arguments << (opts << GetoptLong::OPTIONAL_ARGUMENT)\nend","language":"ruby","dynamic":null,"tags":{}},"Memoizable":{"!":"module","path":"Memoizable","name":"Memoizable","namespace":"","comment":"Memoization is an optimization technique used primarily to speed up \nprograms by having function calls avoid repeating the calculation\nof results for previously-processed inputs.\n\nWhen you \"memoize\" a method/function using Memoizable its results are cached\nso that later calls return results from the cache instead of recalculating\nthem.\n\n  class T\n    include Memoizable\n\n    def initialize(a)\n      @a = a\n    end\n\n    def a\n      \"#{@a ^ 3 + 4}\"\n    end\n\n    memoize :a\n  end\n\n  t = T.new(10)\n  (t.a.__id__ == t.a.__id__)  #=> true\n\nThis method can also be used at the instance level to cache singleton\n(qua class) methods by including it in the singleton class.\n\n--\nTODO: It would be very cool if Memoizable could set-up default parameters\nvia #[] method, e.g. `include Memoizable[:freeze=>true]`.\n++","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":["Memoizable::Copy"],"classes":[],"methods":["Memoizable.cache","Memoizable.append_features","Memoizable#memoize","Memoizable#rememoize","Memoizable#unmemoize"],"accessors":[],"files":["/lib/standard/facets/memoizable.rb"],"tags":{}},"Memoizable.cache":{"!":"method","declarations":["class","public"],"path":"Memoizable.cache","name":"cache","namespace":"Memoizable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cache(.)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/memoizable.rb","line":null,"source":"def self.cache\n  @cache\nend","language":"ruby","dynamic":null,"tags":{}},"Memoizable.append_features":{"!":"method","declarations":["class","public"],"path":"Memoizable.append_features","name":"append_features","namespace":"Memoizable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"append_features(.)","arguments":[{"name":"base"}]}],"returns":[],"file":"/lib/standard/facets/memoizable.rb","line":null,"source":"def self.append_features(base)\n  Module == base ? super(base) : base.extend(self)\nend","language":"ruby","dynamic":null,"tags":{}},"Memoizable#memoize":{"!":"method","declarations":["instance","public"],"path":"Memoizable#memoize","name":"memoize","namespace":"Memoizable","comment":"Directive for making your functions faster by trading space for time.\nWhen you \"memoize\" a method/function using #memoize its results are\ncached so that later calls with the same arguments return results from\nthe cache instead of recalculating them.\n\nThe #memoize method also handles a few options to alter\nbehavior of the memoization:\n\n  :class     => true      cache per-class not per-object\n  :freeze    => true      freeze the memoized return values\n  :arguments => false     do not index cache by arguments","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"memoize(*method_names)","arguments":[{"name":"*method_names"}]}],"returns":[],"file":"/lib/standard/facets/memoizable.rb","line":null,"source":"def memoize(*method_names)\n  options = Hash === method_names.last ? method_names.pop : {}\n\n  options[:arguments] = true if options[:arguments].nil?  # default to true\n\n  ref = options[:class]     ? 'self.class.name'       : 'self'\n  frz = options[:freeze]    ? '.freeze'               : ''\n  arg = options[:arguments] ? '[__a__, block_given?]' : 'nil'\n\n  code = \"\"\n  method_names.each do |m|\n    code << <<-code\n      alias_method '#{ m }:memo', '#{ m }'\n      private '#{ m }:memo'\n      def #{ m }(*__a__,&__b__)\n        c = Memoizable.cache[#{ref}][:'#{ m }']\n        k = #{arg}\n        if c.has_key?(k)\n          c[k]\n        else\n          c[k] = __send__('#{ m }:memo',*__a__,&__b__)#{frz}\n        end\n      end\n    code\n  end\n  module_eval(code)\nend","language":"ruby","dynamic":null,"tags":{}},"Memoizable#rememoize":{"!":"method","declarations":["instance","public"],"path":"Memoizable#rememoize","name":"rememoize","namespace":"Memoizable","comment":"Remove the memoized value from the memoization cache.\nThe next time a memoized methos is called if will be\nremomoized.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rememoize(*method_names)","arguments":[{"name":"*method_names"}]}],"returns":[],"file":"/lib/standard/facets/memoizable.rb","line":null,"source":"def rememoize(*method_names)\n  if Memoizable.cache[self]\n    if method_names.empty?\n      Memoizable.cache.delete(self)\n    else\n      method_names.each do |m|\n        Memoizable.cache[self].delete(m.to_sym)\n      end\n    end\n  end\n  if Memoizable.cache[self.class.name]\n    if method_names.empty?\n      Memoizable.cache.delete(self.class.name)\n    else\n      method_names.each do |m|\n        Memoizable.cache[self.class.name].delete(m.to_sym)\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Memoizable#unmemoize":{"!":"method","declarations":["instance","public"],"path":"Memoizable#unmemoize","name":"unmemoize","namespace":"Memoizable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unmemoize(*method_names)","arguments":[{"name":"*method_names"}]}],"returns":[],"file":"/lib/standard/facets/memoizable.rb","line":null,"source":"def unmemoize(*method_names)\n  rememoize(*method_names)\n  method_names.each do |m|\n    alias_method name, \"#{ m }:memo\"\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Memoizable::Copy":{"!":"module","path":"Memoizable::Copy","name":"Copy","namespace":"Memoizable","comment":"Include Memoizable alone with an #initialize_copy method that\nwill copy the memoization cache when #dup or #clone is used.\n\nTODO: Is this best approach? Perhaps a method to easily create\nthe #initialize_copy method would suffice?","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Memoizable::Copy.included","Memoizable::Copy#initialize_copy"],"accessors":[],"files":["/lib/standard/facets/memoizable.rb"],"tags":{}},"Memoizable::Copy.included":{"!":"method","declarations":["class","public"],"path":"Memoizable::Copy.included","name":"included","namespace":"Memoizable::Copy","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"included(.)","arguments":[{"name":"base"}]}],"returns":[],"file":"/lib/standard/facets/memoizable.rb","line":null,"source":"def self.included(base)\n  base.extend(Memoizable)\nend","language":"ruby","dynamic":null,"tags":{"private":null}},"Memoizable::Copy#initialize_copy":{"!":"method","declarations":["instance","public"],"path":"Memoizable::Copy#initialize_copy","name":"initialize_copy","namespace":"Memoizable::Copy","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize_copy(original)","arguments":[{"name":"original"}]}],"returns":[],"file":"/lib/standard/facets/memoizable.rb","line":null,"source":"def initialize_copy(original)\n  if Memoizable.cache.key?(original)\n    Memoizable.cache[self] = Memoizable.cache[original].dup\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Math.round":{"!":"method","declarations":["class","public"],"path":"Math.round","name":"round","namespace":"Math","comment":"Round number to an integer.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"round(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/round.rb","line":null,"source":"def self.round(x)\n  x.round\nend","language":"ruby","dynamic":null,"tags":{}},"Math.exp10":{"!":"method","declarations":["class","public"],"path":"Math.exp10","name":"exp10","namespace":"Math","comment":"10 to the power +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"exp10(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/exp10.rb","line":null,"source":"def self.exp10(x)\n  10.0 ** x\nend","language":"ruby","dynamic":null,"tags":{}},"Math#asech":{"!":"method","declarations":["instance","public"],"path":"Math#asech","name":"asech","namespace":"Math","comment":"Area secans hyperbolicus of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"asech(x)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/asech.rb","line":null,"source":"def asech(x)\n  log((1.0 + sqrt(1.0 - x * x)) / x)\nend","language":"ruby","dynamic":null,"tags":{}},"Shellwords":{"!":"module","path":"Shellwords","name":"Shellwords","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Shellwords#alt_escape","Shellwords#escape","Shellwords#dos_escape","Shellwords#run"],"accessors":[],"files":["/lib/standard/facets/shellwords.rb"],"tags":{}},"Shellwords#alt_escape":{"!":"method","declarations":["instance","public"],"path":"Shellwords#alt_escape","name":"alt_escape","namespace":"Shellwords","comment":"Escape special characters used in most unix shells\nto use it, eg. with system().\n\nThis differs from Ruby's #escape in that it does not\nescape shell variables, e.g. $0.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alt_escape(cmdline)","arguments":[{"name":"cmdline"}]}],"returns":[],"file":"/lib/standard/facets/shellwords.rb","line":null,"source":"def alt_escape(cmdline)\n  cmdline.gsub(/([\\\\\\t\\| &`<>)('\"])/) { |s| '\\\\' << s }\nend","language":"ruby","dynamic":null,"tags":{}},"Shellwords#escape":{"!":"method","declarations":["instance","public"],"path":"Shellwords#escape","name":"escape","namespace":"Shellwords","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"escape(cmdline)","arguments":[{"name":"cmdline"}]}],"returns":[],"file":"/lib/standard/facets/shellwords.rb","line":null,"source":"def escape(cmdline)\n  cmdline.gsub(/([\\\\\\t\\| &`<>)('\"])/) { |s| '\\\\' << s }\nend","language":"ruby","dynamic":null,"tags":{}},"Shellwords#dos_escape":{"!":"method","declarations":["instance","public"],"path":"Shellwords#dos_escape","name":"dos_escape","namespace":"Shellwords","comment":"Escape special character used in DOS-based shells.\n\nTODO: How to integrate with rest of system?\n1. Use platform condition?\n2. Use separate dos_xxx methods?\n3. Put in separate PowerShellwords module?\n\nCREDIT: Lavir the Whiolet","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dos_escape(cmdline)","arguments":[{"name":"cmdline"}]}],"returns":[],"file":"/lib/standard/facets/shellwords.rb","line":null,"source":"def dos_escape(cmdline)\n  '\"' + cmdline.gsub(/\\\\(?=\\\\*\\\")/, \"\\\\\\\\\\\\\").gsub(/\\\"/, \"\\\\\\\"\").gsub(/\\\\$/, \"\\\\\\\\\\\\\").gsub(\"%\", \"%%\") + '\"'\nend","language":"ruby","dynamic":null,"tags":{}},"Shellwords#run":{"!":"method","declarations":["instance","public"],"path":"Shellwords#run","name":"run","namespace":"Shellwords","comment":"The coolest little arguments parser in all of Rubyland.\n\nCREDIT: Michel Martens","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"run(argv, opts)","arguments":[{"name":"argv"},{"name":"opts"}]}],"returns":[],"file":"/lib/standard/facets/shellwords.rb","line":null,"source":"def run(argv, opts)\n  argv = (String === argv ? shellwords(argv) : argv.to_a.dup)\n  args = []\n  while argv.any?\n    item = argv.shift\n    flag = opts[item]\n    if flag\n      # Work around lambda semantics in 1.8.7.\n      arity = [flag.arity, 0].max\n      # Raise if there are not enough parameters\n      # available for the flag.\n      if argv.size < arity\n        raise ArgumentError\n      end\n      # Call the lambda with N items from argv,\n      # where N is the lambda's arity.\n      flag.call(*argv.shift(arity))\n    else\n      # Collect the items that don't correspond to\n      # flags.\n      args << item\n    end\n  end\n  args\nend","language":"ruby","dynamic":null,"tags":{}},"Array#shellwords":{"!":"method","declarations":["instance","public"],"path":"Array#shellwords","name":"shellwords","namespace":"Array","comment":"Convert an array into command line parameters.\nThe array is accepted in the format of Ruby\nmethod arguments --ie. [arg1, arg2, ..., hash]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shellwords()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/shellwords.rb","line":null,"source":"def shellwords\n  opts, args = *flatten.partition{ |e| Hash === e }\n  opts = opts.inject({}){ |m,h| m.update(h); m }\n  opts.shellwords + args\nend","language":"ruby","dynamic":null,"tags":{}},"Array#shelljoin":{"!":"method","declarations":["instance","public"],"path":"Array#shelljoin","name":"shelljoin","namespace":"Array","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shelljoin()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/shellwords.rb","line":null,"source":"def shelljoin\n  Shellwords.shelljoin(shellwords)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#shellwords":{"!":"method","declarations":["instance","public"],"path":"Hash#shellwords","name":"shellwords","namespace":"Hash","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shellwords()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/shellwords.rb","line":null,"source":"def shellwords\n  argv = []\n  each do |f,v|\n    m = f.to_s.size == 1 ? '-' : '--'\n    case v\n    when false, nil\n    when Array\n      v.each do |e|\n        argv << %[#{m}#{f}=\"#{e}\"]\n      end\n    when true\n      argv << %[#{m}#{f}]\n    else\n      argv << %[#{m}#{f}=\"#{v}\"]\n    end\n  end\n  argv\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#shelljoin":{"!":"method","declarations":["instance","public"],"path":"Hash#shelljoin","name":"shelljoin","namespace":"Hash","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shelljoin()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/shellwords.rb","line":null,"source":"def shelljoin\n  shellwords.shelljoin\nend","language":"ruby","dynamic":null,"tags":{}},"Math.acoth":{"!":"method","declarations":["class","public"],"path":"Math.acoth","name":"acoth","namespace":"Math","comment":"Area cotangens hyperbolicus of +x+","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"acoth(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/acoth.rb","line":null,"source":"def self.acoth(x)\n  0.5 * log((x + 1.0) / (x - 1.0))\nend","language":"ruby","dynamic":null,"tags":{}},"Math.gamma":{"!":"method","declarations":["class","public"],"path":"Math.gamma","name":"gamma","namespace":"Math","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"gamma(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/gamma.rb","line":null,"source":"def self.gamma(x)\n  exp(lgamma(x))\nend","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers":{"!":"module","path":"Numeric::Multipliers","name":"Multipliers","namespace":"Numeric","comment":"= Numeric::Multipliers\n\nAdds methods to Numeric to make working with\nmagnitudes (kilo, mega, giga, milli, micro, etc.)\n\n  1.kilo               #=> 1000\n  1.milli              #=> 0.001\n  1.kibi               #=> 1024\n\nTo display a value in a certain denomination, simply\nperform the inverse operation by placing the\nmultiplier called on unit (1) in the denominator.\n\n  (1000 / 1.kilo)        #=> 1\n  (1024 / 1.kibi)        #=> 1\n\nThanks to Rich Kilmer and bytes.rb which inspired this library.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Numeric::Multipliers#deka","Numeric::Multipliers#hecto","Numeric::Multipliers#kilo","Numeric::Multipliers#mega","Numeric::Multipliers#giga","Numeric::Multipliers#tera","Numeric::Multipliers#peta","Numeric::Multipliers#exa","Numeric::Multipliers#deci","Numeric::Multipliers#centi","Numeric::Multipliers#milli","Numeric::Multipliers#micro","Numeric::Multipliers#nano","Numeric::Multipliers#pico","Numeric::Multipliers#femto","Numeric::Multipliers#atto","Numeric::Multipliers#kibi","Numeric::Multipliers#mebi","Numeric::Multipliers#gibi","Numeric::Multipliers#tebi","Numeric::Multipliers#pebi","Numeric::Multipliers#exbi"],"accessors":[],"files":["/lib/standard/facets/multipliers.rb"],"tags":{}},"Numeric::Multipliers#deka":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#deka","name":"deka","namespace":"Numeric::Multipliers","comment":"SI Multipliers","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"deka()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def deka  ; self * 10 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#hecto":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#hecto","name":"hecto","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"hecto()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def hecto ; self * 100 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#kilo":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#kilo","name":"kilo","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"kilo()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def kilo  ; self * 1000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#mega":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#mega","name":"mega","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mega()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def mega  ; self * 1000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#giga":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#giga","name":"giga","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"giga()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def giga  ; self * 1000000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#tera":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#tera","name":"tera","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tera()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def tera  ; self * 1000000000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#peta":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#peta","name":"peta","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"peta()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def peta  ; self * 1000000000000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#exa":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#exa","name":"exa","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"exa()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def exa   ; self * 1000000000000000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#deci":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#deci","name":"deci","namespace":"Numeric::Multipliers","comment":"SI Fractional","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"deci()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def deci  ; self.to_f / 10 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#centi":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#centi","name":"centi","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"centi()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def centi ; self.to_f / 100 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#milli":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#milli","name":"milli","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"milli()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def milli ; self.to_f / 1000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#micro":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#micro","name":"micro","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"micro()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def micro ; self.to_f / 1000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#nano":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#nano","name":"nano","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"nano()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def nano  ; self.to_f / 1000000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#pico":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#pico","name":"pico","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pico()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def pico  ; self.to_f / 1000000000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#femto":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#femto","name":"femto","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"femto()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def femto ; self.to_f / 1000000000000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#atto":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#atto","name":"atto","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"atto()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def atto  ; self.to_f / 1000000000000000000 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#kibi":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#kibi","name":"kibi","namespace":"Numeric::Multipliers","comment":"SI Binary","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"kibi()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def kibi ; self * 1024 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#mebi":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#mebi","name":"mebi","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mebi()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def mebi ; self * 1024**2 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#gibi":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#gibi","name":"gibi","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"gibi()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def gibi ; self * 1024**3 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#tebi":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#tebi","name":"tebi","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tebi()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def tebi ; self * 1024**4 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#pebi":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#pebi","name":"pebi","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pebi()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def pebi ; self * 1024**5 ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric::Multipliers#exbi":{"!":"method","declarations":["instance","public"],"path":"Numeric::Multipliers#exbi","name":"exbi","namespace":"Numeric::Multipliers","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"exbi()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/multipliers.rb","line":null,"source":"def exbi ; self * 1024**6 ; end","language":"ruby","dynamic":null,"tags":{}},"Math.median":{"!":"method","declarations":["class","public"],"path":"Math.median","name":"median","namespace":"Math","comment":"Returns the numerical median for the an array of values;\nor nil if array is empty.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"median(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/median.rb","line":null,"source":"def self.median(array)\n  percentile(array, 50)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.lgamma":{"!":"method","declarations":["class","public"],"path":"Math.lgamma","name":"lgamma","namespace":"Math","comment":"Logarithmus naturalis of gamma function of +x+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"lgamma(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/lgamma.rb","line":null,"source":"def self.lgamma(x)\n  h  = x + 5.5\n  h -= (x + 0.5) * log(h)\n  sum  =  1.000_000_000_190_015\n  sum += 76.180_091_729_471_46\t     / (x + 1.0)\n  sum -= 86.505_320_329_416_77\t     / (x + 2.0)\n  sum += 24.014_098_240_830_91\t     / (x + 3.0)\n  sum -=  1.231_739_572_450_155\t     / (x + 4.0)\n  sum +=  0.120_865_097_386_617_9e-2 / (x + 5.0)\n  sum -=  0.539_523_938_495_3e-5     / (x + 6.0)\n  -h + log(2.506_628_274_631_000_5 * sum / x)\nend","language":"ruby","dynamic":null,"tags":{"author":"Josef Schugt"}},"Math.tgamma":{"!":"method","declarations":["class","public"],"path":"Math.tgamma","name":"tgamma","namespace":"Math","comment":"Exp of LGamma.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tgamma(.)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/standard/facets/math/tgamma.rb","line":null,"source":"def self.tgamma(x)\n  exp(lgamma(x))\nend","language":"ruby","dynamic":null,"tags":{}},"Math.sqsolve":{"!":"method","declarations":["class","public"],"path":"Math.sqsolve","name":"sqsolve","namespace":"Math","comment":"Returns array of real solution of <code>ax**2 + bx + c = d</code>\nor <code>nil</code> if no or an infinite number of solutions exist.\nIf +d+ is missing it is assumed to be 0.\n\nIn order to solve <code>ax**2 + bx + c = d</code> +sqsolve+ identifies several cases:\n* <code>a == 0:</code>\n  The equation to be solved is the linear equation <code>bx + c = d</code>. #sqsolve> delegates the computation to\n  #linsolve>. If it results in +nil+, +nil+ is returned (not <code>[nil]</code>!). Otherwise a one-element array\n  containing result of #linsolve is returned.\n* <code>a != 0:</code>\n   The equation to be solved actually is a second order one.\n   * <code>c == d</code>\n     The equation to be solved is <code>ax**2 + bx = 0</code>. One solution of this equation obviously is\n     <code>x = 0</code>, the second one solves <code>ax + b = 0</code>. The solution of the latter is\n     delegated to +linsolve+. An array containing both results in ascending order is returned.\n   * <code>c != d</code>\n     The equation cannot be separated into <code>x</code> times some factor.\n     * <code>b == 0</code>\n       The equation to be solved is <code>ax**2 + c = d</code>. This can be written as the linear equation\n       <code>ay + c = d</code> with <code>y = x ** 2</code>. The solution of the linear equation is delegated\n       to +linsolve+. If the returned value for +y+ is +nil+, that becomes the overall return value.\n       Otherwise an array containing the negative and positive squareroot of +y+ is returned\n     * <code>b != 0 </code>\n       The equation cannot be reduced to simpler cases. We now first have to compute what is called the\n       discriminant <code>x = b**2 + 4a(d - c)</code> (that's what we need to compute the square root of).\n       If the descriminant is negative no real solution exists and <code>nil</code> is returned. The ternary\n       operator checking whether <code>b</code> is negative does ensure better numerical stability --only one\n       of the two solutions is computed using the widely know formula for solving second order equations.\n       The second one is computed from the fact that the product of both solutions is <code>(c - d) / a</code>.\n       Take a look at a book on numerical mathematics if you don't understand why this should be done.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sqsolve(.)","arguments":[{"name":"a"},{"name":"b"},{"name":"c"},{"name":"d","default":"0.0"}]}],"returns":[],"file":"/lib/standard/facets/math/sqsolve.rb","line":null,"source":"def self.sqsolve(a, b, c, d = 0.0)\n  if a == 0.0\n    x = linsolve(b, c, d)\n    return x.nil? ? nil: [ linsolve(b, c, d) ]\n  else\n    return [0.0, linsolve(a, b)].sort if c == d\n    if b == 0.0\n      x = linsolve(a, c, d)\n      x < 0.0 ? nil : [-Math.sqrt(x), Math.sqrt(x)]\n    else\n      x = b * b + 4.0 * a * (d - c)\n      return nil if x < 0.0\n      x = b < 0 ? b - Math.sqrt(x) : b + Math.sqrt(x)\n      [-0.5 * x / a, 2.0 * (d - c) / x].sort\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{"author":"Josef Schugt"}},"Continuation.create":{"!":"method","declarations":["class","public"],"path":"Continuation.create","name":"create","namespace":"Continuation","comment":"= Continuation Extension\n\nCreates a continuation in a way that is easier to use than callcc.\nOn the initial call this will return the created Continuation and\nthe arguments you gave to Continuation.create in an Array. If you\nthen issue .call() on the Continuation execution will jump back to\nthe point of time where you initially invoked Continuation.create,\nbut this time it will return the Continuation and the arguments\nyou supplied in an Array.\n\nYou can supply a block instead of default arguments which will\ncause that block to be executed once and its result to be returned\nalong side the created Continuation, but this form is confusing\nand does only rarely make sense.\n\n  # Count from 0 to 10\n  cc, counter = Continuation.create(0)\n  counter   #~> 0..10\n  cc.call(counter + 1) if counter < 10\n\n  # Implement something similar to Array#inject using Continuations.\n  # For simplicity's sake, this is not fully compatible with the real\n  # inject. Make sure that you understand Array#inject before you try\n  # to understand this.\n  class ::Array\n    def cc_inject(value = nil)\n      copy = self.clone\n      cc, result, item = Continuation.create(value, nil)\n      next_item = copy.shift\n      if result and item\n        # Aggregate the result using the block.\n        cc.call(yield(result, item), next_item)\n      elsif next_item\n        # item not yet set and Array is not empty:\n        # This means we did not get a value and thus need to use the\n        # first item from the Array before we can start using the\n        # block to aggregate the result.\n        cc.call(next_item, result)\n      end\n\n      return result\n   end\n end\n [1,2,3,4,5].cc_inject { |acc, n| acc + n } # => 15","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"create(.)","arguments":[{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/continuation.rb","line":null,"source":"def Continuation.create(*args, &block)\n  args = [args] if not args.nil? and not args.is_a? Array # 1.6.8 compatibility\n  cc = nil; result = callcc {|c| cc = c; block.call(cc) if block and args.empty?}\n  result ||= args\n  return *[cc, *result]\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils":{"!":"module","path":"FileUtils","name":"FileUtils","namespace":"","comment":"","format":"rdoc","constants":["FileUtils::OPT_TABLE","FileUtils::Win32Exts","FileUtils::LINKING_SUPPORTED"],"includes":[],"extensions":[],"modules":["FileUtils::NoWrite","FileUtils::Verbose","FileUtils::DryRun"],"classes":["FileUtils::Entry_"],"methods":["FileUtils#wc","FileUtils#ln_r","FileUtils#link_entry","FileUtils#amass","FileUtils#cp_rx","FileUtils#copy_entryx","FileUtils#which","FileUtils#slice","FileUtils#head","FileUtils#tail","FileUtils#stage","FileUtils#whereis","FileUtils#safe_ln","FileUtils#outofdate?","FileUtils#out_of_date?","FileUtils#up_to_date?"],"accessors":[],"files":["/lib/standard/facets/fileutils/wc.rb","/lib/standard/facets/fileutils/ln_r.rb","/lib/standard/facets/fileutils/amass.rb","/lib/standard/facets/fileutils/cp_rx.rb","/lib/standard/facets/fileutils/which.rb","/lib/standard/facets/fileutils/slice.rb","/lib/standard/facets/fileutils/stage.rb","/lib/standard/facets/fileutils/whereis.rb","/lib/standard/facets/fileutils/safe_ln.rb","/lib/standard/facets/fileutils/outofdate.rb"],"tags":{}},"FileUtils::OPT_TABLE":{"!":"constant","path":"FileUtils::OPT_TABLE","name":"OPT_TABLE","namespace":"FileUtils","comment":"","format":"rdoc","value":"{}","tags":{},"files":["/lib/standard/facets/fileutils/ln_r.rb"]},"FileUtils::Win32Exts":{"!":"constant","path":"FileUtils::Win32Exts","name":"Win32Exts","namespace":"FileUtils","comment":"","format":"rdoc","value":"%w{.exe .com .bat .cmd}","tags":{},"files":["/lib/standard/facets/fileutils/which.rb","/lib/standard/facets/fileutils/whereis.rb"]},"FileUtils::LINKING_SUPPORTED":{"!":"constant","path":"FileUtils::LINKING_SUPPORTED","name":"LINKING_SUPPORTED","namespace":"FileUtils","comment":"","format":"rdoc","value":"[true]","tags":{},"files":["/lib/standard/facets/fileutils/safe_ln.rb"]},"FileUtils#wc":{"!":"method","declarations":["instance","public"],"path":"FileUtils#wc","name":"wc","namespace":"FileUtils","comment":"With no arguments, returns a four element array consisting of the number\nof bytes, characters, words and lines in _filename_, respectively.\n\nValid options are +bytes+, +characters+ (or just 'chars'),\n+words+ and +lines+:\n\n  # Return the number of words in 'myfile'\n  FileUtils.wc(\"myfile\",'words')\n\nCREDIT: Daniel J. Berger","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"wc(filename,option='all')","arguments":[{"name":"filename"},{"name":"option","default":"'all'"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/wc.rb","line":null,"source":"def wc(filename,option='all')\n  option.downcase!\n  valid = %w/all bytes characters chars lines words/\n\n  unless valid.include?(option)\n      raise \"Invalid option: '#{option}'\"\n  end\n\n  n = 0\n  if option == 'lines'\n      IO.foreach(filename){ n += 1 }\n      return n\n  elsif option == 'bytes'\n      File.open(filename){ |f|\n        f.each_byte{ n += 1 }\n      }\n      return n\n  elsif option == 'characters' || option == 'chars'\n      File.open(filename){ |f|\n        while f.getc\n            n += 1\n        end\n      }\n      return n\n  elsif option == 'words'\n      IO.foreach(filename){ |line|\n        n += line.split.length\n      }\n      return n\n  else\n      bytes,chars,lines,words = 0,0,0,0\n      IO.foreach(filename){ |line|\n        lines += 1\n        words += line.split.length\n        chars += line.split('').length\n      }\n      File.open(filename){ |f|\n        while f.getc\n            bytes += 1\n        end\n      }\n      return [bytes,chars,words,lines]\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Instantiable":{"!":"module","path":"Instantiable","name":"Instantiable","namespace":"","comment":"= Instantiable\n\nInitialize modules, almost as if they were classes.\n\nAlows a module to be used much like a class, by defining\na #new method that creates a class on demand.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Instantiable.append_features","Instantiable#new"],"accessors":[],"files":["/lib/standard/facets/instantiable.rb"],"tags":{}},"Instantiable.append_features":{"!":"method","declarations":["class","public"],"path":"Instantiable.append_features","name":"append_features","namespace":"Instantiable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"append_features(.)","arguments":[{"name":"mod"}]}],"returns":[],"file":"/lib/standard/facets/instantiable.rb","line":null,"source":"def self.append_features(mod)\n  mod.extend self\nend","language":"ruby","dynamic":null,"tags":{}},"Instantiable#new":{"!":"method","declarations":["instance","public"],"path":"Instantiable#new","name":"new","namespace":"Instantiable","comment":"Never use a class again! ;)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"new(*args,&blk)","arguments":[{"name":"*args"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/standard/facets/instantiable.rb","line":null,"source":"def new(*args,&blk)\n  mod = self\n  @instantiable_class ||= Class.new{include mod}\n  @instantiable_class.new(*args,&blk)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.epsilon":{"!":"method","declarations":["class","public"],"path":"Math.epsilon","name":"epsilon","namespace":"Math","comment":"Levi-Civita symbol of +i+, +j+, and +k+ - 1 if (+i+, +j+, +k+)\nis (1, 2, 3), (2, 3, 1), or (3, 1, 2), -1 if it is (1, 3, 2),\n(2, 1, 3), or (3, 2, 1), 0 as long as +i+, +j+, and +k+ are\nall elements of {1, 2, 3}, otherwise returns <code>nil</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"epsilon(.)","arguments":[{"name":"i"},{"name":"j"},{"name":"k"}]}],"returns":[],"file":"/lib/standard/facets/math/epsilon.rb","line":null,"source":"def self.epsilon(i, j, k)\n  i = Integer(i)\n  return nil if i < 1 or i > 3\n  j = Integer(j)\n  return nil if j < 1 or j > 3\n  k = Integer(k)\n  return nil if k < 1 or k > 3\n  case i * 16 + j * 4 + k\n    when 27, 45, 54 then return  1\n    when 30, 39, 57 then return -1\n  end\n  0\nend","language":"ruby","dynamic":null,"tags":{}},"Math.variance":{"!":"method","declarations":["class","public"],"path":"Math.variance","name":"variance","namespace":"Math","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"variance(.)","arguments":[{"name":"array"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/standard/facets/math/variance.rb","line":null,"source":"def self.variance(array, &block)\n  sum2 = if block_given?\n    sum(array){ |i| j = block[i]; j*j }\n  else\n    sum(array){ |i| i**2 }\n  end\n  sum2/array.size - mean(array, &block)**2\nend","language":"ruby","dynamic":null,"tags":{}},"Math.variance2":{"!":"method","declarations":["class","public"],"path":"Math.variance2","name":"variance2","namespace":"Math","comment":"Variance of the sample.\nVariance of 0 or 1 elements is 0.0.\n\nTODO: Same as #variance? Then choose one.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"variance2(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/variance.rb","line":null,"source":"def self.variance2(array)\n  return 0.0 if array.size < 2\n  summed_sqdevs(array) / (array.size - 1)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.pvariance":{"!":"method","declarations":["class","public"],"path":"Math.pvariance","name":"pvariance","namespace":"Math","comment":"Variance of a population.\nVariance of 0 or 1 elements is 0.0.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pvariance(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/variance.rb","line":null,"source":"def self.pvariance(array)\n  return 0.0 if array.size < 2\n  summed_sqdevs(array) / array.size\nend","language":"ruby","dynamic":null,"tags":{}},"Math.linsolve":{"!":"method","declarations":["class","public"],"path":"Math.linsolve","name":"linsolve","namespace":"Math","comment":"Returns real solution(s) of <code>+a+x + +b+ = +c+</code> or +nil+\nif no or an infinite number of solutions exist. If\n<code>c</code> is missing it is assumed to be 0.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"linsolve(.)","arguments":[{"name":"a"},{"name":"b"},{"name":"c","default":"0.0"}]}],"returns":[],"file":"/lib/standard/facets/math/linsolve.rb","line":null,"source":"def self.linsolve(a, b, c = 0.0)\n  a == 0 ? nil : (c - b) / a\nend","language":"ruby","dynamic":null,"tags":{"author":"Josef Schugt"}},"FileUtils#ln_r":{"!":"method","declarations":["instance","public"],"path":"FileUtils#ln_r","name":"ln_r","namespace":"FileUtils","comment":"Options: noop verbose dereference_root remove_destination\n\nHard link +src+ to +dest+. If +src+ is a directory, this method links\nall its contents recursively. If +dest+ is a directory, links\n+src+ to +dest/src+.\n\n+src+ can be a list of files.\n\n  # Installing ruby library \"mylib\" under the site_ruby\n  FileUtils.rm_r site_ruby + '/mylib', :force\n  FileUtils.ln_r 'lib/', site_ruby + '/mylib'\n\n  # Examples of copying several files to target directory.\n  FileUtils.ln_r %w(mail.rb field.rb debug/), site_ruby + '/tmail'\n  FileUtils.ln_r Dir.glob('*.rb'), '/home/aamine/lib/ruby', :noop => true, :verbose => true\n\n  # If you want to copy all contents of a directory instead of the\n  # directory itself, c.f. src/x -> dest/x, src/y -> dest/y,\n  # use following code.\n  FileUtils.ln_r 'src/.', 'dest'     # cp_r('src', 'dest') makes src/dest,\n                                     # but this doesn't.\n\nTODO: Why --remove-destination and not just --force?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ln_r(src, dest, options = {})","arguments":[{"name":"src"},{"name":"dest"},{"name":"options","default":"{}"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/ln_r.rb","line":null,"source":"def ln_r(src, dest, options = {})\n  fu_check_options options, OPT_TABLE['ln_r']\n  fu_output_message \"ln -r#{options[:remove_destination] ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}\" if options[:verbose]\n  return if options[:noop]\n  options = options.dup\n  options[:dereference_root] = true unless options.key?(:dereference_root)\n  fu_each_src_dest(src, dest) do |s, d|\n    link_entry s, d, options[:dereference_root], options[:remove_destination]\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#link_entry":{"!":"method","declarations":["instance","public"],"path":"FileUtils#link_entry","name":"link_entry","namespace":"FileUtils","comment":"Hard links a file system entry +src+ to +dest+.\nIf +src+ is a directory, this method links its contents recursively.\n\nBoth of +src+ and +dest+ must be a path name.\n+src+ must exist, +dest+ must not exist.\n\nIf +dereference_root+ is true, this method dereference tree root.\n\nIf +remove_destination+ is true, this method removes each destination file before copy.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"link_entry(src, dest, dereference_root = false, remove_destination = false)","arguments":[{"name":"src"},{"name":"dest"},{"name":"dereference_root","default":"false"},{"name":"remove_destination","default":"false"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/ln_r.rb","line":null,"source":"def link_entry(src, dest, dereference_root = false, remove_destination = false)\n  Entry_.new(src, nil, dereference_root).traverse do |ent|\n    destent = Entry_.new(dest, ent.rel, false)\n    File.unlink destent.path if remove_destination && File.file?(destent.path)\n    ent.link destent.path\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils::Entry_":{"!":"class","superclass":"Object","path":"FileUtils::Entry_","name":"Entry_","namespace":"FileUtils","comment":":nodoc:","format":"rdoc","constants":["FileUtils::Entry_::DIRECTORY_TERM","FileUtils::Entry_::SYSCASE"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["FileUtils::Entry_#link","FileUtils::Entry_#descendant_diretory?"],"accessors":[],"files":["/lib/standard/facets/fileutils/ln_r.rb"],"tags":{}},"FileUtils::Entry_::DIRECTORY_TERM":{"!":"constant","path":"FileUtils::Entry_::DIRECTORY_TERM","name":"DIRECTORY_TERM","namespace":"FileUtils::Entry_","comment":"","format":"rdoc","value":"\"(?=/|\\\\z)\".freeze","tags":{},"files":["/lib/standard/facets/fileutils/ln_r.rb","/lib/standard/facets/fileutils/ln_r.rb"]},"FileUtils::Entry_::SYSCASE":{"!":"constant","path":"FileUtils::Entry_::SYSCASE","name":"SYSCASE","namespace":"FileUtils::Entry_","comment":"","format":"rdoc","value":"File::FNM_SYSCASE.nonzero? ? \"-i\" : \"\"","tags":{},"files":["/lib/standard/facets/fileutils/ln_r.rb"]},"FileUtils::Entry_#link":{"!":"method","declarations":["instance","public"],"path":"FileUtils::Entry_#link","name":"link","namespace":"FileUtils::Entry_","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"link(dest)","arguments":[{"name":"dest"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/ln_r.rb","line":null,"source":"def link(dest)\n  case\n  when directory?\n    if !File.exist?(dest) and descendant_diretory?(dest, path)\n      raise ArgumentError, \"cannot link directory %s to itself %s\" % [path, dest]\n    end\n    begin\n      Dir.mkdir dest\n    rescue\n      raise unless File.directory?(dest)\n    end\n  else file?\n    File.link path(), dest\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils::Entry_#descendant_diretory?":{"!":"method","declarations":["instance","public"],"path":"FileUtils::Entry_#descendant_diretory?","name":"descendant_diretory?","namespace":"FileUtils::Entry_","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"descendant_diretory?(descendant, ascendant)","arguments":[{"name":"descendant"},{"name":"ascendant"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/fileutils/ln_r.rb","line":null,"source":"def descendant_diretory?(descendant, ascendant)\n  /\\A(?#{SYSCASE}:#{Regexp.quote(ascendant)})#{DIRECTORY_TERM}/ =~ File.dirname(descendant)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.factorial":{"!":"method","declarations":["class","public"],"path":"Math.factorial","name":"factorial","namespace":"Math","comment":"1 * 2 * ... * +n+, <code>nil</code> for negative numbers","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"factorial(.)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/standard/facets/math/factorial.rb","line":null,"source":"def self.factorial(n)\n  n = Integer(n)\n  if n < 0\n    nil\n  elsif FACTORIALS.length > n\n    FACTORIALS[n]\n  else\n    h = FACTORIALS.last\n    (FACTORIALS.length .. n).each { |i| FACTORIALS.push h *= i }\n    h\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#amass":{"!":"method","declarations":["instance","public"],"path":"FileUtils#amass","name":"amass","namespace":"FileUtils","comment":"An intergrated glob like method that takes a set of include globs,\nexclude globs and ignore globs to produce a collection of paths.\n\nThe ignore_globs differ from exclude_globs in that they match by\nthe basename of the path rather than the whole pathname.\n\nTODO: Should ignore be based on any portion of the path, not just the basename?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"amass(include_globs, exclude_globs=[], ignore=[])","arguments":[{"name":"include_globs"},{"name":"exclude_globs","default":"[]"},{"name":"ignore","default":"[]"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/amass.rb","line":null,"source":"def amass(include_globs, exclude_globs=[], ignore=[])\n\n  include_files = [include_globs].flatten.map{ |g| Dir.glob(g) }.flatten.uniq\n  exclude_files = [exclude_globs].flatten.map{ |g| Dir.glob(g) }.flatten.uniq\n\n  include_files = include_files.map{ |f| File.directory?(f) ? File.join(f, '**/*') : f } # Recursive!\n  exclude_files = exclude_files.map{ |f| File.directory?(f) ? File.join(f, '**/*') : f } # Recursive!\n\n  include_files = include_files.flatten.map{ |g| Dir.glob(g) }.flatten.uniq\n  exclude_files = exclude_files.flatten.map{ |g| Dir.glob(g) }.flatten.uniq\n\n  files = include_files - exclude_files\n\n  files = files.reject{ |f| [ignore].flatten.any?{ |x| File.fnmatch?(x, File.basename(f)) } }\n\n  files\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#cp_rx":{"!":"method","declarations":["instance","public"],"path":"FileUtils#cp_rx","name":"cp_rx","namespace":"FileUtils","comment":"Like FileUtils.cp_r, but takes a filter proc that can return false to skip a file:\n\n  cp_rx \"bigDirectoryTree\", \"dest\", {:noop => true} do |name|\n     /dontCopyThis$/.match(name)\n  end\n\nNote that if the filter rejects a subdirectory then everything within that\nsubdirectory is automatically skipped as well.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cp_rx(src, dest, options = {}, &filter)","arguments":[{"name":"src"},{"name":"dest"},{"name":"options","default":"{}"}],"block":{"name":"&filter"}}],"returns":[],"file":"/lib/standard/facets/fileutils/cp_rx.rb","line":null,"source":"def cp_rx(src, dest, options = {}, &filter)\n fu_check_options(options, OPT_TABLE['cp_r'])\n  if options[:verbose]\n   fu_output_message(\"cp -r#{options[:preserve] ? 'p' : ''}#{options[:remove_destination] ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}\")\n  end\n return if options[:noop]\n fu_each_src_dest(src, dest) do |s, d|\n  copy_entryx(s, d, filter, options[:preserve], options[:dereference_root], options[:remove_destination])\n end\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#copy_entryx":{"!":"method","declarations":["instance","public"],"path":"FileUtils#copy_entryx","name":"copy_entryx","namespace":"FileUtils","comment":"Like FileUtils.copy_entry, but takes a filter proc that can return false to skip a file.\n\nNote that if the filter rejects a subdirectory then everything within that\nsubdirectory is automatically skipped as well.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"copy_entryx(src, dest, filter, preserve = false, dereference_root = false, remove_destination = false)","arguments":[{"name":"src"},{"name":"dest"},{"name":"filter"},{"name":"preserve","default":"false"},{"name":"dereference_root","default":"false"},{"name":"remove_destination","default":"false"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/cp_rx.rb","line":null,"source":"def copy_entryx(src, dest, filter, preserve = false, dereference_root = false, remove_destination = false)\n Entry_.new(src, nil, dereference_root).traverse do |ent|\n  if filter.call(ent.path) then\n\t  destent = Entry_.new(dest, ent.rel, false)\n\t  File.unlink destent.path if remove_destination && File.file?(destent.path)\n\t  ent.copy destent.path\n\t  ent.copy_metadata(destent.path) if preserve\n  end\n end\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#which":{"!":"method","declarations":["instance","public"],"path":"FileUtils#which","name":"which","namespace":"FileUtils","comment":"Looks for the first occurrence of _program_ within _path_.\n\nOn the MS Windows platform, it looks for executables ending with .exe,\n.bat and .com, which you may optionally include in the program name.\nReturns <tt>nil</tt> if not found.\n\nCREDIT: Daniel J. Berger, Michael Granger\n\n--\nThe which() method was adopted from Daniel J. Berger, via PTools\nwhich in in turn was adopted fromt the FileWhich code posted by\nMichael Granger on http://www.rubygarden.org.\n++","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"which(prog, path=ENV['PATH'])","arguments":[{"name":"prog"},{"name":"path","default":"ENV['PATH']"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/which.rb","line":null,"source":"def which(prog, path=ENV['PATH'])\n  path.split(File::PATH_SEPARATOR).each {|dir|\n    # Windows checks against specific extensions\n    if File::ALT_SEPARATOR\n      ext = Win32Exts.find{|ext|\n        if prog.include?('.') # Assume extension already included\n          f = File.join(dir,prog)\n        else\n          f = File.join(dir,prog+ext)\n        end\n        File.executable?(f) && !File.directory?(f)\n      }\n      if ext\n        # Use backslashes, not forward slashes\n        if prog.include?('.') # Assume extension already included\n          f = File.join( dir, prog ).gsub(/\\//,'\\\\')\n        else\n          f = File.join( dir, prog + ext ).gsub(/\\//,'\\\\')\n        end\n        return f\n      end\n    else\n      f = File.join(dir,prog)\n      # Avoid /usr/lib/ruby, for example\n      if File.executable?(f) && !File.directory?(f)\n        return File::join( dir, prog )\n      end\n    end\n  }\n  nil\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#slice":{"!":"method","declarations":["instance","public"],"path":"FileUtils#slice","name":"slice","namespace":"FileUtils","comment":"In block form, yields lines +from+-+to+.  In non-block form, returns\nan array of lines +from+-+to+:\n\n  # Returns lines 8-12 of 'myfile'\n  FileUtils.body(\"myfile\",8,12)\n\nCREDIT Shashank Date, via Daniel Berger.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"slice(filename,from,to)","arguments":[{"name":"filename"},{"name":"from"},{"name":"to"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/slice.rb","line":null,"source":"def slice(filename,from,to) #:yield:\n  IO.readlines(filename)[from-1..to-1]\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#head":{"!":"method","declarations":["instance","public"],"path":"FileUtils#head","name":"head","namespace":"FileUtils","comment":"In block form, yields the first number of +lines+ of file +filename+.\nIn non-block form, it returns an array of the first number of +lines+:\n\n  # Returns first 10 lines of 'myfile'\n  FileUtils.head(\"myfile\", 10)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"head(filename,lines)","arguments":[{"name":"filename"},{"name":"lines"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/slice.rb","line":null,"source":"def head(filename,lines) #:yield:\n  a = []\n  IO.foreach(filename){|line|\n      break if lines <= 0\n      lines -= 1\n      if block_given?\n        yield line\n      else\n        a << line\n      end\n  }\n  return a.empty? ? nil : a\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#tail":{"!":"method","declarations":["instance","public"],"path":"FileUtils#tail","name":"tail","namespace":"FileUtils","comment":"In block form, yields the last number of +lines+ of file +filename+.\nIn non-block form, it returns the lines as an array.\n\nNote that this method slurps the entire file, so I don't recommend it\nfor very large files. If you want an advanced form of +tail+, I\nsuggest using file-tail, by Florian Frank (available on the RAA):\n\n  # Returns last 3 lines of 'myfile'\n  FileUtils.tail(\"myfile\",3)\n\nAnd no tail -f.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tail(filename,lines)","arguments":[{"name":"filename"},{"name":"lines"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/slice.rb","line":null,"source":"def tail(filename,lines) #:yield\n  IO.readlines(filename).reverse[0..lines-1].reverse\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#stage":{"!":"method","declarations":["instance","public"],"path":"FileUtils#stage","name":"stage","namespace":"FileUtils","comment":"Stage by hard linking included files to a stage directory.\n\nstage_directory   -  Where to stage the files\nsource_directory  -  Where to find files to stage\nfiles             -  Files to link in stage relative to source\n\nTODO: Rename to #link_stage or something less likely to name clash?\nTODO: Add options for :verbose, :noop and :dryrun ?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stage(stage_directory, source_directory, files, options={})","arguments":[{"name":"stage_directory"},{"name":"source_directory"},{"name":"files"},{"name":"options","default":"{}"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/stage.rb","line":null,"source":"def stage(stage_directory, source_directory, files, options={})\n  return stage_directory if options[:noop] || options[:dryrun]\n\n  stage_directory, source_directory = stage_directory.to_s, source_directory.to_s\n  ## ensure existance of staging area\n  rm_r(stage_directory) if File.directory?(stage_directory)\n  mkdir_p(stage_directory)\n  ## link files into staging area\n  files.each do |f|\n    src  = File.join(source_directory, f)\n    file = File.join(stage_directory, f)\n    if File.directory?(src)\n      mkdir_p(file) unless File.exist?(file)\n    else\n      fdir = File.dirname(file)\n      mkdir_p(fdir) unless File.exist?(fdir)\n      unless File.exist?(file) and File.mtime(file) >= File.mtime(src)\n        ln(src, file) #safe_ln ?\n      end\n    end\n  end\n  return stage_directory\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils::NoWrite":{"!":"module","path":"FileUtils::NoWrite","name":"NoWrite","namespace":"FileUtils","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["FileUtils::NoWrite#stage"],"accessors":[],"files":["/lib/standard/facets/fileutils/stage.rb"],"tags":{}},"FileUtils::NoWrite#stage":{"!":"method","declarations":["instance","public"],"path":"FileUtils::NoWrite#stage","name":"stage","namespace":"FileUtils::NoWrite","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stage(stage_directory, files, options={})","arguments":[{"name":"stage_directory"},{"name":"files"},{"name":"options","default":"{}"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/stage.rb","line":null,"source":"def stage(stage_directory, files, options={})\n  options[:noop] = true\n  FileUtils.stage(stage_directory, files, options={})\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils::Verbose":{"!":"module","path":"FileUtils::Verbose","name":"Verbose","namespace":"FileUtils","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["FileUtils::Verbose#stage"],"accessors":[],"files":["/lib/standard/facets/fileutils/stage.rb"],"tags":{}},"FileUtils::Verbose#stage":{"!":"method","declarations":["instance","public"],"path":"FileUtils::Verbose#stage","name":"stage","namespace":"FileUtils::Verbose","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stage(stage_directory, files, options={})","arguments":[{"name":"stage_directory"},{"name":"files"},{"name":"options","default":"{}"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/stage.rb","line":null,"source":"def stage(stage_directory, files, options={})\n  options[:verbose] = true\n  FileUtils.stage(stage_directory, files, options={})\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils::DryRun":{"!":"module","path":"FileUtils::DryRun","name":"DryRun","namespace":"FileUtils","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["FileUtils::DryRun#stage"],"accessors":[],"files":["/lib/standard/facets/fileutils/stage.rb"],"tags":{}},"FileUtils::DryRun#stage":{"!":"method","declarations":["instance","public"],"path":"FileUtils::DryRun#stage","name":"stage","namespace":"FileUtils::DryRun","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stage(stage_directory, files, options={})","arguments":[{"name":"stage_directory"},{"name":"files"},{"name":"options","default":"{}"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/stage.rb","line":null,"source":"def stage(stage_directory, files, options={})\n  options[:dryrun] = true\n  FileUtils.stage(stage_directory, files, options={})\nend","language":"ruby","dynamic":null,"tags":{}},"Math.percentile":{"!":"method","declarations":["class","public"],"path":"Math.percentile","name":"percentile","namespace":"Math","comment":"Returns the percentile value for percentile _pcnt_; nil if array is empty.\n\n+pcnt+ should be expressed as an integer, e.g. `percentile(90)` returns\nthe 90th percentile of the array.\n\nAlgorithm from NIST[http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm]\n\nNOTE: This is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Ben Koski\n\n@non-core\n  require 'facets/array/precentile'","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"percentile(.)","arguments":[{"name":"array"},{"name":"pcnt"}]}],"returns":[],"file":"/lib/standard/facets/math/percentile.rb","line":null,"source":"def self.percentile(array, pcnt)\n  sorted_array = array.sort\n\n  return nil if array.length == 0\n\n  rank  = (pcnt.to_f / 100) * (array.length + 1)\n  whole = rank.truncate\n \n  # if has fractional part\n  if whole != rank\n    s0 = sorted_array[whole - 1]\n    s1 = sorted_array[whole]\n\n    f = (rank - rank.truncate).abs\n\n    return (f * (s1 - s0)) + s0\n  else\n    return sorted_array[whole - 1]\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Math.theil_index":{"!":"method","declarations":["class","public"],"path":"Math.theil_index","name":"theil_index","namespace":"Math","comment":"Calculates the Theil index (a statistic used to measure\neconomic inequality).\n\nTI = \\sum_{i=1}^N \\frac{x_i}{\\sum_{j=1}^N x_j} ln \\frac{x_i}{\\bar{x}}\n\n  http://en.wikipedia.org/wiki/Theil_index","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"theil_index(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/theil_index.rb","line":null,"source":"def self.theil_index(array)\n  return -1 if array.size <= 0 or any? { |x| x < 0 }\n  return  0 if array.size <  2 or all? { |x| approx_equal(x, 0) }\n  m = mean(array)\n  s = sum(array).to_f\n  inject(0) do |theil, xi|\n   theil + ((xi > 0) ? (log(xi.to_f/m) * xi.to_f/s) : 0.0)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#whereis":{"!":"method","declarations":["instance","public"],"path":"FileUtils#whereis","name":"whereis","namespace":"FileUtils","comment":"In block form, yields each ((*program*)) within ((*path*)).  In non-block\nform, returns an array of each ((*program*)) within ((*path*)).  Returns\n(({nil})) if not found.\n\nOn the MS Windows platform, it looks for executables ending with .exe,\n.bat and .com, which you may optionally include in the program name:\n\n   FileUtils.whereis(\"ruby\")  #=> ['/usr/local/bin/ruby','/opt/bin/ruby']\n\nCREDIT: Daniel J. Berger","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"whereis(prog, path=ENV['PATH'])","arguments":[{"name":"prog"},{"name":"path","default":"ENV['PATH']"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/whereis.rb","line":null,"source":"def whereis(prog, path=ENV['PATH']) #:yield:\n  dirs = []\n  path.split(File::PATH_SEPARATOR).each{|dir|\n      # Windows checks against specific extensions\n      if File::ALT_SEPARATOR\n        if prog.include?('.')\n            f = File.join(dir,prog)\n            if File.executable?(f) && !File.directory?(f)\n              if block_given?\n                  yield f.gsub(/\\//,'\\\\')\n              else\n                  dirs << f.gsub(/\\//,'\\\\')\n              end\n            end\n        else\n            Win32Exts.find_all{|ext|\n              f = File.join(dir,prog+ext)\n              if File.executable?(f) && !File.directory?(f)\n                  if block_given?\n                    yield f.gsub(/\\//,'\\\\')\n                  else\n                    dirs << f.gsub(/\\//,'\\\\')\n                  end\n              end\n            }\n        end\n      else\n        f = File.join(dir,prog)\n        # Avoid /usr/lib/ruby, for example\n        if File.executable?(f) && !File.directory?(f)\n            if block_given?\n              yield f\n            else\n              dirs << f\n            end\n        end\n      end\n  }\n  dirs.empty? ? nil : dirs\nend","language":"ruby","dynamic":null,"tags":{}},"Math.approx_equal":{"!":"method","declarations":["class","public"],"path":"Math.approx_equal","name":"approx_equal","namespace":"Math","comment":"Approximately equal.\n\nTODO: Use core extension Numeric#approx? instead (?)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"approx_equal(.)","arguments":[{"name":"a"},{"name":"b"},{"name":"epsilon","default":"EPSILON"}]}],"returns":[],"file":"/lib/standard/facets/math/approx_equal.rb","line":null,"source":"def self.approx_equal(a, b, epsilon=EPSILON)\n c = a - b\n c *= -1.0 if c < 0\n  c < epsilon\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#safe_ln":{"!":"method","declarations":["instance","public"],"path":"FileUtils#safe_ln","name":"safe_ln","namespace":"FileUtils","comment":"Attempt to do a normal file link, but fall back\nto a copy if the link fails.\n\nCREDIT: Jim Weirich","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"safe_ln(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/fileutils/safe_ln.rb","line":null,"source":"def safe_ln(*args)\n  unless LINKING_SUPPORTED[0]\n    cp(*args)\n  else\n    begin\n      ln(*args)\n    rescue Errno::EOPNOTSUPP\n      LINKING_SUPPORTED[0] = false\n      cp(*args)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Math.kldivergence":{"!":"method","declarations":["class","public"],"path":"Math.kldivergence","name":"kldivergence","namespace":"Math","comment":"The Kullback-Leibler divergence from this array to that of +q+.\n\nNB: You will possibly want to sort both P and Q before calling this\ndepending on what you're actually trying to measure.\n\nhttp://en.wikipedia.org/wiki/Kullback-Leibler_divergence","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"kldivergence(.)","arguments":[{"name":"array"},{"name":"q"}]}],"returns":[],"file":"/lib/standard/facets/math/kldivergence.rb","line":null,"source":"def self.kldivergence(array, q)\n  fail \"Buggy.\"\n  fail \"Cannot compare differently sized arrays.\" unless size = q.size\n  kld = 0\n  each_with_index { |pi,i| kld += pi*Math::log(pi.to_f/q[i].to_f) }\n  kld\nend","language":"ruby","dynamic":null,"tags":{}},"Math.summed_sqdevs":{"!":"method","declarations":["class","public"],"path":"Math.summed_sqdevs","name":"summed_sqdevs","namespace":"Math","comment":"The sum of the squared deviations from the mean.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"summed_sqdevs(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/summed_sqdevs.rb","line":null,"source":"def self.summed_sqdevs(array)\n  return 0 if array.size < 2\n  m = mean(array)\n  sum(array.map{ |x| (x - m) ** 2 })\nend","language":"ruby","dynamic":null,"tags":{}},"Digest":{"!":"module","path":"Digest","name":"Digest","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":["Digest::Instance"],"classes":["Digest::Class"],"methods":[],"accessors":[],"files":["/lib/standard/facets/digest/base64digest.rb","/lib/standard/facets/digest/salted_digest.rb"],"tags":{}},"Digest::Instance":{"!":"module","path":"Digest::Instance","name":"Instance","namespace":"Digest","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Digest::Instance#base64digest","Digest::Instance#base64digest!","Digest::Instance#salted_digest","Digest::Instance#salted_hexdigest","Digest::Instance#salted_base64digest"],"accessors":[],"files":["/lib/standard/facets/digest/base64digest.rb","/lib/standard/facets/digest/salted_digest.rb"],"tags":{}},"Digest::Instance#base64digest":{"!":"method","declarations":["instance","public"],"path":"Digest::Instance#base64digest","name":"base64digest","namespace":"Digest::Instance","comment":"From Ruby 1.9.2 source","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"base64digest(str = nil)","arguments":[{"name":"str","default":"nil"}]}],"returns":[],"file":"/lib/standard/facets/digest/base64digest.rb","line":null,"source":"def base64digest(str = nil)\n  [str ? digest(str) : digest].pack('m0')\nend","language":"ruby","dynamic":null,"tags":{}},"Digest::Instance#base64digest!":{"!":"method","declarations":["instance","public"],"path":"Digest::Instance#base64digest!","name":"base64digest!","namespace":"Digest::Instance","comment":"From Ruby 1.9.2 source","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"base64digest!()","arguments":[]}],"returns":[],"file":"/lib/standard/facets/digest/base64digest.rb","line":null,"source":"def base64digest!\n  [digest!].pack('m0')\nend","language":"ruby","dynamic":null,"tags":{}},"Digest::Class":{"!":"class","superclass":"Object","path":"Digest::Class","name":"Class","namespace":"Digest","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Digest::Class.base64digest","Digest::Class.salted_digest","Digest::Class.salted_hexdigest","Digest::Class.salted_base64digest"],"accessors":[],"files":["/lib/standard/facets/digest/base64digest.rb","/lib/standard/facets/digest/salted_digest.rb"],"tags":{}},"Digest::Class.base64digest":{"!":"method","declarations":["class","public"],"path":"Digest::Class.base64digest","name":"base64digest","namespace":"Digest::Class","comment":"From Ruby 1.9.2 source","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"base64digest(.)","arguments":[{"name":"str"},{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/digest/base64digest.rb","line":null,"source":"def self.base64digest(str, *args)\n  [self.digest(str, *args)].pack('m0') \nend","language":"ruby","dynamic":null,"tags":{}},"Math.atkinson_index":{"!":"method","declarations":["class","public"],"path":"Math.atkinson_index","name":"atkinson_index","namespace":"Math","comment":"Closely related to the Theil index and easily expressible\nin terms of it.\n\nAI = 1-e^{theil_index}\n\nhttp://en.wikipedia.org/wiki/Atkinson_index","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"atkinson_index(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/atkinson_index.rb","line":null,"source":"def self.atkinson_index(array)\n  t = theil_index(array)\n  (t < 0) ? -1 : 1-Math::E**(-t)\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#outofdate?":{"!":"method","declarations":["instance","public"],"path":"FileUtils#outofdate?","name":"outofdate?","namespace":"FileUtils","comment":"The opposite of #uptodate?","format":"rdoc","aliases":["FileUtils#out_of_date?"],"singleton":null,"interfaces":[{"signature":"outofdate?(path, *sources)","arguments":[{"name":"path"},{"name":"*sources"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/standard/facets/fileutils/outofdate.rb","line":null,"source":"def outofdate?(path, *sources)\n  #return true unless File.exist?(path)\n  ! uptodate?(path, sources.flatten)\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#out_of_date?":{"!":"method","declarations":["instance","public"],"path":"FileUtils#out_of_date?","name":"out_of_date?","namespace":"FileUtils","comment":"The opposite of #uptodate?\nAlias for #outofdate?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"outofdate?(path, *sources)","arguments":[]}],"returns":[],"file":"/lib/standard/facets/fileutils/outofdate.rb","line":null,"source":"def outofdate?(path, *sources)\n  #return true unless File.exist?(path)\n  ! uptodate?(path, sources.flatten)\nend","language":"ruby","dynamic":null,"tags":{}},"FileUtils#up_to_date?":{"!":"method","declarations":["instance","public"],"path":"FileUtils#up_to_date?","name":"up_to_date?","namespace":"FileUtils","comment":"Alias for #uptodate?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"up_to_date?","arguments":[]}],"returns":[],"file":"/lib/standard/facets/fileutils/outofdate.rb","line":null,"source":"alias_method :up_to_date?, :uptodate?","language":"ruby","dynamic":null,"tags":{}},"Digest::Instance#salted_digest":{"!":"method","declarations":["instance","public"],"path":"Digest::Instance#salted_digest","name":"salted_digest","namespace":"Digest::Instance","comment":"CREDIT: Guido De Rosa","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"salted_digest(str='', salt=:auto)","arguments":[{"name":"str","default":"''"},{"name":"salt","default":":auto"}]}],"returns":[],"file":"/lib/standard/facets/digest/salted_digest.rb","line":null,"source":"def salted_digest(str='', salt=:auto)\n  if salt == :auto\n    salt = String.random_binary(digest_length) \n  end\n  digest(str + salt) + salt\nend","language":"ruby","dynamic":null,"tags":{}},"Digest::Instance#salted_hexdigest":{"!":"method","declarations":["instance","public"],"path":"Digest::Instance#salted_hexdigest","name":"salted_hexdigest","namespace":"Digest::Instance","comment":"CREDIT: Guido De Rosa","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"salted_hexdigest(str, salt)","arguments":[{"name":"str"},{"name":"salt"}]}],"returns":[],"file":"/lib/standard/facets/digest/salted_digest.rb","line":null,"source":"def salted_hexdigest(str, salt)\n  Digest.hexencode(salted_digest(str, salt))\nend","language":"ruby","dynamic":null,"tags":{}},"Digest::Instance#salted_base64digest":{"!":"method","declarations":["instance","public"],"path":"Digest::Instance#salted_base64digest","name":"salted_base64digest","namespace":"Digest::Instance","comment":"CREDIT: Guido De Rosa","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"salted_base64digest(str, salt)","arguments":[{"name":"str"},{"name":"salt"}]}],"returns":[],"file":"/lib/standard/facets/digest/salted_digest.rb","line":null,"source":"def salted_base64digest(str, salt)\n  [salted_digest(str, salt)].pack('m0')\nend","language":"ruby","dynamic":null,"tags":{}},"Digest::Class.salted_digest":{"!":"method","declarations":["class","public"],"path":"Digest::Class.salted_digest","name":"salted_digest","namespace":"Digest::Class","comment":"CREDIT: Guido De Rosa","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"salted_digest(.)","arguments":[{"name":"str"},{"name":"salt","default":":auto"},{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/digest/salted_digest.rb","line":null,"source":"def self.salted_digest(str, salt=:auto, *args)\n  new(*args).salted_digest(str, salt)\nend","language":"ruby","dynamic":null,"tags":{}},"Digest::Class.salted_hexdigest":{"!":"method","declarations":["class","public"],"path":"Digest::Class.salted_hexdigest","name":"salted_hexdigest","namespace":"Digest::Class","comment":"CREDIT: Guido De Rosa","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"salted_hexdigest(.)","arguments":[{"name":"str"},{"name":"salt","default":":auto"},{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/digest/salted_digest.rb","line":null,"source":"def self.salted_hexdigest(str, salt=:auto, *args)\n  new(*args).salted_hexdigest(str, salt)\nend","language":"ruby","dynamic":null,"tags":{}},"Digest::Class.salted_base64digest":{"!":"method","declarations":["class","public"],"path":"Digest::Class.salted_base64digest","name":"salted_base64digest","namespace":"Digest::Class","comment":"CREDIT: Guido De Rosa","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"salted_base64digest(.)","arguments":[{"name":"str"},{"name":"salt","default":":auto"},{"name":"*args"}]}],"returns":[],"file":"/lib/standard/facets/digest/salted_digest.rb","line":null,"source":"def self.salted_base64digest(str, salt=:auto, *args)\n  new(*args).salted_base64digest(str, salt)\nend","language":"ruby","dynamic":null,"tags":{}},"Math.gini_coefficient":{"!":"method","declarations":["class","public"],"path":"Math.gini_coefficient","name":"gini_coefficient","namespace":"Math","comment":"Calculates the Gini Coefficient (a measure of inequality of a distribution\nbased on the area between the Lorenz curve and the uniform curve).\n\nhttp://en.wikipedia.org/wiki/Gini_coefficient\n\nThis is a slightly cleaner way of calculating the Gini Coefficient then\nthe previous implementationj.\n\n  GC = \\frac{\\sum_{i=1}^N (2i-N-1)x_i}{N^2-\\bar{x}}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"gini_coefficient(.)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/standard/facets/math/gini_coefficient.rb","line":null,"source":"def self.gini_coefficient(array)\n  return -1 if size <= 0 or any? { |x| x < 0 }\n  return 0 if size < 2 or all? { |x| approx_equal(x,0) }\n  s = 0\n  sort.each_with_index { |li,i| s += (2*i+1-size)*li }\n  s.to_f/(size**2*mean).to_f\nend","language":"ruby","dynamic":null,"tags":{}},"ERB::OpenTemplate#initialize":{"!":"method","declarations":["instance","public"],"path":"ERB::OpenTemplate#initialize","name":"initialize","namespace":"ERB::OpenTemplate","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(*objs_ioc)","arguments":[{"name":"*objs_ioc"}]}],"returns":[{"type":"OpenTemplate","comment":"a new instance of OpenTemplate"}],"file":"/lib/standard/facets/erb.rb","line":null,"source":"def initialize(*objs_ioc)\n  ioc = Hash===objs_ioc.last ? objs_ioc.pop : {}\n  objs = objs_ioc\n\n  mods = []\n\n  objs.each do |obj|\n    mod = Module.new\n    obj.public_methods.each do |m|\n      mod.module_eval do\n        #define_method(m){ |*a,&b| obj.__send__(m,*a,&b) }\n        define_method(m, &obj.method(m).to_proc)\n      end\n    end\n    mods << mod\n  end\n\n  mod = Module.new\n  ioc.each do |k,v|\n    mod.module_eval do\n      define_method(k){ v }\n    end\n  end\n  mods << mod\n\n  extend *mods.reverse\nend","language":"ruby","dynamic":null,"tags":{}},"ERB::OpenTemplate#erb_result":{"!":"method","declarations":["instance","public"],"path":"ERB::OpenTemplate#erb_result","name":"erb_result","namespace":"ERB::OpenTemplate","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"erb_result(str)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/standard/facets/erb.rb","line":null,"source":"def erb_result(str)\n  ERB.new(str).result(binding)\nend","language":"ruby","dynamic":null,"tags":{}},"/README.rdoc":{"!":"document","path":"README.rdoc","name":"README.rdoc","mtime":null,"text":"= Ruby Facets\n\n\"ALL YOUR BASE ARE BELONG TO RUBY\"\n\n\n== Introduction\n\nRuby Facets is the premiere collection of general purpose method\nextensions and standard additions for the Ruby programming language.\n\nFacets houses the largest single collection of methods available for\nextending the core capabilities of Ruby's built-in classes and modules.\nThis collection of extension methods are unique by virtue of their atomicity.\nThe methods are stored in individual files so that each can be required\nindependently. This gives developers the potential for much finer control over\nwhich extra methods to bring into their code.\n\nIn addition Facets provides a collection of extensions to Ruby standard library\nplus a small collection of add-on classes and modules. Together these\nlibraries constitute an reliable source of reusable components, suitable\nto a wide variety of usecases.\n\n\n== Resources\n\n* Homepage: http://rubyworks.github.com/facets\n* Report Bugs: http://github.com/rubyworks/facets/issues\n* Mailing List: http://groups.google.com/group/facets-universal/topics\n* Wiki Pages: http://wiki.github.com/rubyworks/facets\n* Source Code: http://github.com/rubyworks/facets\n\n\n== Documentation\n\nFacets has special documentation needs due to it's extensive bredth.\nThe documentation generated when installing via RubyGems, or the YARD\ndocs provided by rubydoc.info can be somewhat unweildly because it\ncombines all of Facets in one large set. When using these resources,\nit is important to remain aware of the source location of particular\nmethods.\n\nFor better organized online documentation, generated to separate core\nextensions from standard libraries, see the {Learn Facets}[http://rubyworks.github.com/facets/learn.html] page\non the website for links to available documentation.\n\n\n== Installation\n\n=== RubyGems\n\nThe easiest way to install is via RubyGems.\n\n  $ gem install facets\n\n=== Setup.rb\n\nFacets can be installed the old-fashioned way using Ruby Setup (http://rubyworks.github.com/setup).\nDownload and unpack the .tar.gz package and run setup.rb, like so:\n\n  $ tar -xvzf facets-2.x.x.tar.gz\n  $ cd facets-2.x.x\n  $ sudo setup.rb\n\nFacets 2.8+ requires Ruby 1.8.7 or higher.\n\n\n== Mission\n\nFacets holds to the notion that the more we can *reasonably* integrate into\na common foundation, directed toward general needs, the better that foundation\nwill be able to serve the community. There are a number of advantages here:\n\n* Better Code-reuse\n* Collaborative Improvements\n* Greater Name Consistency\n* One-stop Shop and Installation\n\n\n== Usage\n\n=== CORE Library\n\nAt the heart of Ruby Facets is the CORE extensions library. CORE provides\na sizable collection of generally useful methods, along with a few supporting\nclasses, that extend the functionality of Ruby's core classes and modules.\n\nWith the exception of a few *uncommon* extensions, CORE contains anything that\nwill load automatically when issuing:\n\n  require 'facets'\n\nThis loads all the CORE functionality at once. If you plan to use more then a\nhandful of Facets core methods it is recommended that you require the library in\nthis way. However, you can also \"cherry pick\" the CORE library as you prefer.\nAnd for uncommon extensions this must be done. The general require statement for\na core extension library is:\n\n  require 'facets/<class|module>/<method>'\n\nFor example:\n\n  require 'facets/time/stamp'\n\nMost \"atoms\" contain only one method, but exceptions occur when methods\nare closely tied together.\n\nYou can load per-class or per-module groups of core methods by requiring the\nclass or module by name. For example\"\n\n  require 'facets/time'\n\nWill require all the core Time method extensions.\n\nNote that some methods that were part of CORE in 1.8 and earlier are now part\nof MORE libraries. A good example is 'random.rb'. There were separated because\nthey had more specialized use cases, where as CORE extensions are intended as\ngeneral purpose.\n\n==== Method File Names\n\nOperator method redirect files are stored using English names. For instance \n`Proc#*` is `proc/op_mul`.\n\nFor reference, here is the chart.\n\n     +@   => op_plus\n     -@   => op_minus\n     +    => op_add\n     -    => op_sub\n     **   => op_pow\n     *    => op_mul\n     /    => op_div\n     %    => op_mod\n     ~    => op_tilde\n     <=>  => op_cmp\n     <<   => op_lshift\n     >>   => op_rshift\n     <    => op_lt\n     >    => op_gt\n     ===  => op_case\n     ==   => op_equal\n     =~   => op_apply\n     <=   => op_lt_eq\n     >=   => op_gt_eq\n     |    => op_or\n     &    => op_and\n     ^    => op_xor\n     []=  => op_store\n     []   => op_fetch\n\nFacets simply takes the '*' and translates it into a string acceptable to all\nfile systems. Also, if a method ends in '=', '?' or '!' it is simply removed.\n\n\n=== MORE Library (aka Standard Library)\n\nOn top of the extensive CORE library, Facets provides extensions for Ruby's\nstandard library, as well as very small collection of additional modules and\nclasses to supplement it.\n\nUse this library like you would any other 3rd party library.\nThe only difference between Facet's Standard library and other libraries\nis the lack of any enclosing @Facets::@ namespace. This is becuase\nthe libraries provided by Facets are fairly low-level and very general \npurpose.\n\nWhen using Facets extended versions of Ruby's standard libraries,\nthe libraries have to loaded manually, of course. However you\ndo not need to load Ruby's library first, as the Facets' library\nwill do that automatically.\n\nFor example, normally one load Ruby's OpenStruct class via:\n\n  require 'ostruct'\n\nTo load 'ostruct.rb' plus Facets extensions for it simply use:\n\n  require 'facets/ostruct'\n\nFor details pertaining to the functionality of each feature,\nplease see the API documentation.\n\n\n== Contribute\n\nThis project thrives on contribution!\n\nIf you have any extension methods, classes or modules that you think have\nvery general applicability and would like to see them included in\nthis project, don't hesitiate to submit. Also, if you have better versions\nof any thing already included or simply have a patch, they are more than\nwelcome. We want Ruby Facets to be of the highest quality.\n\n\n== Authors\n\nThis collection was put together by, and largely written by Trans. He can be\nreached via email at transfire at gmail.com.\n\nSome parts of this collection were written and/or inspired by other persons.\nFortunately nearly all were copyrighted under the same open license, the Ruby\nLicense, or the more liberal BSD and MIT licenses. In the one or two exceptions\nI have included the copyright notice with the source code. Any code file not\nspecifically labeled othewise shall fall under the Ruby License.\n\nIn all cases, I have made every effort to give credit where credit is due.\nYou will find these acknowledgments embedded in the source code. You can see\nthem in \"CREDIT:\" and/or \"@author\" lines. \n\nAlso see the {Contibutors page}[https://github.com/rubyworks/facets/wiki/Contributors]\non the Wiki for a list of all contributing Rubyists. If anyone is missing from\nthe list, please let me know and I will correct right away. Thanks.\n\n\n== License\n\nThe collection PER COLLECTION is licensed as follows:\n\n  Ruby Facets\n  Copyright (c) 2004,2010 Rubyworks\n\n  Distributed under the terms of the Ruby license.\n\nThe Ruby license is a dual license that also provides for use of the GPL.\nComplete texts of both licenses accompany this document (see LICENSE).\n\nAcknowledgments and Copyrights for particular snippets of borrowed code\nare given in their respective source. All licenses are either compatible\nwith the Ruby license or the original author has given permission for\ninclusion of their code under such license.\n\n\n\"ALL YOUR BASE ARE BELONG TO RUBY!\"\n\nRuby Facets, Copyright (c)2005,2011 Rubyworks\n\nDo you Ruby? (http://ruby-lang.org)\n\n","format":"text/rdoc"},"/HISTORY.rdoc":{"!":"document","path":"HISTORY.rdoc","name":"HISTORY.rdoc","mtime":null,"text":"= Facets Release History\n\n== 2.9.3 / 2011-12-31\n\nHappy New Year! Ruby Facets kicks off the year with a 2.9.x release.\nThis release adds a number of new methods, a few general improvements\nand bug fixes, a couple of deprecations and finally settles the \nproject down to a two-part core/standard project organization.\n\nChanges:\n\n* New Features\n\n  * Add Hash#url_params. (Matt Kirk)\n  * Add Enumerable#hashify. (Ronen Barzel)\n  * Add String#briefcase, similar to #titlecase.\n  * Add Kernel#hierarchical_send (better replacement for preinitialize.rb).\n  * Add Class#hierarchically, which supports #hierarchical_send.\n  * Add Array#median, to get the sorted middle of an array.\n  * Add Math#percentile and Math#median.\n  * Add Instantiable mixin (returns from Mixers spin-off project).\n  * Add Equitable mixin (returns from Mixers spin-off project).\n  * Add Cloneable mixin (returns from Mixers spin-off project).\n  * Add Array#each_pair and #each_value.\n  * Add Numeric#positive? and #numeric?.\n  * Add Method#* and #^ composition methods. (Mike Burns)\n  * Add back Fixnum::MAX and MIN constants.\n  * Add Binding#with.\n\n* Improved Features\n\n  * Improve FileUtils#amass to be more robust.\n  * Improve String#snakecase to convert spaces to underscores.\n  * Improve String#camelcase to convert spaces to \"camels\".\n  * Improve String#snakecase to not handle path names (use #pathize).\n  * Improve String#camelcase to not handle module names (ise #modulize).\n  * Improve Numeric#approx? bu using ratio.\n\n* Renamed Features\n\n  * Rename Enumerable#has? to #incase?.\n\n* Bug Fixes\n\n  * Fix Hash#rekey to keep default_proc.\n  * Fix Binding#self to not be defined for Rubinius.\n\n* Deprecations\n\n  * Deprecate Preinitializable mixin.\n  * Deprecate main.rb, spun-off to `main_like_module` gem.\n\n* Implementation Details\n\n  * Reconsolidated library into just two parts, `core` and `standard`.\n  * The term \"more\" is just a synonym for \"standard\" now.\n  * Relative requires are being used more extensively.\n  * Collection scripts, e.g. `require 'facets'`, are static.\n\n\n== 2.9.2 / 2011-08-23\n\nThe main purpose of this release is a fix for Module#redefine_method,\nso it will not conflict with ActiveSupport. Beyond that a handful of new\nmethods have been added. This release also marks the start of using\na src/ directory to generate the lib/ directory.\n\nChanges:\n\n* New Features\n\n  * Add Enumerable#map_with and alias #zip_map.\n  * Hash#delete_values returns removed keys (#12).\n  * Add clap-like command-line parser to Shellwords.\n  * Add Module#let, akin to RSpec's method.\n  * Add uncommon Module#method_clash method.\n  * Add uncommon Class#singleton? method.\n\n* Bug Fixes\n\n  * Fix Module#redefine_method to use #remove_method.\n  * Fix Kernel#object_hexid, or at least try to do so again.\n  * Fix Exception#detail to not return backtrace if nil.\n\n\n== 2.9.1 / 2011-01-30\n\nPrimarily this release fixes a couple of small issues. But also a handful of\nnew methods have been added.\n\nChanges:\n\n* New Features:\n\n  * Add FileTest#absolute? and #relative?\n  * Add FileTest#contains?\n  * Add FileTest#safe?\n  * Add FileUtils#amass\n  * Add FileUtils#outofdate\n  * Add FileUtils#stage\n  * Add Kernel#yes? and Kernel#no?\n  * Add Enumerable#has? (TOUR library)\n  * Add Digest#salted_digest, etc.\n  * Add Digest#base64digest (1.9.2 method)\n  * Add String#random_binary\n\n* Improved Features\n\n  * Better OS detection in Platform class and RBConfig module\n  * Moved CPU byte order methods from RBConfig to Platform class\n  * General improvements to Platform class API\n\n* Bug Fixes\n\n  * Module#redefine_method need not check pre-existence of method\n  * Fix string/unquote.rb recursive require\n  * Kernel#object_hexid varies on CPU arch, not Ruby version.\n\n\n== 2.9.0 / 2010-09-01\n\nThis release is fairly extensive as it was originally intended to be v3.0.\nAfter further consideration it was decided to reserve v3.0 for the\npolish of real world feedback and more progressive changes. The primary\nfocus of this release has been the completion of migrating Facets into a true\nextensions library. With this release almost all add-on classes and mixins\nhave now been spun-off to other projects. Only the most general purposes\nadd-on classes and mixins remain.\n\nA new TOUR library division has also been added to complement CORE and MORE.\nThis division houses purely optional extensions. The new division serves\na couple of useful purposes. In particular, it helps separates the standard\nlibrary extensions from optional core extension in the RDocs and thus makes\nthe perfect place to vet new extension ideas.\n\nOne important change that will effect anyone using Facets along side\nActiveSupport is that Facets no longer tries to conditionally avoid\nmethod overlaps with ActiveSupport. This is fine for the upcoming\nActiveSupport 3.0 library which extends core classes directly instead of\nusing mixins. One need only require 'facets' in the Rails config/preinitializer.rb\nfile and ActiveSupport will take precedence over Facets. For older versions\nof ActiveSupport, the best approach is to cherry pick from Facets just the\nextensions you want, thus avoiding any conflicts. There are actually only a\ndozen or so overlaps and all are intended to compatible, but it doesn't hurt\nto be sure.\n\nLastly, it is worth mentioning that this release has been more thuroughly\ntested than any version of Facets to date. Thanks to RVM this release runs\ngreen on Ruby 1.8.6, 1.8.7 and 1.9.2.\n\nChanges:\n\n* New Features\n\n  * Add Kernel#temporarily, set variables temporarily and eval block\n  * Add Kernel#deep_clone, a better alternative to #deep_copy\n  * Add Kernel#present? and Kernel#presence\n  * Add Kernel#not and #not?\n  * Add Array#extract_options!, for pulling options off argument list\n  * Add Regexp#|, operator for Regexp#union\n  * Add Array#percentile and Array#median\n  * Add Module#memo, for instance level memoization\n  * Add YAML.read method\n  * Add Pathname#include?\n  * Add Module#anonymous?\n  * Add Module#copy_inheritor\n  * Add Indexable#from and Indexable#upto\n  * Add Array#from and Array#thru\n  * Add NA class via na.rb\n  * Add Memoizable in memoizable.rb for a more robust memoization system\n  * Add Module#safe_memo in thread.rb for thread safe memoization\n  * Add Kernel#sandbox in thread.rb for threaded $SAFE=4 evaluation\n  * Add Hash#subset\n  * Add Kernel#Y to tour library\n  * Add numerous Math extensions\n\n* Deprecations\n\n  * Deprecate Module#attr_toggler as a YAGNI\n  * Deprecate Kernel#class_eval b/c of it's confusing behavior\n  * Deprecate Module#once is no longer an alias for #memoize\n  * Deprecate Integer#succ(n) (for compatibility reasons)\n  * Deprecate Stackable, it's method were moved to CORE\n  * Deprecate Kernel#populate and #set_from (use #assign and #assign_from)\n  * Deprecate Kernel#non_nil? since #not_nil? is enough\n  * Deprecate #__HERE__ b/c implementation was unreliable\n  * Deprecate Time#since, use #less instead\n  * Deprecate Time#advance, use #shift instead\n  * Deprecate Kernel#super_as (no good way to get callers method name)\n  * Deprecate Integer#clear_bit, use #bit_clear instead\n  * Deprecate Kernel#resc, use String#to_re or #to_rx instead\n  * Deprecate Module#modspace\n  * Deprecate Kernel#__ and class X for Proc#partial, use NA instead\n  * Deprecate autoreload.rb has been spun-off to a separate project\n  * Deprecate Module#nesting, b/c redundant and overlap with Module.nesting\n\n* Renamed Features\n\n  * Rename Module#parent            to Module#enclosure\n  * Rename Module#parents           to Module#enclosures\n  * Rename Module#parent_name       to Module#modname\n  * Rename Array#recurisvely        to Array#recurse  \n  * Rename Hash#recurisvely         to Hash#recurse\n  * Rename Enumerable#recursive     to Enumerable#recursively\n  * Rename Array#recursive          to Array#recursively\n  * Rename Hash#recursive           to Hash#recursively        \n  * Rename Kernel#silence_warnings  to Kernel#disable_warnings\n  * Rename Hash#recursive_merge     to Hash#deep_merge\n  * Rename Class#prepend            to Class#preallocate\n  * Rename File#atomic_write        to FileUtils#atomic_write\n  * Rename Module#conflict          to Module#method_clash\n  * Rename Class#inheritor          to Module#class_inheritor\n  * Rename Symbol#re_s              to Symbol#as_s\n  * Rename String#chars             to String#characters\n  * Rename String#outdent           to String#unindent\n  * Rename Time#round               to Time#round_to\n  * Rename Time#hence               to Time#shift (but keep aliases)\n  * Rename Hash#zipnew              to Hash#zip\n\n* Moved Libraries\n\n  * Move roman.rb to integer/roman and string/roman.rb\n  * Move blank.rb to kernel/blank.rb\n  * Move facets-live.rb to facets/auto_core.rb\n  * Move cattr.rb to MORE library\n  * Move duplicable.rb to kernel/dup.rb\n  * Move bitmask.rb to integer/bitmask.rb\n  * Move enumerable/divide.rb to array/divide.rb\n  * Move enumerable/split.rb to array/split.rb\n  * Move enumerable/entropy.rb to array/entropy.rb\n  * Move enumerable/probability.rb to array/probability.rb\n  * Move enumerable/duplicates.rb array/duplicates.rb\n  * Move module/enclosure.rb to optional TOUR libs\n  * Move kernel/instance_exec to option TOUR libs\n\n* Bug Fixes\n\n  * Fix Fixed Hash#rekey! from clobbering previous keys\n  * Fix Exception#raised? is a class method\n  * Fix Enumerator#fx should use #map instead of #each\n  * Fix String#splice needs String#store\n  * Fix Kernel#blank? empty condition was faulty\n  * Fix Comparable#bound needs clip.rb, not cap.rb\n  * Fix String#file needs to pass block\n  * Fix String#edit_distance use new encodings for Ruby 1.9\n\n* Improved Features\n\n  * New lib/tour division of libraries\n  * Module#class_extend dynamically creates append_features method\n  * Kernel#require_all is only for relative requires\n  * __DIR__ can take subdirectory arguments\n  * Hash#join has more sensible default separator (' ')\n  * Some OpEsc escapes have been renamed\n  * Kernel#assign does not accept a block\n  * Kernel#try is now like ActiveSupport's\n  * Improved #respond (which is like old #try)\n  * Remove all `if defined?(ActiveSupport)` conditions\n  * Use #random_range to support specialized Range#at_rand functionality\n  * Use Comparable.[] instead of Comparable()\n  * Array#rotate rotates in opposite direction than before (b/c or Ruby 1.9)\n\n\n== 2.8.4 / 2010-04-27\n\nA minor point release just to get a few improvements out there before\nendeavering into more extensive work for the next major release.\n\n* New Features\n\n  * Added #glob_relative to Pathname\n\n* Deprecations\n\n  * Deprecated BlankSlate (use BasicObject)\n  * Deprecate hashbuilder.rb\n  * Removed casting_hash.rb, moved to new library\n  * Removed opencollection.rb, moved to new library\n  * Removed ansicode.rb, use ansi gem\n\n* Bug Fixes\n\n  * changed Numeric#length to return self, not to_s.self\n  * Fix mispelling of Class#descendants\n\n* Other Improvements\n\n  * Range#at_rand has been optimized\n  * Kernel#singleton_class no longer can take a block\n  * Hash#to_proc takes response argument replacing #to_proc_with_response\n  * OpenHash becomes more like OpenObject and OpenObject becomes bare bones\n  * Range#at_rand optimized for Fixnum/Bignum instead of Integer\n\n\n== 2.8.3 / 2010-04-10\n\nNew release which makes a few adjustments in Kernel core extensions,\nadds a few new extensions and additions, plus other small improvements.\nThe biggest change is the addition of Recusor, which is created via\nEnumerable#recursive. This class is somewhat like Enumerator and\nprovides a number of recursive methods.\n\nChanges:\n\n* 9 New Core Extensions\n\n  * Enumerable#recursive provides a number of other recursive methods.\n  * Enumerable#visit can be used to recursively iterate any Enumerable.\n  * Module#set has been added (from Sinatra).\n  * Symbol#/ is added to be like String#/.\n  * Struct#to_h is added and will ultimately replace Struct#attributes.\n  * ObjectSpace#reflect routes method calls to Kernel context.\n  * Hash#to_module converts a hash to mixin module (Jay Fields).\n  * Kernel#dup! is same as #try_dup from extlib.\n  * Add File#ext which is a useful variation of #extname (Lavir the Whiolet).\n\n* 3 Core Extensions Renamed\n\n  * Renamed #set_from to #assign_from (alias remains until Kernel#set is considerd).\n  * Renamed #populate to #assign and improve.\n  * Kernel#instance_vars is now Kernel#instance and also more useful.\n\n* 1 Core Deprecation\n\n  * Removed #instance_eval hack.\n\n* 2 Core Bug Fixes\n\n  * #map_with_index now uses #each_with_index.\n  * #to_proc_with_response spelling correction.\n\n* 1 Core Adjustment\n\n  * Aliased #metadef to #meta_def.\n\n* 3 New More Libraries\n\n  * casting_hash.rb provides CastingHash class, a hash with flexible keys and values.\n  * prepend.rb allows for AOP-like inclusion of modules.\n  * roman.rb provides simple roman numeral extensions to String and Integer.\n\n* 5 More Improvements\n\n  * Pathname#visit for iterating all entries beneath a path (chikamichi).\n  * Pathname#to_str, b/c Pathname is basically a type of String (from extlib).\n  * Range#at_rand in random.rb handles Float ranges (Lavir the Whiolet).\n  * FileUtils#cp_rx provides controlled copies.\n  * Stash class in stash.rb is improved and is now available as a stand-alone library.\n  * ioredirect.rb has been removed as IORedirect no longer worked.\n  * plugin_manager.rb has been removed. Use 'plugin' gem instead.\n\n\n== 2.8.2 / 2010-02-22\n\nThis release fixes a bug by removing Numeric#size. Turns out that was a\ncore method already. It includes an \"auditing\" of the core enumerable\nmethod which has led to a few modifications most noteable amoung them\nrenaming #map_detect to #find_yield and #compact_map to #purge.\n\nChanges:\n\n* 7 New Core Extensions\n\n  * Add Enumerable#each_with_object.\n  * Add #collapse which is a shortcut for flatten.compact.\n  * Add Numeric#spacing (Mr. Groff)\n  * Add Array#uniq_by! to complement Enumerable#uniq_by.\n  * Add String#exclude? as opposite of #include?\n  * Add Enumerable#exclude? as opposite of #include?\n  * Add Proc#bind_to \n\n* 2 Extensions Renamed\n\n  * Rename Enumerable#compact_map to #purge.\n  * Rename Enumerable#map_detect to #find_yield.\n\n* 4 Deprecations\n\n  * Deprecate #inject!/#injecting in favor of #filter.\n  * Deprecate Array#** as alias of #product.\n  * Remove Numeric#size, as it was already used by core.\n  * Spun tracepoint.rb off as a seprate library.\n\n* 3 Other Changes\n\n  * Integer#multiple? handles zero as an argument.\n  * facets.rb is now dynamically loaded instead of code generated.\n  * General imporvements to date.rb.\n\n\n== 2.8.1 / 2009-12-25\n\nThis release simply fixes a few minor issues.\n\nChanges:\n\n* 1 New Standard Extension\n\n  * Added Pathname#glob_relative to pathanme.rb.\n\n* 3 Adjustments\n\n  * Loading string/tab.rb no longer loads margin.rb or expand_tab.rb.\n  * Fixed FileList method delegations.\n  * Numeric#length and #size return +self+, not +to_s.length+.\n\n\n== 2.8.0 / 2009-11-05\n\nFacets 2.8 effectively completes the MORE library clean-up which peaked\nwith the previous 2.7 release. Another eight libraries have been deprecated,\na few of them spun-off to a separate project. However, this verison also\nreverts a few of the deprecations made in the last version. These libs \nwill remain in Facets's MORE library for the forseeable future.\n\nThis version effectively concludes the MORE library clean-up. The next, and\nlast version before Facets 3.0, will focus on \"auditing\" the CORE library.\n\nChanges:\n\n* 6 Libraries \"Undeprecated\":\n\n  * ini.rb\n  * linkedlist.rb\n  * matcher.rb\n  * memoizer.rb\n  * roman.rb\n  * semaphore.rb\n\n* 5 Libraries Deprecated:\n\n  * fileable.rb    (too esoteric)\n  * ioredirect.rb  (needs better implementation)\n  * coroutine.rb   (because of Fiber)\n  * capsule.rb     (may be spun-off)\n  * recorder.rb    (may be spun-off)\n\n* 3 Libraries Spun-Off and Deprecated:\n\n  * ansicode.rb           ansi\n  * progressbar.rb        ansi\n  * logger.rb             ansi\n\n* Additonal Enhancements:\n\n  * Kernel#extend can now take a block\n  * Fixed kernel#d so it is useable\n  * Added Range#at_rand (thanks to Tyler Rick)\n  * Added Enumerable#map_detect (thanks to Scott Taylor)\n  * String#/ calls File.join\n  * Added String#newlines and String#cleanlines\n  * String#titlecase includes apostrophe in words\n  * BasicObject/BlankSlate is more compliant with 1.9.1 design\n  * Enumerable#count can take multiple items, treats as logical Or\n  * Class#class_extend extends class level, not class_eval\n  * Integer#succ(n) becomes Fixnum#succ(n), succ.rb\n  * Complete rewrite of Inheritor\n  * Shellwords extensions have been reworked\n  * Added String#similarity\n  * Added Levenshtein String#edit_distance method\n  * And other minor improvements (some thanks to ccjr)\n\n\n== 2.7.0 / 2009-08-01\n\nFacets 2.7 is the biggest release of Facets since 2.4. Rather then trickle-release these\nchanges over the course of the 2.6.x series, I made the decision to let 2.7 have them\nall at once. In so doing this release nearly completes the process of trimming down\nthe MORE library to its essentials. Over 40 high-level libraries have been spun-off\nas separate gems and/or deprecated. No doubt this is a big change for Facets, and the\ntransition may be a bit bumpy over the short-term, but I am certain that in the long-run\neveryone involved will be better served. To help, I have listed the effected libraries\nand the alternate gems availble to take their place.\n\nA few other changes have also been made in the release that may also effect your code.\nIn particular you should note that #class_extension has been renamed to #class_extend\n(require 'facets/class_extend'). In addition we have added a few new core methods such\nas Exception#raised? and Symbol#thrown?.\n\nChanges:\n\n* Spun-Off Projects\n\nThese libraries have been deprectated from Facets entirely, but are available\nas separate gems (or soon will be).\n\n    LIBRARY               GEM\n    --------------------  ------------------------------\n    overload.rb           overload\n    binreadable.rb        binaryio\n    downloader.rb         downloader\n    xoxo.rb               xoxo\n    bicrypt.rb            bicrypt\n    typecast.rb           typecast\n    association.rb        association\n    syncarray.rb          sync\n    synchash.rb           sync\n    paramix.rb            paramix\n    crypt.rb              crypt3\n    lrucache.rb           lrucache\n    net/smtp_tls.rb       smtp_tls\n    advisable.rb          advisable\n    buildable.rb          buildable\n    memoizer.rb           memoizer\n    harray.rb             sparray\n    sparse_array.rb       sparray\n    iteration.rb          iteration\n    interval.rb           stick\n    infinity.rb           stick\n    pool.rb               pool\n    linkedlist.rb         linkedlist\n    semaphore.rb          semaphore\n    pqueue.rb             pqueue\n    censor.rb             language\n    matcher.rb            language\n    basex.rb              radix\n    minitar.rb            archive-tar-minitar -or- folio\n\n* Spun-Off But Still Available\n\nThese libraries have been spun-off into stand-alone gems, but remain\navailable via Facets too. Ultimately some of these will be removed\nfrom Facets too (in particular the ansi libraries).\n\n    LIBRARY               GEM\n    --------------------  ------------------------------\n    ansicode.rb           ansi\n    progressbar.rb        ansi\n    logger.rb             ansi\n    tracepoint.rb         tracepoint\n    dictionary.rb         dictionary\n    recorder.rb           recorder\n    ostructable.rb        ostructable -or- openhash\n    openobject.rb         openhash\n    opencollection.rb     openhash\n    opencascade.rb        openhash\n    openhash.rb           openhash\n    openmodule.rb         openmodule\n    fileable.rb           fileable\n    enumerablepass.rb     enumargs\n\n* Deprecations Without Current Replacement\n\nThe libraries have been deprecated but do not yet have replacements.\nSeperate gems for these are planned though.\n\n    * bbcode.rb\n    * ini.rb\n    * settings.rb\n    * xmlhash.rb\n\n* Deprecations Merged Into CORE\n\nThese libraries have been deprecated because their functionality was merged into\nthe CORE library and/or made available in some another way.\n\n    * 1stclassmethod.rb   #method! and #instance_method! are now part of CORE.\n    * elementor.rb        #per has been added to CORE.\n    * elementwise.rb      #ewise has been added to CORE.\n    * consoleutils.rb     #ask is in CORE, for the rest see Ansi or Clio project.\n    * attr.rb             Added Module#attr_setter to CORE, and separated the rest in MORE.\n\n* General Deprecations\n\nThese libraries have simply been deprecated because they were found lacking in\nsome significant fashion.\n\n    * nilstatus.rb        Poved rather useless, not to mention trivial.\n    * heap.rb             Heap was just an alias for PQueue anyway. Use 'pqueue' instead.\n    * dependency.rb       Other solutions exist that are much better (like Advisable).\n    * classmethods.rb     #class_extend solution is more robust.\n    * ziputils.rb         Have a look at Folio (gem install folio) for replacement.\n    * unheritable.rb      Implementation is trivial and usefulness questionable.\n    * instantise.rb       Replaced by instance_function.rb.\n\n* Other Enhancements\n\n    * Fixed Proc#curry to work with #define_method (Thanks to R.Potter)\n    * Module#class_extension has been renamed to #class_extend (require 'facets/class_extend').\n    * kernel#instance is no longer in core; now it is an extra monkey patch for #instance_eval.\n    * Kernel#this has been removed. It is equivalent to 'method(__method__)'.\n    * BlankSlate is now an alias for BasicObject, and will be deprecated in the future.\n    * Kernel#method! and Module#instance_method! now use a global variable for their cache.\n    * #object_state (old name was #state) has been added to core.\n\n\n== 2.6.0 / 2009-07-03\n\nFacets 2.6.0 removes htmlfilter.rb and cssfilter.rb due to licensing\nincompatability. These scripts are now available as a separate package\ncalled 'htmlfilter'. Also removed are a few MORE libs that were too\nexpiremental and/or not robust enough. Effectively this finishes up\nthe \"spring cleaning\" of the MORE lib mentioned a few releases back.\n\nBut it also marks a new start in trimming MORE down further. We have\ndecided to do this for three reasons 1) Some of the MORE libs would\nbe better served as separate projects. 2) Facets will become a tighter\nlibrary, primarily focused on extensions. And 3) all libraries involved\nwill become easier to maintain and thus more robust in the long run.\n\nThis release also fixes an important arity bug with the recently added\nModule#extend method --one of the very few actual core overrides in Facets.\n\nChanges:\n\n* 7 Major Enhancements\n\n    * Removed htmlfilter.rb due to licensing issues.\n    * Also removed cssfilter.rb ('gem install htmlfilter' now)\n    * Removed rwdelegator.rb, simply not a robust solution.\n    * Removed buildable.rb, api is too confusing.\n    * Removed meta.rb which was not very useful and too expiremental anyway.\n    * Removed prototype.rb, which needs it's own project.\n\n* 3 Minor Enhancements\n\n    * Removed Kernel#__HERE__ as it simply cannot work.\n      (Ruby 1.9.2 will offer #source_location for the same, btw)\n    * Returned binding/opvars to core.\n    * Added Integer#length as suggested by Victor H. Goff III.\n\n* 1 Bug Fix\n\n    * Fixed arity issue with Module#extend.\n\n\n== 2.5.2 / 2009-04-07\n\nFacets 2.5.2 is a simple maintentance release which fixed a few issues\nin the new to_hash.rb library. This release also added String#lowercase\nand String#uppercae.\n\nChanges:\n\n* 1 Major Enhancement\n\n    * added string/uppercase and lowercase\n\n* 1 Minor Enhancement\n\n    * adjustments to to_hash.rb\n\n\n== 2.5.1 / 2009-03-05\n\nFacets 2.5.1 fixes a few bugs, makes some small but nice additions\nand improves 1.9 compatibility.\n\nThe most important addition to make note of is Object#extend, which has\nbeen overridden to allow a block parameter. This is one of only two or three\nactual \"monkey patches\" in all of Facets. The block, when provided,\nis used to create an annonymous module which then extends the reciever.\nThis is a \"good practice\" way to extend objects, rather than using class_eval\non the singleton class.\n\nSpecial thanks to Erik Veenstra, Pit Capitan and especially Sandor Szücs\nfor their contributions to this release.\n\nChanges:\n\n* 7 Major Enhancements\n\n    * added Hash#group_by_value (thanks to Erik Veenstra)\n    * added String#file\n    * added Hash#new_with (Pit Capitan)\n    * added module/extend.rb, now can take a block.\n    * added hook.rb\n    * added to_h_auto\n    * overhauled to_hash.rb, now has multiple methods\n\n* 10 Bug Fixes\n\n    * corrected ostruct.rb to test for frozen state on updates\n    * fixed String#left_align\n    * fixed conflict between test_name.rb and test_arguments.rb\n    * fixed Enumreable#split when reciever is empty array\n    * fixed coruption of reciever by Hash#collate (thanks to Tilo Sloboda)\n    * fixed Array#to_h, h={} was not initialized\n    * fixed test of Module#conflict according ruby19\n    * fixed Hash#dearray_singluar_values\n    * association.rb stores reference when using #new\n    * changed Array#product to make it compatible to ruby 19, deleted block parameter\n\n* 5 Minor Enhancements\n\n    * split enumerable/collect into map_with_index and compact_map\n    * improved Array#to_h for 1.9 using flatten(1)\n    * Dictionary#replace can take regular Hash too\n    * move test_to_hash.rb from more to core\n    * Doc'd that UnboundMethod#name returns Symbol in 1.9, but String in 1.8\n\n\n== 2.5.0 / 2008-11-23\n\nFacets 2.5.0 is an important milestone in the development of Facets.\n\nThis release has been tested against Rails' ActiveSupport library.\nAs long as Facets is loaded after ActiveSupport, everything\nshould work fine. Of course, there's no counting for real world\ntrials, but all ActiveSupport testcases pass under this scenario.\n\nSecondly, this release is the first of two (or three) down-scaling\nreleases intended to remove all the remaining \"excess\" from the\nlibrary. This is being done for a variety of reasons. Some scripts\nare substantial enough to be one their own and have been spun-off\ninto separate largely compatible projects. In this release:\n\n  If you were using...   Use this project instead...\n\n    annotations.rb         Anise\n\n    bytes.rb               RichUnits\n    times.rb\n\n    command.rb             Clio\n    consoleutils.rb\n\nA few others scripts have been deprecated, without an alternative\nrecourse, simply because they were too weak, such as  uploadutils.rb,\nor highly experimental, such as chain.rb and eventhook.rb.\n\nAlthough this release constitutes an over all slimming down of Facets,\ntwo excellent new libraries have been added.\n\n1) *ini.rb* by Jeena Paradies. While YAML is frequently used by\nRubyists for configuration files, a full-on serializer like YAML\nis often overkill. INI files provide a lightweight solution\nspecifically geared for configuration.\n\n2) *filter.rb* by Brian Candler offers lazy evaluation chains of\nEnumerable methods. This is an elegant way to optimize contiguous\nmaps, selections, etc. --effective even on infinite enumerators.\n(Note, the name of this library may be changed in the next release.)\n\nWhile work remains to be done, I am happy to say, Facets is\nfinally beginning to approach the level of solidity I set out to\nachieve just over a year ago. Thank the Maker!\n\nSpecial thanks to Brian Candler, Jeena Paradies and Tyler Rick.\n\nChanges:\n\n* 9 Major Changes\n\n    * added Brian Candler's Enumerator::Filter\n    * added sparse_array.rb (was old harray.rb)\n    * added Jeena Paradies' ini.rb\n    * renamed CacheDelegator to Memoizer\n    * renamed DictionaryMatcher to just Matcher\n    * deprecated bytes.rb and times.rb (use RichUnits instead)\n    * deprecated uploadutils.rb; ziputils.rb will be (use Folio)\n    * deprecated annotations.rb (use Anise instead)\n    * deprecated command.rb and consoleutils.rb (use Clio instead)\n\n* 5 Minor Changes\n\n    * deprecated chain.rb (very expiremental)\n    * deprecated eventhook.rb (moved to ToadCode project)\n    * deprecated tagiter.rb (moved to ToadCode project)\n    * moved Hash#symolize_keys and #stringify_keys to core lib\n      (still recommend #rekey instead though)\n    * switched to git as of 2.4.5\n\n* 4 Bug Fixes\n\n    * memoize.rb, cache was at class-level, now at instance-level\n    * binding/caller.rb, fixed require for callstack.rb\n    * fixed missing require in string/tabto.rb\n    * Fixed some bugs with Time#ago/Time#hence not changing years\n      correctly when you changed months.\n      (For example, Time.utc(2008, 1, 1).ago(12, :months) incorrectly\n      returned 2009-01-01 instead of 2007-01-01.)\n      Changed Time#ago/Time#hence to still work if passed negative number.\n\n\n== 2.4.5 / 2008-10-02\n\nFacets 2.4.5 is a maintaince release. This release is notable however in that\nit will likely be the last that to use SVN. Facets will be switching to Git.\nAlso, some libraries that have been flagged \"to be deprecated\" for some time\nwill finally be so.\n\nChanges:\n\n* 8 Major Enhancements\n\n    * Re-added date.rb to lore library, and removed from core.  (#r1014)\n    * Much improved date.rb extension now in Lore library.  (#r1027)\n    * Deprecated kernel/suppress. Use Exception.suppress from now on.  (#r1040)\n    * Deprecated string/style.rb. Use English project instead.  (#r1074)\n    * Console namespace is no longer supported (for Ansicode).  (#r1077)\n    * enumerable/mode.rb, Enumerable#mode returns array since there can be more than one.  (#r1079)\n    * OpenCascade automatically creates nodes, use foo? to query.  (#r1056)\n    * Change #index_of to #index which now takes a block.\n\n* 14 Minor Enhancements\n\n    * OpenStruct.new can now take a default block, like Hash.new.\n    * Moved variablize methods out of metaid.rb and into separate files (string/ and symbol/).  (#r1042)\n    * Added Time#advance.  (#r1046)\n    * Speed up of Integer odd/even methods.  (#r1057)\n    * Array#index now takes a block (this is a core override).  (#r1059)\n    * Spilt file/write.rb into separate method files (append, create, writelines).  (#r1073)\n    * Modified Enumerable#split to behave like String#split.  (#r1076)\n    * hash/op.rb, split into separate method files.  (#r1081)\n    * Added string/modulize. string/methodize handles path names now too.  (#r1085)\n    * Class#cattr is now part of core.  (#r1089)\n    * Modified Enumerable#split to behave like String#split.  [minor]\n    * Removed Rope class. If anything this will have a separate project.\n    * Added doc/news.html and doc/authors.html to website (temporarily?).\n    * Added zlib.rb to Lore library.\n\n* 7 Bug Fixes\n\n    * OpenStruct#to_h dups internal table.  (#r1015)\n    * Fixed require of string/xor in bicrypt.rb.  (#r1039)\n    * integer/odd.rb, fixed Ruby 1.9 condition.  (#r1080)\n    * class/cattr_*.rb fix require bug\n    * opencascade.rb, fixed bug when accessing sub-hash.\n    * typecast.rb, fixed require for string/methodize.\n    * Fixed Pathname#glob to ensure use of ::File.\n\n\n== 2.4.4 / 2008-09-01\n\nFacets 2.4.4 includes a major bug fix that caused Facets not to load properly,\nhaving to do with a Time extension. The problem has been fixed. In addition,\nthis release put Facets only a few pending adjustments away from full\nRails/ActiveSupport compatibility.\n\nChanges:\n\n* 10 Major Enhancements\n\n    * Added string/mask providing powerful string manipulation.  (#997)\n    * BasicObject is now just a synonm for BlankSlate unless Ruby 1.9.  (#1000)\n    * Added Symbol#plain?, Symbol#query? and Symbol#setter?  (#1011)\n    * Removed Time#to_date.\n      * Due to clobberd RI Docs (!) this should have been in Lore lib date.rb\n      * Moved to Lore date.rb. (#1012)\n    * Re-added date.rb to lore library, and removed from core.  (#1014)\n    * Much improved date.rb extension now in Lore library.  (#1027)\n    * Deprecated kernel/suppress. Use Exception.suppress from now on.  (#1040)\n    * Improved date.rb and moved to LORE library, and removed from CORE.  [major]\n    * Deprecated kernel/suppress. Use Exception.suppress from now on.  [major]\n    * Deprecated String#to_time.\n      * This method reqiures the loading of a number of other standard libs.\n      * We can reconsider adding it again if we decide these other libs should be core.\n      * Or if we find a more suitable way to define the method.\n\n* 17 Minor Enhancements\n\n    * Moved style.rb to string/stylize.rb  (#998)\n    * Renamed string/subtract to string/op_sub.\n      Old name will remain for time being for compatability. (#1002)\n    * Module#instance_method_define? now only applies to public methods.  (#1003)\n    * Array#index accepts a block (one of the few core overrides).  (#1004)\n    * Moved Hash#<< from hash/update.rb to hash/op_push.rb  (#1005)\n    * Add facets class files (eg. facets/string) have been made dynamic.  (#1013)\n    * Moved variablize methods out of metaid.rb and into separate files (string/ and symbol/).  (#1042)\n    * Added Time#advance.  (#1046)\n    * Added qua_class.rb. Yea. It really is my favorite.\n    * Added simple functional test that loads all of Facets.\n    * Added a benchmark for measuring how fast Facets loads. (Core < 1sec!)\n    * Made Module#alias_method_chain a public method (for better Rails support).\n    * Wrapped Nilclass#to_f in 1.9 condition.\n    * float/round.rb redirects to numeric/round.rb.\n    * numeric/float.rb holds rounding methods for all classed Numeric, Integer and Float.\n    * Replaced Kernel#instance_exec with Mauricio's version.\n    * Improved String#each_char to work like Ruby 1.9.\n      * This loads strscan.rb.\n      * It is wrapped in a 1.9 condition.\n\n* 8 Bug Fixes\n\n    * Hash#<< now returns self  (#1001)\n    * OpenStruct#to_h dups internal table.  (#1015)\n    * Fixed require of string/xor in bicrypt.rb.  (#1039)\n    * Fixed facets.rb to use relative paths.\n    * Fixed cgi.rb (CGI is a class not a module).\n    * OpenStruct#to_h dups internal table.  [bug]\n    * Fixed require of string/xor in bicrypt.rb.  [bug]\n    * date.rb (stamp) fixed ref to constant FORMAT.\n\n\n== 2.4.3 / 2008-08-14\n\nFacets is almost fully interoperable with ActiveSupport and Ruby 1.9.\nWe will continue to improve this interoperability in upcoming releases.\n\nAs a REMINDER, Facets 2.4+ now encourages:\n\n  require 'facets'\n\nThis is better than cherry-picking methods. It may seem counter-intuitive,\nbut it actually proves more advantages to do this for the sake of\nimproved interoperability. The practice of cherry-picking can become\nproblematic if other dependent libraries have cherry-picked different\nmethods. In those cases these distinctions go unaccounted and untested.\n\nNote that this release does not include a setup.rb script. We are working\non a new version of this script, which we plan to include in the next release.\n\nThis release give special thanks to the following people for their contributions:\nKen Bloom, Nick Caruso, Evgeniy Dolzhenko, Andy Freeman, Tomasz Muras and Dave Myron.\nAnd of course, to anyone else I failed to mention that has contributed.\n\n(NOTE: 2.4.3's changes may actually be long to 2.4.2. Notice the releases are\nonly two days apart. There was an issue with 2.4.2 and it had to be replaced\nimmediately. So take the distinct with a grain of salt.)\n\nChanges:\n\n* Additions\n\n    * Add Time#trunc and Time#round to Core.\n    * Add Array#recursively and fixed bug in Hash#recursively.\n    * Add Kernel#instance method which provides a fluent interface to private object space.\n    * Add Symbol#plain?, Symbol#query? and Symbol#setter?\n    * Add Hash#symbolize_keys and #stringify_keys.\n    * Add File#split_root.\n    * Add #glob and #glob_first as extensions to Pathname.\n    * Add NilClass#ergo whic points back to kernel/ergo.\n    * Add #bump method to VersionNumber class.\n    * Add String#mask providing powerful string manipulation.\n    * Add Ken Bloom's DictionaryMatcher class (will be renamed in future version)\n\n* Deprecations\n\n    * Deprecate Hash#keys_to_s and Hash#keys_to_sym.\n      * These are the original versions of these methods.\n      * But now we can use #rekey(:to_s) and #rekey(:to_sym) instead.\n    * Deprecat ruby.rb, which was a sort 1.9 compatibility layer.\n\n* 22 Major Enhancements\n\n    * Changed File#rewrite to not use the in-place change of the string.\n    * Renamed Class#to_pathname and #to_methodname to #pathize and #methodize.\n    * Removed Console:: namespace for ANSICode.\n    * Moved Mentalguy's lazy.rb to core!\n    * Added Indexable and Stackable to core.\n    * BasicObject is now just a synonm for BlankSlate unless Ruby 1.9.  [major]\n    * Moved Indexable and Stackable to core.\n    * Renamed arguments.rb and CLI::Arguments to argvector.rb and Argvector.\n    * Added optional argument to Dictionary#first and #last.\n    * Moved binding/opvars from core to more.\n\n* 19 Minor Enhancements\n\n    * Improved File#rootname --it is now more robust.\n    * Made FileUtils#whereis a module_function again.\n    * Created Lore library to house extensions to Ruby's standard library.\n    * Re-added facets class files (eg. facets/string) and are now dynamic.\n    * Added block to Array#index.\n      * This is one of the few core overrides in Facets.\n      * It is a feature already in Ruby 1.9.\n    * Added Jim Weirich's BlankSlate class.\n      * This is a temporary measure be compatible w/ AcitveSupport's BasicObject.\n    * Split kernel/load.rb into require_all.rb and require_local.rb.\n    * Split module/alias.rb up into alias_accessor, alias_module_function and alias_method_chain.\n    * Renamed string/subtract to string/op_sub.\n      Old name will remain for time being for compatability. [minor]\n    * Moved style.rb to string/stylize.rb  [minor]\n    * Added warning to bytes to use RichUnits instead.\n    * Updated warn line fore eventual deprecation of fileshell and arguments.*\n    * Added facets-load.rb to allow old school cherry picking.*\n      * Between 2.0 and 2.4 require 'facets' simply added core to LOAD_PATH.\n      * Starting with 2.4 it loads all of core automatically instead.\n      * facets-load.rb provides a way to use the old behavior.\n            require 'facets-load.rb\n            require 'kernel/with'\n            require 'symbol/to_proc'\n      * This adds the path to the end of LOAD_PATH to prevent any load conflicts.\n\n* 5 Bug Fixes\n\n    * Fixed Time#hence changed years when changing months.\n    * Fixed Time#hence to flip year correctly when adding months.\n    * Hash#<< returns self\n    * Fixed String#pathize.\n    * Module#instance_method_defined? now only applies to public methods.\n\n* Administrative Enhancements\n\n    * While not perceptible to an end user, there are now 3 divisions: lib/core, lib/lore, lib/more.\n    * Modified script/test to display $LOAD_PATH before running tests.\n\n== 2.4.2 / 2008-08-12\n\nJust some more of those great old work your ass off changes.\n\nChanges:\n\n* Major Enhancements\n\n    * Added Ken Bloom's DictionaryMatcher class from Ruby Quiz #103.\n      (Note this class will probably be renamed in the future.)\n    * Changed File#rewrite to not use the inplace change of the string.\n      * If you were using the function, change your code to use File#rewrite! instead.\n      * Or, modify your code ot use the new behavior.\n      * This change can make for a slippery bug, so be sure to check for it!\n    * Moved live.rb to facets-live.rb.\n    * Added kernel/instance method which provides a fluent interface to private object space.\n\n* 5 Minor Enhancements\n\n    * Added sow generation forms.\n    * Spilt Time#trunc into separate file.\n    * Remove old log files --shouldn't version control these.\n    * Added note to FileList to add glob options parameter.\n    * Added optional argument to Dictionary#first and #last.\n\n* Other Enhancements\n\n    * Move \"lore\" tests to test/lore (lore are extensions to Ruby's standard lib).\n    * Added test/core, test/lore and test/more.\n    * Added time/test_round.rb\n    * Added array/recursively.\n    * Added time/round.\n    * Time#to_date makes the public (it already existed in Ruby!)\n    * Fixed Time#hence to flip year correctly when adding months.\n    * Work on documentation using new Sow system.\n    * Moved meta.rb to more/kernel/meta.rb and merged facets/core.rb into facets.rb.\n    * Added more/kernel directory --hey not every extension can be core.\n    * Adjusted loadpath and moved lazy.rb to core!\n    * Moved remaing files to subdirectory locations.\n    * Moved most core libs to core/.\n    * Move most more files to the more directory.\n    * Added lore and more directories.\n    * Added facets/core directory. Yes, I'm spiliting the lib again.\n      * Loadpath will be used, so user inteface will stay the same.\n      * Setup.rb will be adjusted to recognaize loadpath.\n    * Removed Rope class. If anything this will have a separate project.\n    * Moved setup.rb to script/setup.\n      * This will either be replaced with configure/install scripts.\n      * Or, depend on a separate ruby setup.rb project.\n    * Added recorder.rb to consider in work directory.\n    * Added admin directory.\n    * Added \"TO BE DEPRECATED\" message to ruby.rb.\n    * Added all methods from ruby.rb as individual core methods.\n      * These are the methods that overlap with 1.9.\n      * They are encased in 'unless RUBY_VERSION' caluses.\n    * Imporved file/rootname --now much more robust.\n    * Added Kernel#to_yamlfrag to yaml.rb as way to output yaml w/o the \"---\" header.\n      * Perhaps not the most robust solution, but okay for now.\n      * Maybe a poor name for the method, but you got a better one?\n    * Made FileUtils#whereis a module_function again like it used to be. Because:\n      (1) that seems to be the way most other FileUtils methods are (cd, mkdir, cp, ...) and the most\n          obvious way that users would WANT to use FileUtils: FileUtils.whereis(\"ruby\").\n      (2) I see module_function used in other comparible parts of Facets: UploadUtils, ConsoleUtils,\n          ZipUtils, FileUtils#safe_ln, ...\n      (3) My code that relied on the old module_function behavior was breaking\n          What were you thinking changing it?? ;)\n\n\n== 2.4.1 / 2008-04-03\n\nThis release takes aim at improving compatability with ActiveSupport.\nIt also reintroduces an improved paramix.rb.\n\nChanges:\n\n* 4 Major Enhancements\n\n    * A much improved paramix.rb has been returned to the library.\n      * There a no longer capitialize module methods at all.\n      * Use Module#[] and mixin_params[] instead.\n    * Deprecated behavior.rb. It was not robust.\n    * Added basex.rb, for working in any encoding base using any character set (base62 is the default).\n\n* 3 Minor Enhancements\n\n    * Comparing to ActiveSupport, found 63 extension clashes, but most are due to 1.9 features.\n      The rest should be compatible.\n    * Reatomized a number of Kernel and String methods. Reatomization is nearly complete.\n    * Continued work on reatomizing core extensions (nearly complete now).\n\n\n== 2.4.0 / 2008-03-24\n\nFacets 2.4 is a major step forward for Facets. It is perhaps the release\nthat 2.0 should have been, but of course it took the actual 2.0 release\nto make 2.4 possible. Some annoyances you may have encountered in updating\nyour code to 2.0 are now fixed. And from 2.4 on, Facets will now be\nsettling down into simple refinement release cycles for a while.\n\nThe main change under the hood is to bring everything up to the top\nlib/facets/ directory. No longer are the libraries sorted by category.\nI had done so for a long time to make it easier to track the various libs,\nbut in the end it was only making it more diffcult to deal with build tools\nand packaging.\n\nFor the end-user, the largest change is a new emphisis on:\n\n  require 'facets'\n\nThis is better than cherry-picking methods. It may seem counter-\nintuitive, but it actually proves more advantantages to do this\nfor the sake of interoperability than the practice of cherry-picking.\nThe reason is simply because others may have cherry-picked different\nmethods, and those distinctions go unaccounted and untested.\n\nAlso with this release, to bolster the use of require 'facets',\nsome lack-luster extensions have been deprecated and namespace usage\nhas been improved. In addition, we are getting very close to full\nActiveSupport, and Ruby 1.9, interoperability. Expect this\nto be complete in the next minor release or two.\n\nChanges:\n\n* Enhancements\n\n    * String#to_re and String#to_rx have swapped default behaviors. #to_rx escapes, #to_re does not.\n    * The Console namespace is being deprecated. command.rb and arguments.rb now use CLI naemspace.\n    * #compare_on and #equate_on are now \"mixin methods\" Comparable() and Equateable().\n    * Enumerable#product, #combintations and #permutations have change to be Ruby 1.9 compatible.\n    * thread.rb, map_send, et al, block is passed to send instead of yielding on result.\n    * namespace.rb has been renamed to methodspace.rb.\n    * Ruby 1.9 defined a new Proc#curry method, so Facets version has been made compatible.\n    * The old curry method is now called #partial, as in \"partial application\".\n    * Deprecated interface.rb. Perhaps a better approach but nonetheless extraneous.\n    * Deprecated paramix.rb. A better way is to use a capitialized methods. (Perhaps a lib for that?)\n    * Brought back a few web related libs, htmlfilter.rb and cssfilter.rb in particular.\n    * camelcase and snakecase are core extensions. For specialized styles use String#style in style.rb.\n    * Renamed ArgVector to CLI::Arguments\n    * Moved one_nine.rb to ruby.rb\n    * Moved test/test_one_nine.rb to test/test_ruby.rb.\n    * Updated requires for \"one_nine\" to just \"ruby\" b/c of backports to 1.8.7.\n    * Added warning to Rick Kilmers's unit system.\n        * Moving Rich Kilmers's units system to it's own package.\n        * Three are alternate unit systems available and Facets should work with any of them.\n        * Will keep a fair amount of the Time extensions though.\n    * Moved nil/status.rb to nilstatus.rb\n    * Got rid of Method#curry and Method#partial since they just convert to Procs.\n    * Made op_esc.rb a separate module rather thanan extension.\n    * Deprecated with_reader, with_writer and with_accessor for attr_singleton_reader, &c.\n    * Deprecated Hash#pairs_at. Use Hash#slice instead from core.\n    * Fixed the namespaces of some extensions.\n    * Added prime directory and files.\n    * Removed all \"prime\" extension files.\n    * Move mattr to module.\n    * Fixed require bug in time methods.\n    * Reverted memomize.rb back to original code --will come back to later.\n    * Added stylizer.rb to replace stylize.rb\n    * Array #recursively is not only called #traverse.\n    * Added case/stylize methods to more/facets/string.\n    * Renamed more/string/facets/titlecase to captialize_all.\n    * Added uri and xoxo tests.\n    * Progressive work on memoize and elementor.\n    * Functor no longer privatizes =, == and =~.\n    * Properly split conversion.rb.\n    * Some string methods extracted from stylize.rb.\n    * Moved random.rb to more/.\n    * Renamed namespace.eb to methodspace.rb.\n    * Moved autoreload to more/facets/kernel.\n    * Removed old curry.rb.\n    * Added cgi.rb with some standard extensions.\n    * Deprecated paramix.rb.\n    * Added xmlhash.rb and returned uri.rb extensions to the library.\n    * Added #method_name to Date class.\n    * Remove cut-bases AOP, now in it's own library.\n    * Converted compare_on.rb to Paramtric Mixins.\n    * Split fileutils up into individual methods.\n    * Renamed console.rb to what it should be consoleutils.rb.\n    * Update to command.rb integrating MasterCommand and Command into a single class.\n    * Added options back into multiglob_r.\n    * Improved cloneable.rb to be a true deep dup/clone mixin using Ken Bloom's suggestion.\n    * Added tasksystem.rb.\n    * Added enumerable/combinations.\n    * Added openhash and tracepoint.\n\n* Bug Fixes\n\n    * Fixed bug with #peek in stackable.\n    * Fixed bug in Kernel#object_hexid.\n    * Fixed bug in multiglob_r so it will NOT follow symlinks.\n    * Fixed test_keyize.rb.\n\n* Adminstrative Changes\n\n    * This was a fairly large and fast-paced update, so unfortunately not all changes are listed this time.\n    * Added ri generation to setup.rb.\n    * Updated README and allowed doc/ to be included in package.\n    * Finally completed removal of all embedded tests.\n    * Organized all libs between core, more, class and mixin.\n\n\n== 2.3.0 / 2008-02-01\n\nAmoung other changes with this release, cloneable.rb is now a true deep\ndup/clone mixin; tracepoint.rb returns to the library.\n\nChanges:\n\n* 4 Major Enhancements\n\n    * Cloneable provides true deep cloning.\n    * Moved hash_keyize.rb to CORE as hash/keyize.rb.\n    * Added tracepoint.rb back to the library.\n    * Added hash/collate.\n\n* 3 Bug Fixes\n\n    * Fixed multiglob_r bug, so it will NOT follow symlinks.\n    * Added a couple of missing binding requires.\n    * Fixed test_keyize.rb.\n\n* 6 Admistrative Changes\n\n    * Reorganized library into smaller groups: core, more, class and mixin.\n    * Remove admin/svn subdir.\n    * Remove admin/log.\n    * Add admin tasks.\n    * Moved admin tasks to admin directory.\n    * Added admin directory.\n\n\n\n== 2.2.1 / 2007-12-22\n\nThis release get rid of the underlying methods subdir.\nAll method redirects are now in core, to ensure there\nare no more name clashes.\n\nChanges:\n\n* Method Renames\n\n  * Moved string/format.rb to string/wrap.rb.\n  * Updated String#brief.\n  * Moved binding/cflow.rb to caller.rb.\n  * Moved core hash/keyize to more.\n\n* Other Enhancements\n\n  * Fixed up binding extensions.\n\n* Administrative Adjustments\n\n  * Got rid of methods subdir. All method redirects are in core/.\n  * Moved doc/wiki to apiwiki b/c of Rubyforge's wiki.\n  * Removed doc/api dir.\n  * Added wiki.\n  * Renamed a couple test tasks.\n  * Update per-module/class files.\n  * Moved methods and groups task to trash.\n  * Added test class/remove_descendents.rb.\n  * Added all remaining per-method require libs from methods/ (will need to wrok through these over time).\n  * Added trash work directory.\n  * Adjust text according to per-method file changes.\n  * All hash method, but the conversion methods, are now represented in core/facets/hash.\n  * Added a few more Hash per-method files.\n  * Add per-method libs for hash.\n  * Updated facets/string.rb.\n  * Renamed ROLLRC to facets.roll.\n\n\n== 2.2.0 / 2007-12-13\n\nThis release provides improved rdocs and prepares facets for use with Ruby 1.9.\nIt also adds Matthew Harris' duration.rb library. Bug thanks to Matthew!\n\nChanges:\n\n* Additions\n\n    * Added Matthew Harris' Duration class.\n    * Added Hash#slice and Hash#except (didn't we have this before?)\n    * Added registerable.rb, updated history.\n    * Added #include_as to facets/namespace.rb.\n    * Added op.rb to string.rb.\n    * Added String/op.rb with String#- method.\n\n* Method Renames and Reorganizations\n\n    * The name Array#unzip didn't makes sense, it was renamed to #modulate (though #collate seems better?)\n    * Renamed Enumerable#collate to #mash (Map hASH); #collate and #graph remain aliases for the time being.\n    * Renamed accessor #attributes to #instance_attributes.\n    * Renamed Enumerable #collate to #mash. (old name, along with graph, will be an alias for time being)\n    * Divided enumerable/collect into split.rb and each.rb as well.\n    * Moved mapsend.rb to thread.rb.\n    * Updated mapsend.rb to focus on threads.\n    * Moved continuation extensions to more lib.\n\n* Deprecations\n\n    * Deprecated Module#include_and_extend. Just use both silly.\n    * More lib pp_s.rb has been removed. Use #pretty_inspect instead.\n    * Removed continuation from core.\n    * Removed pp_s.rb (use pretty_inspect) add continuation.rb.\n    * Remove kernel/require_esc.rb.\n\n* Other Enhancements\n\n    * integer/bitmask.rb has changed a bit --pun intended ;) Deprecated some methods and now use \"~\" instead of \"-\" to clear bits.\n    * Split binding extensions up a bit more finely --eval.rb sprouted here.rb, self.rb and defined.rb.\n    * Move Time#stamp out of conversion.rb and into time/ dir, and remove to_s alias.\n    * Preliminary addition of Matthew Harris' excellent duration.rb lib (will integrate with times.rb better in future).\n    * Minor edit to basicobject.rb in light of 1.9.\n    * Minor adjustments to lazy.rb to fix warnings by Ruby 1.9.\n    * Added if clauses to handle upcoming Ruby 1.9 gracefully. Facets should now be just about ready for use with 1.9.\n\n* Documentation Enhancements\n\n    * A lot of rdoc updates to core extensions --as promised ;)\n    * Just about every method now has at least a brief explinaiton and an example.\n\n* Administrative Adjustments\n\n    * Moved task/config.yaml to meta/ per new Ratch.\n    * Moved task/special to task/doc.\n    * Updated todo list (in dev/).\n    * Copied log/history.rd to CHANGES.\n    * Removed log/history.rd and log/todo.rd\n    * Fixed stylize.rb for use with 1.9 (fixed case statement).\n    * Separated kernel/returning, now that #tap will be in 1.9.\n    * Updated facets.rb for use with 1.9.\n    * Separated time/stamp.rb.\n    * Divided binding up into a few more pieces.\n    * Fixed kernel/instance to play nice with 1.9.\n    * Added test for string/op.rb.\n    * Added test_collect.rb split-offs and test_mash inplace of test_collate.\n    * Cleanup test headers.\n    * Added 1.9 check in continuation/create.rb.\n    * Add a couple new task for rdoc gen.\n    * Added nbsp to quickopts task.\n    * Work on website using siteparts.\n\n\n== 2.1.3 / 2007-11-28\n\nThis release fixes four bugs --one being fairly serious, as it prevented\nrequire 'facets' from working at all.\n\nChanges:\n\n* 4 Bug Fixes\n\n    * Fixed oddity in Enumerable/collate.\n    * Fixed issue that prevented loading of facets.rb.\n    * Array#to_h used flatten, but it needed to be flatten(1).\n    * Move core/main.rb back to core/facets.rb as it conflicts with lib in more/.\n\n\n== 2.1.2 / 2007-11-22\n\nChanges:\n\n* Additions\n\n    * Added Exception#details.\n\n* General Enhancements\n\n    * Dir::multiglob no longer handels -/+ modifiers. Use FileList instead.\n\n* Administrative Adjustments\n\n    * Fixed task/install script.\n    * Improved task/changes.\n\n\n== 2.1.1 / 2007-11-16\n\nChanges:\n\n* Additions\n\n    * Added kernel/ergo.rb.\n    * Added pp_s.rb (Questionable addition, but we'll leave it for now.)\n    * Added validation.rb. This is here for Nitro's sake --better techinques may replace it in the future.\n    * Added Console::Logger to logger.rb (may be separated in future).\n    * Added option arity to command.rb.\n\n* Deprecations\n\n    * Removed tracepoint.rb.\n\n* Bug Fixes\n\n    * Fixed bug in command.rb that clobbered options.\n    * Fixed options bug in command.rb.\n\n\n== 2.1.0 / 2007-11-10\n\nMajor changes include a new and much-improved command.rb, a new BiCrypt\nclass for simple two-way crypotgraphy, as well as attr_reader!, \nattr_writer! and attr_accessor! for flag attributes, plus \nalias_xxx methods for all attr_xxx methods.\n\n\nChanges:\n\n* Additions\n\n    * Added BiCrypt class for simple two-way encryption.\n    * module/attr.rb now has attr_reader!, attr_writer! and attr_accessor!\n    * All attr_xxx methods have coresponding alias_xxx methods.\n    * Added UniversalOptions module.\n    * Added \"tester\" attribues attr_xxx!. Also added alias_xxx for all attr_xxx methods.\n\n* Enhancements\n\n    * command.rb has been completely rewritten. The API has changed completely!\n    * There is no longer a Commmand::Optoins class. Use Console::Arguments instead.\n    * Moved common alias methods from attr.rb to alias.rb.\n    * MasterCommand now passes (args, opts), until 1.9 is main stream.\n    * Cleaned up enumerable/permutation.rb\n    * Added -q option to zip method in ZipUtils.\n    * Ok. #p is back. This will in fact be in 1.9, so we're good.\n\n* Bug Fixes\n\n    * Fixed bug in Enumerable#cluster_by which returned nil instead of [].\n    * Fixed minor bug in arguments.rb that prevented proper repeat parameters.\n    * Fixed bug in to_console.\n    * Fixed bug in enumerable/cluster_by (returned nil instead of []).\n    * Fixed bug in Hash#- Thanks to Xavier Shay.\n    * Fixed to_h in Command::Options\n\n* Admin Changes\n\n    * Added dev/test\n    * Renamed RELEASE to WHATSNEW\n    * Added injecting test and cleaned up.\n    * Added comment for potential future #is.\n    * Added top-level log directory.\n    * Remove #q reference from RELEASE.\n    * Cleanup of test_initializer.rb.\n\n\n== 2.0.5 / 2007-11-07\n\nMinor release that fixes a couple of bugs and adds the last of\nadopted methods from Gavin Sinclair's Extensions project.\n\nAlso, renamed #p to #q, because of multiple args problem. \nI don't know how Ruby 1.9 plans to handle multiple args.\nWill deprecate for 1.9 anyway so doesn't matter much.\n\nChanges:\n\n* Additions\n\n    * Added final methods Gavin Sinclair's Extensions project. (Noah Gibbs)\n\n* General Improvements\n\n    * Made #alias_method_chain compatible with current ActiveSupport version.\n    * Rename #p to #q, because of multiple args problem.\n    * Allow Class#initializer to return the attribute names.\n\n* Bug Fixes\n\n    * Fixe return bug in hash/op.rb.\n    * Fixe bug with Dictionary#initialize.\n    * Fixe bug with Hash#-. (Xavier Shay)\n\n* Admin Adjustments\n\n    * Fixed package name in icli.yaml.\n    * Added name field to meta/icli.yaml.\n    * Added meta/icli.yaml.\n    * Added a RELEASE file to hold current release notes.\n    * Added log task.\n    * Added changelog file in doc/log/.\n\n\n== 2.0.4 / 2007-11-04\n\nChanges:\n\n* Unsorted Changes\n\n    * Up'd version to 2.0.4.\n    * Update task/groups.\n    * Removed extest task. We will no longer need it.\n    * Minor update to rdoc.yaml.\n    * Renamed old changelogs.\n\n\n== 2.0.3 / 2007-11-02\n\nChanges:\n\n* Unsorted Changes\n\n    * Touch up to methods task.\n    * Update rsync filter\n    * Minor updates fixing issues highlighted by running crosstest.\n    * Many minor bug fixes after running against crosstest.\n    * Added usage support for __foo options.\n    * Fixed a many a test after running against crosstest.\n    * Removed load task. It did not isolate the libs, so wasn't effective.\n    * Added a number of new tasks.\n    * Rename SMTP_TLS to Smtp_tls for Rdocs.\n    * Moved rdoc.yaml to config/.\n    * moved task/config to task/config/general.\n    * Update tasks.\n\n\n2007-11-01  transami\n\nChanges:\n\n* Unsorted Changes\n\n    * Added array/only,  symbol/to_proc (where did it go?) and hash/select.\n\n    * Update roll file.\n    * Moved test_command_options to test_command.\n    * Update dictionary test to check dup and autohash.\n    * Fixed autohash and dup bugs.\n    * Verbatim support for Rails' version of #alias_method_chain.\n    * Remove site/ directory.\n    * Moved rsync filter up too.\n    * Moved doc/site/ up to doc/.\n    * Added javascript directory to doc/.\n\n    * Updates across the board.\n    * Updates to stylize and command.rb.\n    * Made facets.rb a shortcut to facets/facets.rb (this is for Rolls, better way?)\n    * Oh smack. Lots of stuff fixed.\n\n    * Remove version.txt. No longer needed.\n    * Removed meta/project.yaml, replaced by facets roll file.\n\n    * Modifications to command.rb, snapshot and rbsystem.\n        * Merged command.rb and command_options.rb into command.rb.\n        * Added to_data aliases to snapshot.rb\n        * Minor additions to rbsystem. Rather than System, maybe Ruby?\n\n    * Removed embedded test from overload.rb.\n    * Allow OpenStruct#initialize to take a setter block.\n    * Downloader needs 'wb' flag rather then just 'w'.\n    * Fixed typo and removed embedded test.\n    * Fixed bug in command_options.rb, putting the class back in the Console namespace.\n\n    * improved module/traits.rb\n\n\n== 2.0.2 / 2007-10-08\n\nChanges:\n\n* Administrative Changes\n\n    * Cleaned up some test and updated version to 2.0.2\n    * Update methods to eleminate duplicate file names between lib/core and lib/methods\n\n\n== 2.0.1 / 2007-10-06\n\nChanges:\n\n* Unsorted Changes\n\n    * updated version to 2.0.1\n    * minor bugs fixes\n    * update methods task to display each file as it process it\n    * added benchmarks for some enumerable methods.\n    * moved demo/bench/bench_factorial to an demo/bench/integer subclass\n    * added Erik Veenstra to AUTHORS for work on enumerable/group_by and cluster_by\n    * minor improvement to test task to specifically read test_*.rb files\n    * removed enumerable/partition.rb\n    * move enumerable/partition.rb methods to collect.rb.\n    * Improved Integer#of.\n    * Minor improvements to collect.rb and partition.rb\n    * Deprecated nonuniq!, bug fixed cluster_by and aliased group_by and partition_by.\n    * Renamed Enumerable#partition_by to group_by (like Ruby 1.9) and fixed bug in cluster_by.\n\n\n== 2.0.0 / 2007-10-02\n\nChanges:\n\n* General Enhancements\n\n    * Added Oliver Renaud to the AUTHORS list (oops!)\n\n* Bug Fixes\n\n    * Fix requires in `cut.rb` and `attributes.rb`.\n    * Fix `String#brief` in `format.rb`.\n\n* Unsorted Changes\n\n    * removed 1stClassMethod from \"more\" docs\n    * removed 1stClassMethod as a rdoc target (now in Core target)\n    * update install and rdoc tasks\n    * moved string/test_index.rb to string/test_nchar.rb\n    * updated indexable tests\n    * update string.rb to include string/nchar.rb\n    * moved index.rb to nchar.rb\n    * clean up string/index.rb\n    * moved facets.rb to fore directory\n    * add comment to groups task\n    * added groups task\n    * updated all extrension group files (array.rb, binding.rb, etc.)\n    * uncapitalize meta files\n    * update methods task a bit more, plus related configuration\n    * updated methods task\n    * removed lib/core --this is generated content (may be renamed too)\n    * added load and stats tasks\n    * update install task --this replaces setup b/c of Facets' special install needs\n    * update project file\n    * removed lib/facets\n    * moved remaining libs to fore (will later consider an additional subdivision)\n    * move facets/fore to fore/facets\n    * move facets/more to more/facets\n    * added ;ob/core, more and fore\n    * move memorize\n    * removed io and net directories\n    * moved io/redirect.rb to more/ioredirect.rb and net/smtp_tls.rb and net/uploadutils.rb libs to more too.\n    * few more libs moved to more/ directory\n    * moved all the most obvious more libs to the more directory\n    * moved fore \"grouping\" libs to fore directory\n    * moved \"fore\" libs to fore directory\n    * create for and more directories (yes, you know what's coming ;)\n    * renamed remain.rb (was main_as_module.rb) to just main.rb\n    * improved rdoc task and project.yaml file\n    * better docs for OpenObject\n    * improved method hiding\n    * documentation touch ups\n    * fixes for conversion.rb rather than conversions.rb\n    * updated to website docs\n    * moved demos to demo/sample\n    * added bench and sample dir to demo\n    * moved spy.html to light.html\n    * menum change to webpage, fixed core doc link\n    * moved metadata files to meta/ (info/ or box/ would be better?)\n    * updated test_conversion.rb for to_h/to_hash\n    * reverse_each instead of each for after advice in advice.rb\n    * final fix to to_h/to_hash discrepency\n    * added a Path and Root features to Pathname (good idea?)\n    * update advice.rb test and moved old cut test to dev/scrap\n    * updated advice; removed preinitialize.rb to trinkets project (it was too expiremental)\n    * command_filter.rb needs to considered/developed; moved to dev/new/\n    * fixed interface.rb fo singelton methods\n    * updates to tests\n    * whole lot of small bug fixes\n    * add tests to revision control\n    * removed old cut test (moved to dev/scrap)\n    * working on tests\n    * added read.rb (taken from readwrite.rb)\n    * split readwrite.rb into read.rb and write.rb\n    * remove string/unpack.rb, offset can be had using '@' format instead\n    * renamed conversions.rb to conversion.rb, fixed some requires\n    * improved attr.rb\n    * some cleanup of enumerable extensions\n    * setup annotations demo\n    * add non-embedded tests\n    * finally brough over toadcode prototype.rb and cleaned it up enough to be useful\n    * removed annotations subdir\n    * moved annotations/ann.rb and attr.rb to annotations.rb and attributes.rb\n    * remove annotations.rb\n    * moved annotations/settings.rb up a dir\n    * remove settings.rb\n    * chnaged multiton_id(e) to multiton_id(*e,&b)\n    * updated test task\n    * added Christoph Rippel to authors lists\n    * added doc header to new multiton class\n    * update to new version of multiton\n    * playing around with multiton2.rb\n    * renamed dev/try to dev/new\n    * created dev/old to temporarily house old versions of libs that have been replaced.\n    * fixed quick.html documentation\n    * used old wiki.gif as email.gif instead\n    * fixed config.yaml publish entry\n    * some minor updates to index.html\n    * moved site to doc/site\n    * update to publish task\n    * updates of tasks\n    * added kernel/report.rb to hold debug/warn extensions.\n    * renamed reporting.rb to silence.rb\n    * update reporting.rb (created report.rb from it)\n    * task work\n    * clean up dev finis\n    * cleanup dev just a bit more\n    * continue cleanup of dev directory\n    * moved dev/twiki to misc/\n    * removed dev/core\n    * moved require_directory.rb to misc/\n    * added dev/misc for code scraps that might be useful but are not straight lib or task code\n    * more dev changes\n    * organize dev better\n    * cleanup of dev continues\n    * cleanup of dev dir\n    * clean up dev dir more\n    * some cleanup of dev directory\n    * almost completed advice lib\n    * added comment about possible update\n    * deprecate instance_send and instance_map\n    * work on rdoc task\n    * work on rdoc task\n    * added dev/cut dir\n    * no reason to track .config\n    * clean up trunk\n    * added todo comment\n    * added advice.rb to replace old aspects.rb\n    * removed aspects.rb (sucked), added prototype.rb (infancy) and adjusted to class_extension.rb\n    * removed #to_roman (now part of the English project)\n    * cont. work on aop and cuts\n    * fixed IMG tag bug\n    * added yaml.rb\n    * move #here convenience method to binding/eval (separate?)\n    * added in order to remove kernel/misc.rb\n    * consolidate string/regesc\n    * added module/methods\n    * updates to include and attr\n    * fixed Range#umbrella\n    * more organization of docs\n    * orginizing docs\n    * update val.rb\n    * added proc/fn.rb (from kernel/misc.rb) and fixed typo in compose.rb\n    * moved misc.rb to val.rb\n    * better organization of some kernel methods\n    * moved #here alias to eval.rb\n    * minor updates and some bug fixes (modspace what broke)\n    * removed file/yaml.rb in favor or just yaml.rb\n    * moved this to facets/yaml.rb\n    * work on aop system\n    * Added aop.rb, and cut.r and recursive.rb\n    * moved cut.rb to dev (old version will be deprecated)\n    * added to_hash to Dictionary, and minor mods to others\n    * oops, no need for enumerator directory\n    * moved threaded_send.rb to mapsend.rb\n    * moved threaded_send out of enumerable/ dir\n    * updates to elementor.rb\n    * merged instance_map into threaded_send\n    * removed map_send\n    * merging map_send with threaded_send\n    * cont work on elementwise methods\n    * divide elementwise functions betwee two libs\n    * uniq.rb is merged into count.rb\n    * removed count.rb (uniq.rb will become count.rb)\n    * continued refinement of enumerable extensions\n    * general improvements to the organization of enumerable extensions\n    * removed facets/cli dir\n    * moved all cli libs from facets/cli to facets/\n    * moved cli support files to facets locations\n    * moved cli lib to facets main (also modified functor)\n    * renamed hash/reverse to hash/merge (it contains #reverse_merge)\n    * remove instance_intercept (moced to Trinkets project)\n    * continued modification of those tasky tools\n    * removed lib/more (this is it!)\n    * moved M-Z of more/facets to facets (this is it!)\n    * moved A-L of more/facets to facets (this is it!)\n    * removed lib/core (this is it!)\n    * moved lib/core/facets.rb to lib/facets.rb (this is it!)\n    * moved lib/core/facets to lib/facets (this is it!)\n    * added file/yaml.rb\n    * added a list of libraries considered \"core\"\n    * continued work on build tools\n    * change tools for core/more convergence (so help us god!)\n    * added conversion requirement to some core libs\n    * update methods task\n    * update quick.html to mirror rdoc changes --still needs work though\n    * remove old rdoc task\n    * added rdoc section (minimal) to tool/config.yaml\n    * nope. remove site/rdoc\n    * add rdoc dir, should we?\n    * remove site/rdoc in preperation for new way\n    * facets.rb belongs to core/\n    * renamed some doc files\n    * removed src/core\n    * move src/core/lin to lib/core\n    * added kernel/constant\n    * remove src/core/web\n    * moving more of core to top-level (svn sucks!)\n    * moving core support files to top-level\n    * removed src/more\n    * move src/more/lib to lib/more\n    * made lib dir (to replace src)\n    * added settings.rb which points to annotations/settings.rb\n    * moved svn to annotations/ subdir\n    * moved dev files to top-level as part of more transition\n    * temporarily removed dev/more\n    * moved annotations demo to demo dir\n    * added demo folder\n    * add dev/more\n    * remove struct again! (stupid svn)\n    * moved file to top-level doc as part of more transisiton\n    * bullshit svn crap\n    * ann moved back to more (strongly considering annotations for it's own project)\n    * build moved back to more\n    * aop moved back to more\n    * cast moved back to more\n    * crypt moved back to more\n    * exts moved back to more\n    * file moved back to more\n    * meta moved back to more\n    * misc moved back to more\n    * model moved back to more\n    * struct moved to back to more\n    * moved sync back to more\n    * moved commandoptions.rb to command_options.rb\n    * rewrote command and command options libs\n    * initial Subversion import\n\n\n== 1.8.54 / 2007-03-21\n\nThe following list of changes also includes changes from intrim releases,\n`1.8.51 / 2007-02-19`, `1.8.49 / 2007-02-16`, `1.8.20 / 2007-02-06` and\n`1.8.8  / 2007-01-31`. Unfortuantely the transition form darcs to git, \nled to some information loss in this regard.\n\nChanges:\n\n* Unsorted Changes:\n\n    * added reqiure to ostruct.rb test\n    * fix to command.rb's initializer\n    * fixed bug with times.rb beginning_of_year and beginning_of_month\n    * replaced pqueue and heap with new working class (thanks to Olivier Renaud)\n    * fixed bug in ormsupport.rb (this will be moved out of facets in next release)\n    * added empty? to dictionary (removed old subclass of Hash)\n    * significant improvements to command.rb thanks to Tyler Rick\n    * added tests to elementwise and tap\n    * fixed test for elementwise and op_tilde_self\n    * added enumerable/map_send\n    * added thread_map and thread_map_send thanks to greg\n    * added operator \"~@\" for enumerable/elementwise\n    * added more/consoleutils.rb\n    * added string/cleave\n    * added capitalize_all thanks to Richard Laugesen\n    * cartesian_product is an alias of enumerable/cart\n    * added array pad thanks to Richard Laugesen\n    * added kernel/tap\n    * fixed test/unit load issues\n    * converted facet/ requires to facets/core or facets/more as needed\n    * further improvements to arguments.rb (looking good!)\n    * improved symbol/self/generate\n    * bug fix kernel/autoreload arguments needed to be in opposite order\n    * add to_xoxo\n    * removed bad character codes in multiplier.rb\n    * used yaml to allow json.rb to work for all object in general\n    * improvements to functor (note: is to_a and to_proc okay?)\n    * add test to string/bytes.rb\n    * bug fix to nilclass/op_cmp\n    * fixed enumerable/op_pow to use enumerable/cart\n    * added array/op_div\n    * adjustments to xmlbuilder and htmlbuilder dur to buildingblock changes\n    * improved buildingblock.rb\n    * simplified interface of arguments.rb (still a little more to do)\n    * improvements/simplifications to Dir.multiglob\n    * added new authors to list\n    * fixed misspelling of behavior.rb (was bahvior.rb)\n    * removed #own from base list in facets.rb (really need a standard for \"singleton class\")\n    * minor adjustments to uploadutils\n    * fixed bug in aspects.rb that would not handle args of wrapped method\n    * Symbol#to_s optimization, had to remove freeze\n    * updates to fileutils/stage (stage worth keeping?)\n    * update to credits\n    * fix bug in kernel/ask, returns more than one character\n    * cleanup of enumerbale/graph (no effective change)\n    * new super fast enumerable/cart by Thomas Hafner (replaces #cross)\n    * improved multiglob rountines (accept '+' and '-' prefixes)\n    * No longer will track project file via scm until it settles\n    * fixed bug in attr_tester, thanks Dov!\n    * added weekdays to times.rb thanks to Ryan Platte and Dave Hoover\n    * improvements to dictionary.rb (no longer a subclass of Hash) thanks Jan!\n    * re-replace openhash with openobject\n    * improvements to ann.rb and ann_attr.rb. works, yea!\n    * fixed bug in string/singular.rb\n    * changed enumerable/cross into enumerable/cart and cartesian_product\n    * openobject returns (openhash was a bad name, thanks george)\n    * moved enumerable/cross to enumerable/cart (cartesian_product)\n\n\n== 1.8.0 / 2007-01-24\n\nThe list of changes also includes intrim releases `1.7.46 September 8, 2006`,\n`1.7.38 August 31, 2006`, and `1.7.30 August 23, 2006`.\n\nChanges:\n\n* Additions\n\n    * Add facets/automatic.rb, very cool, albiet experimental, way to load core methods automatically!\n    * added hash/insert; like store but only if key isn't already present\n    * added module/include_and_extend\n    * added File::mulitglob_sum; accumulates file patterns, and accepts '+' and '-' prefixes\n    * added module/module_method; like module_function but makes method public\n    * added module/include_function_module; attempts to properly include one function_module into another\n    * kernel/yaml convenience method for YAML::load\n    * added kernel/supress; supress errors while executing a block (nice DHH!)\n    * added symbol/chomp, like string#chomp\n    * added proc/to_h; converts an assignment proc into a hash\n    * proc/bind; bind a proc to an object, returning a method\n    * added module/prepend; provides dyanamic method wraps for modules, and static wraps for classes\n    * added module/new; use a module as if it were a class\n    * added module/alias_accessor\n    * kernel/instance_class; yet anouther meta_class name, but a more sensicle name this one\n    * added kernel/populate; populates an object's inst. vars from a hash or assingment block\n    * added kernel/daemonize; one last thanks to DHH!\n    * added enumerable/injecting; like inject but automatically returns the memo from the block\n    * added kernel/object_send, a true public-only send method\n    * added kernel/silence_stream; output to null device; thanks DHH!\n    * added kernel/instance_values, thanks DHH!\n    * added Config:inspect for rbconfig\n    * added hash/pairs_at (aking to values_at)\n    * added _why's metaid methods (meta_class, meta_eval, etc.)\n    * added kernel/enable_warnings to complement silence_warinings\n    * added integer/to_roman\n    * added logical operators for hash (and/or)\n    * array/to_path convert ans array to a path string\n    * array/index takes a block\n    * added fileutils/compress; very simple convenience methods for archiving folders\n    * added fileutils/stage adn staged, a means of transfering files accoring to preset rules\n    * added kernel/ask, simply command to get console input\n    * added populate.rb, mixin for classes that need on a basic initializer\n    * added version_number.rb (a specialized tuple)\n    * added uploadutils.rb\n    * added Joel VanderWerf's great script.rb script\n    * added Austin's minitar.rb --it's just too damn useful!\n    * added htmlfilter.rb very nice html escape class\n    * added dependency.rb, allwos method to have dependend execution (like rake tasks)\n    * added arguments.rb this is for parsing console command arguments\n    * add new version of annotations: ann.rb and ann_attr.rb\n    * added File::yaml? to roughly detect if a file is a yaml file\n\n* Renamed Features\n\n    * Rename #superior to #super_at.\n    * OpenObject = OpenHash (OpenObject will eventually be deprecated)\n    * renamed quaclass to qua_class\n    * renamed openobject to openhash !!!\n\n* Deprecations\n\n    * had to remove taskable.rb for now (implementation won't work as toplevel include)\n    * deprecated (yored) kernel/own, yet another term for the singleton class\n    * removed dataobject.rb (was never used)\n    * deprecated (yored!) module/inject; what a silly method\n    * deprecated kernel/require_facet (no longer needed)\n\n* Bug Fixes\n\n    * Fix enumerable/partition_by.\n    * memoize should now work at toplevel\n    * minor bug fix to httpaccess\n\n* General Enhancments\n\n    * Add buildingblock.rb, replacing builderobject.rb.\n    * HtmlBuilder and XMLBuilder aer now based on BuildingBlock\n    * adjust require for \"yored\" files\n    * minor improvements to basic object (object_self to access kernel methods)\n    * ostuct adjustment, use #instance_delegate to get underneth the open access\n    * module/include_as is now based on module/namespace (thanks Pit!)\n    * minor adjustments to methods for (class<<self;self;end)\n    * facets.rb now references facets/sys.rb\n    * adjust old annotation.rb (now in yore) to use openhash\n\n* Admin Adjustments\n\n    * further updates to project info file (need to stop versioning this)\n    * deprecated (yored) builderobject.rb (poor implementation)\n    * moved deprecated #facet_require to yore lib\n    * minor doc change to instance_intercept.rb\n    * doc change to methodfilter.rb (maybe deprecat in future)\n    * moved old module/namespace implementation to yore\n\n* Unsorted Changes\n\n    * moved plugin.rb to ratchets/library project\n    * proper credit for multiton goes to Ara T. Howard!!!! Also improvements.\n    * remove library.rb (move to ratchets/library project)\n    * updated autovivify.rb to use openhash\n    * improvement to command.rb\n    * imporved time/stamp\n    * reimplemented proc/to_method for more sensible behavior\n    * reimplemented module/namespace, very clever thanks to pit captain\n    * added module_load and module_require, e.g. load into and require into\n    * reimplemented instance_exec, should be much improved\n    * doc updates to inflect.rb\n    * updates to Hash op_add, reverse_merge, and rekey\n    * each_slice is now just an alias via enumerator & fixes to partition_by\n    * minor adjusment to multiglob\n    * modified all.rb (not recommended!) to require facets/sys\n    * modifications to project information file (should this be versioned?)\n    * created yore lib to store deprecated features (good idea!)\n    * modified PROJECT info file\n    * added module class/module_load and _require\n    * remove facet/ redirect lib from darcs repository\n    * OpenObject is now OpenHash (OpenObject still exist for backcompat)\n    * kernel/returning is a stub for kernel/with\n    * added proc/update as alias for #call per Tim Pease use of Proc as Observable\n    * added behavior.rb by Nobuyoshi Nakada (plan to improve)\n    * rewrote taskable.rb using classes to represent tasks; it is much improved\n    * openobject.rb doc updates\n    * major update to functor which is now a subclass of Proc (should be faster)\n    * improvements to dictionary.rb to go along with additions of first and last\n    * small improvements to command.rb\n    * removed uses of __class__ for object_class and solidified usaged of #as in basicobject.rb\n    * deprecated ostruct shadow methods (i.e __table__) in favor of #instance methods\n    * added test to module/alias_method_chain\n    * imporvements to instance_exec thanks to Mauricio Fernandez\n    * improvements to kernel/send_as\n    * improvements to kernel/as\n    * minor doc addition to kernel/as\n    * fixed syntax in hash/op_add.rb\n    * imporvements to hash/partition_by thanks to Gregory of Laurel\n    * added Mauricio Fernandez to authors\n    * added addtional work library lore\n    * moved \"calibre\" project information files\n    * moved a number of \"in the works\" libs to ToadCode project\n    * removed predicate.rb, an expiremental logic system, and moved to ToadCode\n    * Added plugin.rb, an indirect require mechinism, ie. a plugin system\n    * remove one.rb and moved to ToadCode project, this was just silly/fun library\n    * Added library.rb which is a library ledger system (used to be roll.rb)\n    * added kernel/with which instance_eval's a block on with's subject\n    * rekey is an improved version of normalize_keys (ie. the basis of symbolize_keys)\n    * multiglob is like glob but handles a list of patterns\n    * proper access to openstruct's underlying table\n    * minor adjustment to taskable.rb\n    * minor adjustment to #dresner docs\n    * minor adjustment to #as\n    * simple doc addition to setup.rb\n    * doc fixes and losening toplevel constraint to Object in taskable\n    * made OpenObject #update and #merge public; added to_hash\n    * minor \"public\" fix to main_as_object\n    * removed unorder_store and store_only; added first/last to dictionary\n    * continued improvements to command.rb\n      added some new callbacks such as option_missing;\n      also handles method_missing properly now\n    * minor adjustments to module::@+\n    * added string/rewrite\n    * test fixes to module/include_as\n    * documentation fix for class_extension\n    * minor edit to supermethod (also finish #superior removal)\n    * cleanup kernel/set_with code\n    * update kernel/metaclass can now take a block\n    * added hash#+ and hash#- (op_add and op_sub)\n    * added cache to enumerable/every\n    * minor updates to facets.rb\n    * removed kernel/superior (silly name)\n    * minor modifications ot PROJECT file\n    * [add] more/autovivify.rb expiremental lib.\n    * [update] Minor fix to command.rb to not use Kernel methods as subcommands.\n    * [update] Work on annotation.rb to improve support for :self.\n    * [deprecate] enumerable/permute.rb (replaced by permutation) and minor test fix to linkedlist.rb\n    * [added] linkedlist.rb (thanks Kirk Haines!)\n    * [added] enumerable/sum (thanks to Gavin Kistner)\n    * [added] array/each_combo and combos (Eunumerable.combinations will be deprecated eventually)\n    * [rename] changed enumerable/permute to permutation\n    * [update] annotation.rb, fixed :self key\n    * [added] pathname/op_div\n    * [deprecated] hash/each.rb\n    * [removed] hash/each.rb, this variation of Hash#each is too \"dangerous\" in practice\n    * [update] module/self/op_add.rb: fixed inclusion order\n    * annotation.rb, return annotations of self when key is :self [updated]\n    * module/self/op_add.rb and op_sub.rb - traits like features [added]\n    * minor improvemtns to module/clone_using and integrate\n    * command.rb: minor change to docs [update]\n    * openobject.rb (added NilClass#to_openobject) [update]\n    * enumerable/each_slice.rb [replace]\n      Ruby already has #each_slice if you require 'enumerator'. And for 1.9,\n      I believe, this will be present automatically. So Facets' each_slice\n      has been replaced with a simple redirection to require 'enumerator'.\n      Ruby's version is slightly different in that it won't check arity if\n      a slice count is not given. For this, use enumerable/each_by.\n    * array/delete_at.rb [removed]\n      Ruby's Array class already has a #delete_at method,\n      although this is another method at odds with Hash.\n      Use #delete_values_at instead.\n    * moved File.bitbucket to File.null (but bitbucket was so \"fun\"! ;)\n    * added nilclass/to_path\n    * added kernel/load_local\n    * added kernel/callee\n    * added enumerable/eachn, integer/each and integer/of\n    * re-added array/delete_values_at\n    * added filetest/self/root\n    * added cache.rb\n    * moved Dir.bitbucket to File.bitbucket\n    * removed task file in favor of sake based util/\n    * added main_as_module\n    * added doublemetaphone (Thanks Lawrence Philps!)\n    * rewrote taskable.rb\n    * minor doc fix to association.rb\n    * added symbol/to_s which caches the result for speed up\n    * additions and adjusments related to hash/delete_at\n    * added Dir.bitbucket\n    * update to array/op_fetch to include op_store\n    * updated docs and util tasks\n    * minor changes\n    * added filesystem.rb\n    * taskable should now work at the toplevel too\n    * still working the organization as Reap/Sake change\n    * started setting project tasks up for sake\n    * updates to enumerable each_slice\n    * updated names of meta files\n    * added trace to command.rb\n    * organizational changes\n\n\n== 1.7.0 / 2006-07-25\n\nChanges:\n\n* Additions\n\n    * Add Infinity class.\n    * Add `tkxml.rb`.\n    * Add singleton Annotations.\n    * Add Cuts implimentation.\n\n* Improvements\n\n    * Improve command.rb with error catch. (Jonas)\n    * Improve #wrap_method, no need to undef method before redefining.\n    * Improve String#singular and plural.\n    * Improve #normalize_keys to take a proc instead of a \"send\" parameter.\n\n* Bug Fixes\n\n    * Add #to_a to OpenObject.\n    * Fix instance_interception test.\n\n* Miscellaneous Enhancements\n\n    * Add hash/op_div.rb and array/op_div.rb.\n    * Allow tasks to do arguments (all dependent tasks must take same args)\n    * Separated integer/op_mul from compose, op_mul now composes and Integer#of.\n    * added work dir to repo\n\n    * doc cleanup\n\n    * remove kernel/called and fixed callee,__callee__ and __method__.\n    * just about prefected OpenObject\n    * keys_to_sym to symbolize_keys usage\n    * remove explore dir, perhaps better to do without midstage\n\n\n\n== 1.6.0 / 2006-07-20\n\nChanges:\n\n    * PrivateAccess expiremental class\n\n* Additions\n\n    * Add Hash#reverse_merge (from ActiveSupport).\n\n    * adjustments to stringify_keys, record normalize_keys\n    * work on other Hash subclasses Dictionary, OpenCascade, and Hash#having_fallback features\n    * added some core methods enumerable#divide, array and hash op_div, kernel/meta\n    * deprecated generate_method_name and generate_instance_method_name\n    * Hash methods keys_to_s and keys_to_sym to stringify_keys and symbolize_keys\n    Both now depend on normalize_keys\n    * rewrote openobject as a subclass of Hash with a method filter\n    * rewrote annotation.rb and moved into more/\n    * add meta docs to darcs\n    * added Jan Molic's Debugger(Logger) to explore\n    * calibre task (worth the effort?)\n    * added Symbol::generate\n    * remove generate_method_name methods\n    ** removed kernel/generate_method_name\n    ** removed moodule/generate_instance_method_name\n    Neither were thread safe.\n    * new implementation of openobject cont.\n    * updated dictionary class\n    1. created subclass AutoDictionary, now used by Dictionary.auto\n    2. deprecated ::key_new and :value_new, use ::new.by_key and ::new.by_value instead.\n    3. Retained ::alpha but changed ::auto_key to ::auto_alpha.\n    * new implementation of openobject in Facets/EXPLORE\n    * Added deep_clone (thanks Jan Molic)\n    * project metadata work adjustments\n    * minor update to tagiterator.rb\n    * add _darcs expection to FileList\n    * fix to nilclass#status (accept single parameter)\n    * added Hash.auto (thanks Jan Molic)\n    * remove blankslate alias to basicobject\n    * added annotation and instance_intercept to Facets/EXPLORE\n    * added Kernel#to_data\n    * add Daniel Berger's Hash#to_stuct\n    * moved ValueHolder in snapshot.rb to Snapshot::ValueHolder\n    * minor bug fix to alias_method_chain\n    * fix compatiblity with Reap\n    * improved Proc#to_method and Kernel#instance_exec\n    * added instance_exec (duh)\n    * added object_clone and object_dup object_ methods are intended as non-overridable (although you cna if you must).\n    * no Configuration alias for Settings\n    * added facets/explore libs\n    * added settings.rb from glue\n    * openobject uses self[] instead of @table[]\n    also update proj/infp to start 1.5 series\n\n* Deprecations\n\n    * Deprecate BasicObject.\n\n\n== 1.4.5 / 2006-07-05\n\nChanges:\n\n* Additions\n\n    * Add NilClass#status which allows a message to be passed through a failure chain.\n    * Add Module#alias_method_chain from Rails as a cleveridiom for module-based method wrapping.\n      A limited solution, but since there's no standard solution as of yet, well support til then.\n    * Add Enumerable#cascade, cascade a list of actions on each  element of an enumerable.\n\n\n== 1.4.4 / 2006-07-03\n\nChanges:\n\n* Bug Fixes\n\n    * The `#method missing` in HtmlBuilder effected by BasicObject fix\n      (use __self__.method instead of __method__).\n\n* Improved Features\n\n    * Update Functor, by adding `@self = function.binding.self`.\n\n* Renamed Features\n\n    * Change WebAgent to Web.\n\n* Deprecations\n\n    * Removed hash/keys_to_iv b/c it is a poor name. Since the alternative\n      of #keys_to_instance_variables conveys the wrong idea, decided to just\n      get rid of this. Instead use the hash#variablize_keys which is also\n      Rails compatibile.\n\n\n== 1.4.3 / 2006-06-27\n\n* Administrative Adjustments\n\n    * Move ProjectInfo to proj/info.\n    * Better arrangment of repository,\n\n\n== 1.4.2 / 2006-06-21\n\nThis release makes adjustments to BasicObject, further reducing unhidden\nmethods. Among them __object__, __method__ and #as. Also added `#method_missing`\nthat detects shadow methods and rebinds them to Object. Keep in mind that woun't\nhelp you if you override method_missing which is typical for this class.\n\nThis release also marks the first use of Darcs version control manager!\n\nChanges:\n\n* Improvements\n\n    * Adjusted BasicObject slightly, further reducing unhidden methods.\n\n* Bug Fixes\n\n    * Fixed bug in BasicObject#__self__.\n\n* Administrative Adjustments\n\n    * Started using Darcs --finally!\n    * Transition to Darcs has interupted ChangeLog though :(\n\n\n== 1.4.0 / 2006-05-05\n\nChanges:\n\n* Additions\n\n    * Added Cookie, HTTP and HTTPAccess of ...'s library.\n    * Added OpenCascade, which is like OpenObject but chains access.\n    * Added MenTalguy's lazy.rb which include's Future and Promise classes.\n    * Added task.rb, which provides a Rake interface compatible task\n      system, but that can be used in any code.\n\n* Improvements\n\n    * Improved Hash#traverse (it now does all traversing before yielding).\n    * Console::Command also now supports run-on flags (eg. -xvzf).\n    * Updated tuple.rb so that when a string is converted to a Tuple (#to_t)\n      the values wll be made integers if they are composed of only numbers.\n      If you need all strings you can use a block since the block bypasses\n      this auto coercement, eg. to_t{ |v| v }.\n\n* Renames\n\n    * OpenObject's __get__ and __set__ methods have been changed\n      to __fetch__ and __store__ to correspond to the Hash methods.\n\n* Depreacetions\n\n    * kernel/me, kernel/methodname and kernel/method_name have all been\n      deprecated in favor of the 1.9 standard kernel/__method__ and\n      kernel/__callee__.\n    * Console::Application is deprecated and is no longer an alias for\n      Console::Command.\n    * More's classinherit.rb has been removed, and classmethods.rb will be\n      too in  another version or two. You should transition all uses of\n      these to core/module/class_extension.rb.\n\n\n== 1.3.1 / 2006-04-17\n\nChanges:\n\n* Deprecations\n\n    * Deprecated string/to_arr.\n\n* General Enhancements\n\n    * Slightly adjusted string#to_a.\n\n\n== 1.3.0 / 2006-04-05\n\nChanges:\n\n* Additions\n\n  * Ported parts of Nitro's Glue library to Facets.\n      * more/aspects.rb\n      * core/module/on_included.rb\n      * core/module/expirable.rb\n      * core/enumerable/accumulate.rb\n  * Added xoxo.rb, json.rb and rtals.rb.\n\n* General Enhancements\n\n  * Repaired missing data files for units.rb.\n  * Moved cattr methods from module/ to class/.\n  * mattr methods are in limbo at the moment (they were aliases for cattr).\n\n\n== 1.2.1 / 2006-03-29\n\nChanges:\n\n* Renamed Features\n\n  * kernel/meta has been renamed to kernel/instance\n\n\n== 1.2.0 / 2006-03-24\n\nChanges:\n\n* Additions\n\n  * Add zimba.tm's string/modulize, pathize and methodize.\n  * Add some Gem methods, self/active?, self/gemspec, self/gempath.\n\n\n== 1.0.3 / 2006-02-10\n\nChanges:\n\n* Additions\n\n    * Added _why's Array#modulo.\n\n* General Enhancements\n\n    * Last ditch attempt to keep facets and calibre as one project.\n\n\n== 1.0.0 / 2005-12-04\n\nOkay. Now we've finally hit our 1.0.0 relase. Yea! Does it desrve 1.0 at this point?\nAh, well close enough. Mainly there won't be anymore silly development names ;)\n\nChanges:\n\n* General Enhancements\n\n    * Sped up string#similarity.\n    * By popular protest deprecated usage of \"AClass.use Facets, :amethod\".\n    * Created nicer layout of facets/support, /group, /english (one day /method).\n    * Odd sets of facets have been move to facets/group/, eg. facets/group/inflect.\n    * All is now well preped for a Rolls release shoud that come about.\n\n\n","format":"text/rdoc"},"/NOTICE.rdoc":{"!":"document","path":"NOTICE.rdoc","name":"NOTICE.rdoc","mtime":null,"text":"= COPYRIGHT NOTICES\n\n== Ruby Facets\n\nCopyright:: (c) 2005,2011 Thomas Sawyer\n\n  Copyright (c) 2005,2011 Thomas Sawyer\n\n  You may distribute this software under the same terms as Ruby.\n\n\n== Ruby/Extensions\n\nCopyright:: (c) 2004 Gavin Sinclair\nLicense:: Ruby\n\n  Copyright (c) 2004 Gavin Sinclair\n\n  Ruby/Extensions (extensions.rubyforge.org) is copyrighted free software\n  created and maintained by Gavin Sinclair (gsinclair@soyabean.com.au) and\n  released under the same license as Ruby.\n\n  THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS OR\n  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE.\n\n\n==  Nitro/Glue\n\nCopyright:: (c) 2006, George Moschovitis\nLicense:: BSD-3-Clause\n\n  Copyright (c) 2006, George Moschovitis\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  * Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name of the <ORGANIZATION> nor the names of its contributors\n    may be used to endorse or promote products derived from this software\n    without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  POSSIBILITY OF SUCH DAMAGE.\n\n\n== ActiveSupport\n\nCopyright:: (c) 2005-2011 David Heinemeier Hansson\nLicense:: MIT\nWebsite:: http://rails.org\n\n  Copyright (c) 2005-2011 David Heinemeier Hansson\n\n  Permission is hereby granted, free of charge, to any person obtaining\n  a copy of this software and associated documentation files (the\n  \"Software\"), to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sell copies of the Software, and to\n  permit persons to whom the Software is furnished to do so, subject to\n  the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n== Ruby Treasures\n\nCopyright:: (c) 2001 Paul Brannan\nLicense:: Ruby License\n\n  Ruby Treasures 0.1\n  Copyright (c) 2001 Paul Brannan <paul@atdesk.com>\n\n  You may distribute this software under the same terms as Ruby (see the file\n  RUBY.txt that was distributed with this library).\n\n\n== Metaid\n\nCopyright:: (c) why the lucky stiff\n\n  Copyright (c) why the lucky stiff\n\n\n== CLAP\n\nCopyright:: (c) 2010 Michel Martens\nLicense:: MIT\nWebsite:: https://github.com/soveran/clap\n\n  Copyright (c) 2010 Michel Martens\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  of the Software, and to permit persons to whom the Software is furnished to\n  do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n\n== String#natcmp\n\nCopyright:: (c) 2003 by Alan Davies\nLicense:: Custom\n\n  String#natcmp is based on Martin Pool's \"Natural Order String Comparison\"\n  originally written in C. (see http://sourcefrog.net/projects/natsort/)\n\n  This implementation is Copyright (C) 2003 by Alan Davies\n  <cs96and_AT_yahoo_DOT_co_DOT_uk>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n\n  3. This notice may not be removed or altered from any source distribution.\n\n","format":"text/rdoc"},"/RUBY.txt":{"!":"document","path":"RUBY.txt","name":"RUBY.txt","mtime":null,"text":"\n Ruby Facets\n\n Copyright (c) 2005,2010 Thomas Sawyer\n\n\n THE RUBY LICENSE\n (http://www.ruby-lang.org/en/LICENSE.txt)\n\n You may redistribute this software and/or modify it under either the terms of\n the GPL (see below), or the conditions below:\n\n  1. You may make and give away verbatim copies of the source form of the\n     software without restriction, provided that you duplicate all of the\n     original copyright notices and associated disclaimers.\n\n  2. You may modify your copy of the software in any way, provided that\n     you do at least ONE of the following:\n\n       a) place your modifications in the Public Domain or otherwise\n          make them Freely Available, such as by posting said\n          modifications to Usenet or an equivalent medium, or by allowing\n          the author to include your modifications in the software.\n\n       b) use the modified software only within your corporation or\n          organization.\n\n       c) rename any non-standard executables so the names do not conflict\n          with standard executables, which must also be provided.\n\n       d) make other distribution arrangements with the author.\n\n  3. You may distribute the software in object code or executable\n     form, provided that you do at least ONE of the following:\n\n       a) distribute the executables and library files of the software,\n          together with instructions (in the manual page or equivalent)\n          on where to get the original distribution.\n\n       b) accompany the distribution with the machine-readable source of\n          the software.\n\n       c) give non-standard executables non-standard names, with\n          instructions on where to get the original software distribution.\n\n       d) make other distribution arrangements with the author.\n\n  4. You may modify and include the part of the software into any other\n     software (possibly commercial).  But some files in the distribution\n     are not written by the author, so that they are not under these terms.\n\n     For the list of those files and their copying conditions, see the\n     file LEGAL.\n\n  5. The scripts and library files supplied as input to or produced as\n     output from the software do not automatically fall under the\n     copyright of the software, but belong to whomever generated them,\n     and may be sold commercially, and may be aggregated with this\n     software.\n\n  6. THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS OR\n     IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n     PURPOSE.\n\n ----------------------------------------------------------------------------\n\n\n                   GNU GENERAL PUBLIC LICENSE\n                     Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n The licenses for most software are designed to take away your\n freedom to share and change it.  By contrast, the GNU General Public\n License is intended to guarantee your freedom to share and change free\n software--to make sure the software is free for all its users.  This\n General Public License applies to most of the Free Software\n Foundation's software and to any other program whose authors commit to\n using it.  (Some other Free Software Foundation software is covered by\n the GNU Library General Public License instead.)  You can apply it to\n your programs, too.\n\n When we speak of free software, we are referring to freedom, not\n price.  Our General Public Licenses are designed to make sure that you\n have the freedom to distribute copies of free software (and charge for\n this service if you wish), that you receive source code or can get it\n if you want it, that you can change the software or use pieces of it\n in new free programs; and that you know you can do these things.\n\n To protect your rights, we need to make restrictions that forbid\n anyone to deny you these rights or to ask you to surrender the rights.\n These restrictions translate to certain responsibilities for you if you\n distribute copies of the software, or if you modify it.\n\n For example, if you distribute copies of such a program, whether\n gratis or for a fee, you must give the recipients all the rights that\n you have.  You must make sure that they, too, receive or can get the\n source code.  And you must show them these terms so they know their\n rights.\n\n We protect your rights with two steps: (1) copyright the software, and\n (2) offer you this license which gives you legal permission to copy,\n distribute and/or modify the software.\n\n Also, for each author's protection and ours, we want to make certain\n that everyone understands that there is no warranty for this free\n software.  If the software is modified by someone else and passed on, we\n want its recipients to know that what they have is not the original, so\n that any problems introduced by others will not reflect on the original\n authors' reputations.\n\n Finally, any free program is threatened constantly by software\n patents.  We wish to avoid the danger that redistributors of a free\n program will individually obtain patent licenses, in effect making the\n program proprietary.  To prevent this, we have made it clear that any\n patent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\n modification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n   0. This License applies to any program or other work which contains\n a notice placed by the copyright holder saying it may be distributed\n under the terms of this General Public License.  The \"Program\", below,\n refers to any such program or work, and a \"work based on the Program\"\n means either the Program or any derivative work under copyright law:\n that is to say, a work containing the Program or a portion of it,\n either verbatim or with modifications and/or translated into another\n language.  (Hereinafter, translation is included without limitation in\n the term \"modification\".)  Each licensee is addressed as \"you\".\n\n Activities other than copying, distribution and modification are not\n covered by this License; they are outside its scope.  The act of\n running the Program is not restricted, and the output from the Program\n is covered only if its contents constitute a work based on the\n Program (independent of having been made by running the Program).\n Whether that is true depends on what the Program does.\n\n    1. You may copy and distribute verbatim copies of the Program's\n  source code as you receive it, in any medium, provided that you\n  conspicuously and appropriately publish on each copy an appropriate\n  copyright notice and disclaimer of warranty; keep intact all the\n  notices that refer to this License and to the absence of any warranty;\n  and give any other recipients of the Program a copy of this License\n  along with the Program.\n\n  You may charge a fee for the physical act of transferring a copy, and\n  you may at your option offer warranty protection in exchange for a fee.\n\n    2. You may modify your copy or copies of the Program or any portion\n  of it, thus forming a work based on the Program, and copy and\n  distribute such modifications or work under the terms of Section 1\n  above, provided that you also meet all of these conditions:\n\n      a) You must cause the modified files to carry prominent notices\n      stating that you changed the files and the date of any change.\n\n      b) You must cause any work that you distribute or publish, that in\n      whole or in part contains or is derived from the Program or any\n      part thereof, to be licensed as a whole at no charge to all third\n      parties under the terms of this License.\n\n      c) If the modified program normally reads commands interactively\n      when run, you must cause it, when started running for such\n      interactive use in the most ordinary way, to print or display an\n      announcement including an appropriate copyright notice and a\n      notice that there is no warranty (or else, saying that you provide\n      a warranty) and that users may redistribute the program under\n      these conditions, and telling the user how to view a copy of this\n      License.  (Exception: if the Program itself is interactive but\n      does not normally print such an announcement, your work based on\n      the Program is not required to print an announcement.)\n  \n  These requirements apply to the modified work as a whole.  If\n  identifiable sections of that work are not derived from the Program,\n  and can be reasonably considered independent and separate works in\n  themselves, then this License, and its terms, do not apply to those\n  sections when you distribute them as separate works.  But when you\n  distribute the same sections as part of a whole which is a work based\n  on the Program, the distribution of the whole must be on the terms of\n  this License, whose permissions for other licensees extend to the\n  entire whole, and thus to each and every part regardless of who wrote it.\n  \n  Thus, it is not the intent of this section to claim rights or contest\n  your rights to work written entirely by you; rather, the intent is to\n  exercise the right to control the distribution of derivative or\n  collective works based on the Program.\n  \n  In addition, mere aggregation of another work not based on the Program\n  with the Program (or with a work based on the Program) on a volume of\n  a storage or distribution medium does not bring the other work under\n  the scope of this License.\n  \n    3. You may copy and distribute the Program (or a work based on it,\n  under Section 2) in object code or executable form under the terms of\n  Sections 1 and 2 above provided that you also do one of the following:\n  \n      a) Accompany it with the complete corresponding machine-readable\n      source code, which must be distributed under the terms of Sections\n      1 and 2 above on a medium customarily used for software interchange; or,\n  \n      b) Accompany it with a written offer, valid for at least three\n      years, to give any third party, for a charge no more than your\n      cost of physically performing source distribution, a complete\n      machine-readable copy of the corresponding source code, to be\n      distributed under the terms of Sections 1 and 2 above on a medium\n      customarily used for software interchange; or,\n  \n      c) Accompany it with the information you received as to the offer\n      to distribute corresponding source code.  (This alternative is\n      allowed only for noncommercial distribution and only if you\n      received the program in object code or executable form with such\n      an offer, in accord with Subsection b above.)\n  \n  The source code for a work means the preferred form of the work for\n  making modifications to it.  For an executable work, complete source\n  code means all the source code for all modules it contains, plus any\n  associated interface definition files, plus the scripts used to\n  control compilation and installation of the executable.  However, as a\n  special exception, the source code distributed need not include\n  anything that is normally distributed (in either source or binary\n  form) with the major components (compiler, kernel, and so on) of the\n  operating system on which the executable runs, unless that component\n  itself accompanies the executable.\n  \n  If distribution of executable or object code is made by offering\n  access to copy from a designated place, then offering equivalent\n  access to copy the source code from the same place counts as\n  distribution of the source code, even though third parties are not\n  compelled to copy the source along with the object code.\n  \n    4. You may not copy, modify, sublicense, or distribute the Program\n  except as expressly provided under this License.  Any attempt\n  otherwise to copy, modify, sublicense or distribute the Program is\n  void, and will automatically terminate your rights under this License.\n  However, parties who have received copies, or rights, from you under\n  this License will not have their licenses terminated so long as such\n  parties remain in full compliance.\n  \n    5. You are not required to accept this License, since you have not\n  signed it.  However, nothing else grants you permission to modify or\n  distribute the Program or its derivative works.  These actions are\n  prohibited by law if you do not accept this License.  Therefore, by\n  modifying or distributing the Program (or any work based on the\n  Program), you indicate your acceptance of this License to do so, and\n  all its terms and conditions for copying, distributing or modifying\n  the Program or works based on it.\n  \n    6. Each time you redistribute the Program (or any work based on the\n  Program), the recipient automatically receives a license from the\n  original licensor to copy, distribute or modify the Program subject to\n  these terms and conditions.  You may not impose any further\n  restrictions on the recipients' exercise of the rights granted herein.\n  You are not responsible for enforcing compliance by third parties to\n  this License.\n  \n    7. If, as a consequence of a court judgment or allegation of patent\n  infringement or for any other reason (not limited to patent issues),\n  conditions are imposed on you (whether by court order, agreement or\n  otherwise) that contradict the conditions of this License, they do not\n  excuse you from the conditions of this License.  If you cannot\n  distribute so as to satisfy simultaneously your obligations under this\n  License and any other pertinent obligations, then as a consequence you\n  may not distribute the Program at all.  For example, if a patent\n  license would not permit royalty-free redistribution of the Program by\n  all those who receive copies directly or indirectly through you, then\n  the only way you could satisfy both it and this License would be to\n  refrain entirely from distribution of the Program.\n  \n  If any portion of this section is held invalid or unenforceable under\n  any particular circumstance, the balance of the section is intended to\n  apply and the section as a whole is intended to apply in other\n  circumstances.\n  \n  It is not the purpose of this section to induce you to infringe any\n  patents or other property right claims or to contest validity of any\n  such claims; this section has the sole purpose of protecting the\n  integrity of the free software distribution system, which is\n  implemented by public license practices.  Many people have made\n  generous contributions to the wide range of software distributed\n  through that system in reliance on consistent application of that\n  system; it is up to the author/donor to decide if he or she is willing\n  to distribute software through any other system and a licensee cannot\n  impose that choice.\n  \n  This section is intended to make thoroughly clear what is believed to\n  be a consequence of the rest of this License.\n  \n    8. If the distribution and/or use of the Program is restricted in\n  certain countries either by patents or by copyrighted interfaces, the\n  original copyright holder who places the Program under this License\n  may add an explicit geographical distribution limitation excluding\n  those countries, so that distribution is permitted only in or among\n  countries not thus excluded.  In such case, this License incorporates\n  the limitation as if written in the body of this License.\n  \n    9. The Free Software Foundation may publish revised and/or new versions\n  of the General Public License from time to time.  Such new versions will\n  be similar in spirit to the present version, but may differ in detail to\n  address new problems or concerns.\n  \n  Each version is given a distinguishing version number.  If the Program\n  specifies a version number of this License which applies to it and \"any\n  later version\", you have the option of following the terms and conditions\n  either of that version or of any later version published by the Free\n  Software Foundation.  If the Program does not specify a version number of\n  this License, you may choose any version ever published by the Free Software\n  Foundation.\n  \n    10. If you wish to incorporate parts of the Program into other free\n  programs whose distribution conditions are different, write to the author\n  to ask for permission.  For software which is copyrighted by the Free\n  Software Foundation, write to the Free Software Foundation; we sometimes\n  make exceptions for this.  Our decision will be guided by the two goals\n  of preserving the free status of all derivatives of our free software and\n  of promoting the sharing and reuse of software generally.\n  \n                              NO WARRANTY\n  \n    11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n  PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n  REPAIR OR CORRECTION.\n  \n    12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\n  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n  POSSIBILITY OF SUCH DAMAGES.\n  \n                      END OF TERMS AND CONDITIONS\n \n","format":"text/plain"},"/lib/standard/facets/platform.rb":{"!":"script","path":"lib/standard/facets/platform.rb","name":"platform.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/platform.rb","language":"text/x-ruby"},"/lib/standard/facets/pathname.rb":{"!":"script","path":"lib/standard/facets/pathname.rb","name":"pathname.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/pathname.rb","language":"text/x-ruby"},"/lib/standard/facets/cloneable.rb":{"!":"script","path":"lib/standard/facets/cloneable.rb","name":"cloneable.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/cloneable.rb","language":"text/x-ruby"},"/lib/standard/facets/cgi.rb":{"!":"script","path":"lib/standard/facets/cgi.rb","name":"cgi.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/cgi.rb","language":"text/x-ruby"},"/lib/standard/facets/opesc.rb":{"!":"script","path":"lib/standard/facets/opesc.rb","name":"opesc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/opesc.rb","language":"text/x-ruby"},"/lib/standard/facets/zlib.rb":{"!":"script","path":"lib/standard/facets/zlib.rb","name":"zlib.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/zlib.rb","language":"text/x-ruby"},"/lib/standard/facets/continuation.rb":{"!":"script","path":"lib/standard/facets/continuation.rb","name":"continuation.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/continuation.rb","language":"text/x-ruby"},"/lib/standard/facets/date.rb":{"!":"script","path":"lib/standard/facets/date.rb","name":"date.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/date.rb","language":"text/x-ruby"},"/lib/standard/facets/multiton.rb":{"!":"script","path":"lib/standard/facets/multiton.rb","name":"multiton.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/multiton.rb","language":"text/x-ruby"},"/lib/standard/facets/interval.rb":{"!":"script","path":"lib/standard/facets/interval.rb","name":"interval.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/interval.rb","language":"text/x-ruby"},"/lib/standard/facets/getoptlong.rb":{"!":"script","path":"lib/standard/facets/getoptlong.rb","name":"getoptlong.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/getoptlong.rb","language":"text/x-ruby"},"/lib/standard/facets/basicobject.rb":{"!":"script","path":"lib/standard/facets/basicobject.rb","name":"basicobject.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/basicobject.rb","language":"text/x-ruby"},"/lib/standard/facets/thread.rb":{"!":"script","path":"lib/standard/facets/thread.rb","name":"thread.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/thread.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils.rb":{"!":"script","path":"lib/standard/facets/fileutils.rb","name":"fileutils.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils.rb","language":"text/x-ruby"},"/lib/standard/facets/shellwords.rb":{"!":"script","path":"lib/standard/facets/shellwords.rb","name":"shellwords.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/shellwords.rb","language":"text/x-ruby"},"/lib/standard/facets/multipliers.rb":{"!":"script","path":"lib/standard/facets/multipliers.rb","name":"multipliers.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/multipliers.rb","language":"text/x-ruby"},"/lib/standard/facets/nullclass.rb":{"!":"script","path":"lib/standard/facets/nullclass.rb","name":"nullclass.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/nullclass.rb","language":"text/x-ruby"},"/lib/standard/facets/erb.rb":{"!":"script","path":"lib/standard/facets/erb.rb","name":"erb.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/erb.rb","language":"text/x-ruby"},"/lib/standard/facets/find.rb":{"!":"script","path":"lib/standard/facets/find.rb","name":"find.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/find.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/tail.rb":{"!":"script","path":"lib/standard/facets/fileutils/tail.rb","name":"tail.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/tail.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/which.rb":{"!":"script","path":"lib/standard/facets/fileutils/which.rb","name":"which.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/which.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/whereis.rb":{"!":"script","path":"lib/standard/facets/fileutils/whereis.rb","name":"whereis.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/whereis.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/ln_r.rb":{"!":"script","path":"lib/standard/facets/fileutils/ln_r.rb","name":"ln_r.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/ln_r.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/cp_rx.rb":{"!":"script","path":"lib/standard/facets/fileutils/cp_rx.rb","name":"cp_rx.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/cp_rx.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/amass.rb":{"!":"script","path":"lib/standard/facets/fileutils/amass.rb","name":"amass.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/amass.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/wc.rb":{"!":"script","path":"lib/standard/facets/fileutils/wc.rb","name":"wc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/wc.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/slice.rb":{"!":"script","path":"lib/standard/facets/fileutils/slice.rb","name":"slice.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/slice.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/outofdate.rb":{"!":"script","path":"lib/standard/facets/fileutils/outofdate.rb","name":"outofdate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/outofdate.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/stage.rb":{"!":"script","path":"lib/standard/facets/fileutils/stage.rb","name":"stage.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/stage.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/safe_ln.rb":{"!":"script","path":"lib/standard/facets/fileutils/safe_ln.rb","name":"safe_ln.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/safe_ln.rb","language":"text/x-ruby"},"/lib/standard/facets/fileutils/head.rb":{"!":"script","path":"lib/standard/facets/fileutils/head.rb","name":"head.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/fileutils/head.rb","language":"text/x-ruby"},"/lib/standard/facets/net/http.rb":{"!":"script","path":"lib/standard/facets/net/http.rb","name":"http.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/net/http.rb","language":"text/x-ruby"},"/lib/standard/facets/math.rb":{"!":"script","path":"lib/standard/facets/math.rb","name":"math.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math.rb","language":"text/x-ruby"},"/lib/standard/facets/yaml.rb":{"!":"script","path":"lib/standard/facets/yaml.rb","name":"yaml.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/yaml.rb","language":"text/x-ruby"},"/lib/standard/facets/equitable.rb":{"!":"script","path":"lib/standard/facets/equitable.rb","name":"equitable.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/equitable.rb","language":"text/x-ruby"},"/lib/standard/facets/set.rb":{"!":"script","path":"lib/standard/facets/set.rb","name":"set.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/set.rb","language":"text/x-ruby"},"/lib/standard/facets/tuple.rb":{"!":"script","path":"lib/standard/facets/tuple.rb","name":"tuple.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/tuple.rb","language":"text/x-ruby"},"/lib/standard/facets/uri.rb":{"!":"script","path":"lib/standard/facets/uri.rb","name":"uri.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/uri.rb","language":"text/x-ruby"},"/lib/standard/facets/ostruct.rb":{"!":"script","path":"lib/standard/facets/ostruct.rb","name":"ostruct.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/ostruct.rb","language":"text/x-ruby"},"/lib/standard/facets/argvector.rb":{"!":"script","path":"lib/standard/facets/argvector.rb","name":"argvector.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/argvector.rb","language":"text/x-ruby"},"/lib/standard/facets/instantiable.rb":{"!":"script","path":"lib/standard/facets/instantiable.rb","name":"instantiable.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/instantiable.rb","language":"text/x-ruby"},"/lib/standard/facets/memoizable.rb":{"!":"script","path":"lib/standard/facets/memoizable.rb","name":"memoizable.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/memoizable.rb","language":"text/x-ruby"},"/lib/standard/facets/digest/salted_digest.rb":{"!":"script","path":"lib/standard/facets/digest/salted_digest.rb","name":"salted_digest.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/digest/salted_digest.rb","language":"text/x-ruby"},"/lib/standard/facets/digest/base64digest.rb":{"!":"script","path":"lib/standard/facets/digest/base64digest.rb","name":"base64digest.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/digest/base64digest.rb","language":"text/x-ruby"},"/lib/standard/facets/rbconfig.rb":{"!":"script","path":"lib/standard/facets/rbconfig.rb","name":"rbconfig.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/rbconfig.rb","language":"text/x-ruby"},"/lib/standard/facets/digest.rb":{"!":"script","path":"lib/standard/facets/digest.rb","name":"digest.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/digest.rb","language":"text/x-ruby"},"/lib/standard/facets/timer.rb":{"!":"script","path":"lib/standard/facets/timer.rb","name":"timer.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/timer.rb","language":"text/x-ruby"},"/lib/standard/facets/enumargs.rb":{"!":"script","path":"lib/standard/facets/enumargs.rb","name":"enumargs.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/enumargs.rb","language":"text/x-ruby"},"/lib/standard/facets/strscan.rb":{"!":"script","path":"lib/standard/facets/strscan.rb","name":"strscan.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/strscan.rb","language":"text/x-ruby"},"/lib/standard/facets/math/summed_sqdevs.rb":{"!":"script","path":"lib/standard/facets/math/summed_sqdevs.rb","name":"summed_sqdevs.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/summed_sqdevs.rb","language":"text/x-ruby"},"/lib/standard/facets/math/sech.rb":{"!":"script","path":"lib/standard/facets/math/sech.rb","name":"sech.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/sech.rb","language":"text/x-ruby"},"/lib/standard/facets/math/coth.rb":{"!":"script","path":"lib/standard/facets/math/coth.rb","name":"coth.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/coth.rb","language":"text/x-ruby"},"/lib/standard/facets/math/cdf.rb":{"!":"script","path":"lib/standard/facets/math/cdf.rb","name":"cdf.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/cdf.rb","language":"text/x-ruby"},"/lib/standard/facets/math/acoth.rb":{"!":"script","path":"lib/standard/facets/math/acoth.rb","name":"acoth.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/acoth.rb","language":"text/x-ruby"},"/lib/standard/facets/math/sec.rb":{"!":"script","path":"lib/standard/facets/math/sec.rb","name":"sec.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/sec.rb","language":"text/x-ruby"},"/lib/standard/facets/math/lgamma.rb":{"!":"script","path":"lib/standard/facets/math/lgamma.rb","name":"lgamma.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/lgamma.rb","language":"text/x-ruby"},"/lib/standard/facets/math/sign.rb":{"!":"script","path":"lib/standard/facets/math/sign.rb","name":"sign.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/sign.rb","language":"text/x-ruby"},"/lib/standard/facets/math/sum.rb":{"!":"script","path":"lib/standard/facets/math/sum.rb","name":"sum.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/sum.rb","language":"text/x-ruby"},"/lib/standard/facets/math/pstd.rb":{"!":"script","path":"lib/standard/facets/math/pstd.rb","name":"pstd.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/pstd.rb","language":"text/x-ruby"},"/lib/standard/facets/math/acsch.rb":{"!":"script","path":"lib/standard/facets/math/acsch.rb","name":"acsch.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/acsch.rb","language":"text/x-ruby"},"/lib/standard/facets/math/epsilon.rb":{"!":"script","path":"lib/standard/facets/math/epsilon.rb","name":"epsilon.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/epsilon.rb","language":"text/x-ruby"},"/lib/standard/facets/math/csc.rb":{"!":"script","path":"lib/standard/facets/math/csc.rb","name":"csc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/csc.rb","language":"text/x-ruby"},"/lib/standard/facets/math/ceil.rb":{"!":"script","path":"lib/standard/facets/math/ceil.rb","name":"ceil.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/ceil.rb","language":"text/x-ruby"},"/lib/standard/facets/math/sqr.rb":{"!":"script","path":"lib/standard/facets/math/sqr.rb","name":"sqr.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/sqr.rb","language":"text/x-ruby"},"/lib/standard/facets/math/pow.rb":{"!":"script","path":"lib/standard/facets/math/pow.rb","name":"pow.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/pow.rb","language":"text/x-ruby"},"/lib/standard/facets/math/gini_coefficient.rb":{"!":"script","path":"lib/standard/facets/math/gini_coefficient.rb","name":"gini_coefficient.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/gini_coefficient.rb","language":"text/x-ruby"},"/lib/standard/facets/math/exp2.rb":{"!":"script","path":"lib/standard/facets/math/exp2.rb","name":"exp2.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/exp2.rb","language":"text/x-ruby"},"/lib/standard/facets/math/gamma.rb":{"!":"script","path":"lib/standard/facets/math/gamma.rb","name":"gamma.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/gamma.rb","language":"text/x-ruby"},"/lib/standard/facets/math/atkinson_index.rb":{"!":"script","path":"lib/standard/facets/math/atkinson_index.rb","name":"atkinson_index.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/atkinson_index.rb","language":"text/x-ruby"},"/lib/standard/facets/math/rmd.rb":{"!":"script","path":"lib/standard/facets/math/rmd.rb","name":"rmd.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/rmd.rb","language":"text/x-ruby"},"/lib/standard/facets/math/min.rb":{"!":"script","path":"lib/standard/facets/math/min.rb","name":"min.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/min.rb","language":"text/x-ruby"},"/lib/standard/facets/math/median.rb":{"!":"script","path":"lib/standard/facets/math/median.rb","name":"median.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/median.rb","language":"text/x-ruby"},"/lib/standard/facets/math/acsc.rb":{"!":"script","path":"lib/standard/facets/math/acsc.rb","name":"acsc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/acsc.rb","language":"text/x-ruby"},"/lib/standard/facets/math/approx_equal.rb":{"!":"script","path":"lib/standard/facets/math/approx_equal.rb","name":"approx_equal.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/approx_equal.rb","language":"text/x-ruby"},"/lib/standard/facets/math/linsolve.rb":{"!":"script","path":"lib/standard/facets/math/linsolve.rb","name":"linsolve.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/linsolve.rb","language":"text/x-ruby"},"/lib/standard/facets/math/theil_index.rb":{"!":"script","path":"lib/standard/facets/math/theil_index.rb","name":"theil_index.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/theil_index.rb","language":"text/x-ruby"},"/lib/standard/facets/math/log2.rb":{"!":"script","path":"lib/standard/facets/math/log2.rb","name":"log2.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/log2.rb","language":"text/x-ruby"},"/lib/standard/facets/math/round.rb":{"!":"script","path":"lib/standard/facets/math/round.rb","name":"round.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/round.rb","language":"text/x-ruby"},"/lib/standard/facets/math/asec.rb":{"!":"script","path":"lib/standard/facets/math/asec.rb","name":"asec.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/asec.rb","language":"text/x-ruby"},"/lib/standard/facets/math/root.rb":{"!":"script","path":"lib/standard/facets/math/root.rb","name":"root.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/root.rb","language":"text/x-ruby"},"/lib/standard/facets/math/sinc.rb":{"!":"script","path":"lib/standard/facets/math/sinc.rb","name":"sinc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/sinc.rb","language":"text/x-ruby"},"/lib/standard/facets/math/asech.rb":{"!":"script","path":"lib/standard/facets/math/asech.rb","name":"asech.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/asech.rb","language":"text/x-ruby"},"/lib/standard/facets/math/beta.rb":{"!":"script","path":"lib/standard/facets/math/beta.rb","name":"beta.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/beta.rb","language":"text/x-ruby"},"/lib/standard/facets/math/max.rb":{"!":"script","path":"lib/standard/facets/math/max.rb","name":"max.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/max.rb","language":"text/x-ruby"},"/lib/standard/facets/math/factorial.rb":{"!":"script","path":"lib/standard/facets/math/factorial.rb","name":"factorial.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/factorial.rb","language":"text/x-ruby"},"/lib/standard/facets/math/lcm.rb":{"!":"script","path":"lib/standard/facets/math/lcm.rb","name":"lcm.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/lcm.rb","language":"text/x-ruby"},"/lib/standard/facets/math/stderr.rb":{"!":"script","path":"lib/standard/facets/math/stderr.rb","name":"stderr.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/stderr.rb","language":"text/x-ruby"},"/lib/standard/facets/math/kldivergence.rb":{"!":"script","path":"lib/standard/facets/math/kldivergence.rb","name":"kldivergence.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/kldivergence.rb","language":"text/x-ruby"},"/lib/standard/facets/math/tgamma.rb":{"!":"script","path":"lib/standard/facets/math/tgamma.rb","name":"tgamma.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/tgamma.rb","language":"text/x-ruby"},"/lib/standard/facets/math/exp10.rb":{"!":"script","path":"lib/standard/facets/math/exp10.rb","name":"exp10.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/exp10.rb","language":"text/x-ruby"},"/lib/standard/facets/math/percentile.rb":{"!":"script","path":"lib/standard/facets/math/percentile.rb","name":"percentile.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/percentile.rb","language":"text/x-ruby"},"/lib/standard/facets/math/acot.rb":{"!":"script","path":"lib/standard/facets/math/acot.rb","name":"acot.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/acot.rb","language":"text/x-ruby"},"/lib/standard/facets/math/sqsolve.rb":{"!":"script","path":"lib/standard/facets/math/sqsolve.rb","name":"sqsolve.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/sqsolve.rb","language":"text/x-ruby"},"/lib/standard/facets/math/abs.rb":{"!":"script","path":"lib/standard/facets/math/abs.rb","name":"abs.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/abs.rb","language":"text/x-ruby"},"/lib/standard/facets/math/mean.rb":{"!":"script","path":"lib/standard/facets/math/mean.rb","name":"mean.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/mean.rb","language":"text/x-ruby"},"/lib/standard/facets/math/std.rb":{"!":"script","path":"lib/standard/facets/math/std.rb","name":"std.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/std.rb","language":"text/x-ruby"},"/lib/standard/facets/math/csch.rb":{"!":"script","path":"lib/standard/facets/math/csch.rb","name":"csch.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/csch.rb","language":"text/x-ruby"},"/lib/standard/facets/math/variance.rb":{"!":"script","path":"lib/standard/facets/math/variance.rb","name":"variance.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/variance.rb","language":"text/x-ruby"},"/lib/standard/facets/math/cot.rb":{"!":"script","path":"lib/standard/facets/math/cot.rb","name":"cot.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/cot.rb","language":"text/x-ruby"},"/lib/standard/facets/math/gcd.rb":{"!":"script","path":"lib/standard/facets/math/gcd.rb","name":"gcd.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/gcd.rb","language":"text/x-ruby"},"/lib/standard/facets/math/delta.rb":{"!":"script","path":"lib/standard/facets/math/delta.rb","name":"delta.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/delta.rb","language":"text/x-ruby"},"/lib/standard/facets/math/floor.rb":{"!":"script","path":"lib/standard/facets/math/floor.rb","name":"floor.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/floor.rb","language":"text/x-ruby"},"/lib/standard/facets/math/amd.rb":{"!":"script","path":"lib/standard/facets/math/amd.rb","name":"amd.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/amd.rb","language":"text/x-ruby"},"/lib/standard/facets/math/pvariance.rb":{"!":"script","path":"lib/standard/facets/math/pvariance.rb","name":"pvariance.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/math/pvariance.rb","language":"text/x-ruby"},"/lib/standard/facets/random.rb":{"!":"script","path":"lib/standard/facets/random.rb","name":"random.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/standard/facets/random.rb","language":"text/x-ruby"}}
