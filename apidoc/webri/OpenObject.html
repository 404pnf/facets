<br/><b>Class: OpenObject < Hash</b><hr />
<h1>OpenObject</h1>
OpenObject is very similar to Ruby's own OpenStruct, but it offers some useful advantages. With OpenStruct slots with the same name's as predefined Object methods can not be used. With OpenObject any slot can be defined, OpendObject is also a bit faster becuase it is based on a Hash, not method signitures.<p />
Because OpenObject is a subclass of Hash, it can do just about everything a Hash can do, except that most public methods have been made protected and thus available only internally or via #send.<p />
OpenObject will also clobber any method for which a slot is defined. Even generally very important methods can be clobbered, like instance_eval. So be aware of this. OpenObject should be used in well controlled scenarios.<p />
If you wish to pass an OpenObject to a routine that normal takes a Hash, but are uncertain it can handle the distictions properly you can convert easily to a Hash using #to_hash! and the result will automatically be converted back to an OpenObject on return.<p />
<pre>  o = OpenObject.new(:a=&amp;gt;1,:b=&amp;gt;2)
  o.as_hash!{ |h| h.update(:a=&amp;gt;6) }
  o #=&amp;gt; #&amp;lt;OpenObject {:a=&amp;gt;6,:b=&amp;gt;2}&amp;gt;
</pre>
Finally, unlike a regular Hash, all OpenObject's keys are symbols and all keys are converted to such using #to_sym on the fly.<p />
<hr />
<p />
<h2>Constants:</h2>
PUBLIC_METHODS = /(^__|^instance_|^object_|^\W|^as$|^send$|^class$|\?$)/<br />
<p />
<h2>Class methods:</h2>
[], new<p />
<h2>Instance methods:</h2>
==, [], []=, as_hash!, default!, define_slot, delete, each, fetch, initialize_copy, inspect, merge, method_missing, protect_slot, store, to_a, to_h, to_hash, to_openobject, to_proc, update<br/><br/>